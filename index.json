[{"categories":["Blog"],"date":"October 25, 2024","permalink":"https://mahigarg.github.io/blogs/optionset-vs-enum-in-swift/","section":"blogs","summary":"In Swift, both OptionSet and enum are common patterns for representing options or states. While they share some similarities, they serve different purposes and have distinct use cases. In this blog, we’ll explore OptionSet and enum in Swift, examine their unique characteristics, and look at practical examples to help clarify when to use each.\nWhat is an OptionSet? An OptionSet in Swift is a protocol that provides a way to represent multiple independent options or flags as a single variable using a bitwise format. OptionSet works well for cases where multiple options can be combined together, such as permissions, configurations, or state flags.\nDefining an OptionSet To create an OptionSet, define a struct that conforms to the OptionSet protocol and assign each option a unique power-of-two value so they can be combined without interference.\nstruct NotificationOptions: OptionSet { let rawValue: Int static let email = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 0) // 0001 static let sms = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 1) // 0010 static let push = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 2) // 0100 static let inApp = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 3) // 1000 static let all: NotificationOptions = [.email, .sms, .push, .inApp] } Here:\nEach option is represented by a unique bit. The options can be combined with bitwise OR (|), enabling multiple options to be stored in a single OptionSet instance. Using OptionSet An OptionSet allows combining and checking options efficiently:\nvar settings: NotificationOptions = [.email, .push] // Check for options print(settings.contains(.email)) // true print(settings.contains(.sms)) // false // Add and remove options settings.insert(.sms) settings.remove(.push) print(settings.contains(.push)) // false When to Use OptionSet When multiple options can be enabled independently. When options need to be combined into a single variable. When options are frequently checked, added, or removed. What is an enum? An enum in Swift is a type that defines a group of related values. Unlike an OptionSet, an enum represents mutually exclusive cases—only one of the values can be assigned to a variable at any time.\nDefining an enum Here’s an example of an enum that represents different types of notifications:\nenum NotificationType { case email case sms case push case inApp } Using enum An enum is particularly useful when you need a variable to be one of several defined cases. Here’s an example:\nvar notification: NotificationType = .email switch notification { case .email: print(\u0026#34;Email notification\u0026#34;) case .sms: print(\u0026#34;SMS notification\u0026#34;) case .push: print(\u0026#34;Push notification\u0026#34;) case .inApp: print(\u0026#34;In-App notification\u0026#34;) } With an enum, each case is unique and cannot be combined with other cases. Unlike OptionSet, assigning multiple values to a single enum variable isn’t possible because it only represents one value at a time.\nWhen to Use enum When options are mutually exclusive (only one option can be chosen at a time). When each case represents a unique, distinct state. When you want to use switch statements to handle different values. OptionSet vs. Enum: Key Differences Feature OptionSet Enum Purpose Represents multiple, independent options Represents mutually exclusive values Combination Options can be combined using bitwise operations Only one value at a time Data Storage Stores options as bits, allowing multiple flags Stores only one case in a variable Checking Options Use .contains, .insert, .remove Use switch or if statements Common Use Cases Permissions, flags, settings State representation, event type, modes Example Scenarios Let’s look at a few examples to clarify when to use OptionSet vs. enum in real scenarios.\nScenario 1: File Permissions (OptionSet) When handling file permissions like read, write, and execute, you’ll likely want to combine multiple permissions. An OptionSet is ideal for this use case.\nstruct FilePermissions: OptionSet { let rawValue: Int static let read = FilePermissions(rawValue: 1 \u0026lt;\u0026lt; 0) // 0001 static let write = FilePermissions(rawValue: 1 \u0026lt;\u0026lt; 1) // 0010 static let execute = FilePermissions(rawValue: 1 \u0026lt;\u0026lt; 2) // 0100 static let all: FilePermissions = [.read, .write, .execute] } var permissions: FilePermissions = [.read, .write] permissions.insert(.execute) // Adding execute permission print(permissions.contains(.read)) // true print(permissions.contains(.execute)) // true Here, each permission is independent, so an OptionSet works perfectly to allow combining permissions efficiently.\nScenario 2: Transportation Mode (Enum) Imagine an app where users can select a mode of transportation. Since a user can only use one mode at a time, an enum would be suitable.\nenum TransportationMode { case walking case biking case driving case publicTransit } var mode: TransportationMode = .driving switch mode { case .walking: print(\u0026#34;User is walking.\u0026#34;) case .biking: print(\u0026#34;User is biking.\u0026#34;) case .driving: print(\u0026#34;User is driving.\u0026#34;) case .publicTransit: print(\u0026#34;User is using public transit.\u0026#34;) } With an enum, each case is distinct, and only one can be assigned to mode at a time, making it ideal for mutually exclusive options.\nScenario 3: App Notification Settings (Combined Use of OptionSet and Enum) In some cases, using both OptionSet and enum can be advantageous. Imagine an app that lets users choose the type of notifications they receive and allows combining multiple settings like enabling sound, vibration, or badge notifications. Here’s how we could use both:\nenum NotificationType { case message case friendRequest case activity } struct NotificationOptions: OptionSet { let rawValue: Int static let sound = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 0) static let vibration = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 1) static let badge = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 2) } var notificationType: NotificationType = .message var notificationSettings: NotificationOptions = [.sound, .vibration] // Handling notification type switch notificationType { case .message: print(\u0026#34;Message notification.\u0026#34;) case .friendRequest: print(\u0026#34;Friend request notification.\u0026#34;) case .activity: print(\u0026#34;Activity notification.\u0026#34;) } // Checking notification settings if notificationSettings.contains(.sound) { print(\u0026#34;Sound enabled.\u0026#34;) } if notificationSettings.contains(.badge) { print(\u0026#34;Badge enabled.\u0026#34;) } This example shows how enum helps define the type of notification, while OptionSet allows combining multiple settings for that notification. It’s a powerful combination for scenarios where you need both mutually exclusive options and combinable settings.\nSummary Feature OptionSet Enum Definition Protocol for defining combinable options Type that represents a fixed set of cases Combines Values Yes, using bitwise operations No, only one case at a time Checking Values .contains, .insert, .remove switch or if statements Best Use Cases Permissions, flags, multiple independent settings State representation, mutually exclusive options Example Notification options, file permissions Transport modes, notification type Conclusion Choosing between OptionSet and enum depends on your requirements. If you need to represent multiple independent options that can be combined, OptionSet is the best choice. For distinct, mutually exclusive options, enum is the way to go. By understanding the key differences, you can better model your data and write more expressive, maintainable Swift code.\n","tags":["Swift"],"title":"OptionSet vs Enum in Swift"},{"categories":["Blog"],"date":"October 23, 2024","permalink":"https://mahigarg.github.io/blogs/optionset-in-swift/","section":"blogs","summary":"In Swift, an OptionSet is a powerful way to represent a collection of unique options or flags using a bitwise format. OptionSet works especially well when you need to define multiple independent settings or features, such as configuration options, permissions, or state indicators. This blog post will explore what OptionSet is, how to use it, and some practical examples to demonstrate its capabilities.\nWhat is OptionSet? OptionSet is a Swift protocol that enables you to define a set of options that can be combined or used individually. Each option is represented as a unique bit in an integer, allowing multiple options to be stored compactly in a single variable. This makes operations like combining, checking, and removing options very efficient.\nKey Characteristics of OptionSet: Each option is represented as a unique power of two. Options can be combined using bitwise OR (|). Individual options can be checked using bitwise AND (\u0026amp;). When to Use OptionSet OptionSet is useful when you:\nNeed to represent multiple options that can be turned on or off independently. Want to store these options efficiently in a single variable. Want to perform operations on these options using bitwise logic. Creating an OptionSet To create an OptionSet, define a structure that conforms to the OptionSet protocol. Inside the structure, define each option as a staticconstant with unique bit values.\nHere’s a simple example of an OptionSet representing different notification settings:\nstruct NotificationOptions: OptionSet { let rawValue: Int static let email = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 0) // 0001 static let sms = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 1) // 0010 static let push = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 2) // 0100 static let inApp = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 3) // 1000 static let all: NotificationOptions = [.email, .sms, .push, .inApp] } In this example:\nEach option is defined as a unique bit. 1 \u0026lt;\u0026lt; 0 represents the first bit (1), 1 \u0026lt;\u0026lt; 1 represents the second bit (2), and so on. all is a convenience option that includes all notification types. Working with OptionSet With the NotificationOptions OptionSet, you can now create combinations of options, check for specific options, and remove options.\n1. Combining Options You can combine multiple options using the | operator or by simply creating an array of the options you want to combine.\nlet selectedOptions: NotificationOptions = [.email, .push] print(selectedOptions.contains(.email)) // true print(selectedOptions.contains(.sms)) // false 2. Checking for an Option Use the .contains() method to check if a specific option is set within an OptionSet value.\nif selectedOptions.contains(.email) { print(\u0026#34;Email notifications are enabled.\u0026#34;) } else { print(\u0026#34;Email notifications are not enabled.\u0026#34;) } 3. Adding and Removing Options You can add options to an existing OptionSet using the insert() method and remove options with the remove() method.\nvar myOptions: NotificationOptions = [.sms] myOptions.insert(.push) print(myOptions.contains(.push)) // true myOptions.remove(.sms) print(myOptions.contains(.sms)) // false Practical Example: File Permissions Imagine you are creating a file system and need to assign permissions to files. Common permissions include read, write, and execute, which can all be represented using OptionSet.\nstruct FilePermissions: OptionSet { let rawValue: Int static let read = FilePermissions(rawValue: 1 \u0026lt;\u0026lt; 0) // 0001 static let write = FilePermissions(rawValue: 1 \u0026lt;\u0026lt; 1) // 0010 static let execute = FilePermissions(rawValue: 1 \u0026lt;\u0026lt; 2) // 0100 static let all: FilePermissions = [.read, .write, .execute] } // Create a file with read and write permissions var filePermissions: FilePermissions = [.read, .write] // Check permissions if filePermissions.contains(.read) { print(\u0026#34;File is readable.\u0026#34;) } if !filePermissions.contains(.execute) { print(\u0026#34;File is not executable.\u0026#34;) } // Add execute permission filePermissions.insert(.execute) print(filePermissions.contains(.execute)) // true // Remove write permission filePermissions.remove(.write) print(filePermissions.contains(.write)) // false Here:\nWe define a FilePermissions OptionSet with read, write, and execute options. Permissions can be combined or modified for a file using methods like insert and remove. Default Values and Custom Options In many cases, it’s useful to provide default options or custom combinations of options. For example, you might want to have default notification settings or a commonly used permission configuration.\nstruct NotificationOptions: OptionSet { let rawValue: Int static let email = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 0) static let sms = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 1) static let push = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 2) static let inApp = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 3) static let all: NotificationOptions = [.email, .sms, .push, .inApp] static let defaultOptions: NotificationOptions = [.email, .push] } // Usage let defaultSettings = NotificationOptions.defaultOptions print(defaultSettings.contains(.email)) // true print(defaultSettings.contains(.sms)) // false print(defaultSettings.contains(.push)) // true Here, defaultOptions combines email and push notifications as a default setting. You can create additional custom options this way to encapsulate common settings.\nSummary OptionSet provides a clear, efficient way to manage sets of unique options in Swift. Here’s a recap of what we covered:\nOperation Code Example Description Define Options let email = NotificationOptions(rawValue: 1 \u0026lt;\u0026lt; 0) Assign each option a unique power-of-two value Combine Options let options: NotificationOptions = [.email, .push] Use , Check for Option options.contains(.email) Check if an option is set Add an Option options.insert(.sms) Add an option using insert() Remove an Option options.remove(.push) Remove an option using remove() Default / Custom Sets static let defaultOptions: NotificationOptions = [.email] Define pre-configured option sets The OptionSet protocol in Swift is a fantastic tool when you need to represent a collection of settings, flags, or permissions efficiently. By defining each option as a bit, you can combine them with minimal memory and check or modify them with bitwise operators.\n","tags":["Swift"],"title":"OptionSet in Swift"},{"categories":["Blog"],"date":"October 21, 2024","permalink":"https://mahigarg.github.io/blogs/opaque-types-vs-generics-in-swift/","section":"blogs","summary":"Swift’s type system offers powerful tools to handle abstraction and flexibility, including Opaque Types and Generics. While both serve to manage and generalize types, they work differently and are used in distinct scenarios. In this post, we’ll explore their differences, use cases, and examples to understand when to use one over the other.\nWhat are Generics in Swift? Generics enable us to write flexible and reusable code by allowing us to create functions and types that work with any specified type. When defining a generic, we provide a placeholder (usually denoted with T, U, etc.) which will be replaced by a specific type whenever it’s used.\nExample of Generics Here\u0026rsquo;s a simple example of a generic function in Swift that works with any type that conforms to Equatable:\nfunc areEqual\u0026lt;T: Equatable\u0026gt;(_ a: T, _ b: T) -\u0026gt; Bool { return a == b } let result1 = areEqual(5, 5) // true let result2 = areEqual(\u0026#34;Hello\u0026#34;, \u0026#34;Hi\u0026#34;) // false How Generics Work Type Erasure at Call Site: The generic type (T) is replaced by the actual type when the function is called, and this type must conform to any constraints defined on the generic (like Equatable here). Compile-Time Type Safety: Swift checks that each use of the generic type meets the constraints during compilation, ensuring type safety. Benefits of Generics Code Reusability: Generics allow us to define functions and types that work for multiple types. Compile-Time Type Checking: Generic constraints ensure that the type conforms to specific requirements (like Equatable, Comparable, etc.) before compiling, reducing runtime errors. What are Opaque Types in Swift? Opaque Types were introduced in Swift 5.1 to enable more specific control over return types. Unlike generics, where the caller can specify the type, opaque types let the function or type itself determine the type it returns without exposing the exact type information to the caller. This is achieved using the some keyword.\nExample of Opaque Types Here’s a simple example with an opaque return type:\nfunc makeRandomNumber() -\u0026gt; some Equatable { return Int.random(in: 1...100) } In this function, the caller knows that it will receive a type that conforms to Equatable but doesn’t need to know that it is specifically an Int. The function itself decides the concrete type (Int), which remains consistent across calls to makeRandomNumber.\nHow Opaque Types Work Caller Receives Abstracted Return Type: The caller knows that the return type conforms to a specific protocol but doesn’t know its exact type. Compile-Time Type Consistency: Although the caller doesn’t know the exact type, the compiler guarantees that the type remains the same throughout the scope where the opaque type is used. Benefits of Opaque Types Type Hiding: Opaque types hide the concrete type, providing an abstraction layer. Type Consistency: The same concrete type is used consistently even if the caller doesn’t know the type, providing more predictable behavior than Any or type-erased wrappers. Key Differences between Opaque Types and Generics Feature Generics Opaque Types Syntax func\u0026lt;T: Protocol\u0026gt;(_ value: T) -\u0026gt; T func() -\u0026gt; some Protocol Caller’s Role Caller specifies the type when calling the function Caller does not know the exact return type Type Inference Type resolved at call site Type is determined by the function itself Use Case Useful for functions or types that can operate on various types Useful for functions or properties where type abstraction is beneficial Flexibility Allows for different types across calls Maintains a single concrete type across calls Examples Array, Dictionary\u0026lt;Key, Value\u0026gt; SwiftUI’s some View When to Use Generics vs. Opaque Types Use Generics when you want to define functions, types, or collections that can operate with various types. Generics offer flexibility and allow the caller to provide the actual type. Use Opaque Types when you want to hide the underlying type information and only expose conformance to a protocol or set of constraints. This is common in API design where the caller doesn’t need to know the underlying implementation details. Example Comparison To better understand the distinction, let’s look at two examples where we use both generics and opaque types to accomplish similar tasks.\n1. Using Generics: Summing Any Numeric Values With generics, we can define a function that accepts any type conforming to Numeric:\nfunc sum\u0026lt;T: Numeric\u0026gt;(_ a: T, _ b: T) -\u0026gt; T { return a + b } let intSum = sum(5, 10) // 15 let doubleSum = sum(5.5, 10.2) // 15.7 Here, sum works with any numeric type (Int, Double, etc.), and the type of T is inferred based on the arguments provided by the caller.\n2. Using Opaque Types: Returning a Type-Erased Collection Suppose we want a function that returns a collection of Ints but hides the specific collection type. An opaque return type makes this possible:\nfunc makeNumberCollection() -\u0026gt; some Collection { return [1, 2, 3, 4, 5] } let numbers = makeNumberCollection() print(numbers.count) // Output: 5 Here, the caller knows only that the function returns a Collection of integers but not the specific type (Array in this case). This allows us to change the underlying collection type (e.g., from Array to Set) without affecting the caller’s code.\nReal-World Example: SwiftUI’s some View SwiftUI uses opaque types extensively, especially for its views. When you create a SwiftUI view, you return some View, which represents an opaque return type that conforms to the View protocol:\nimport SwiftUI struct ContentView: View { var body: some View { Text(\u0026#34;Hello, SwiftUI!\u0026#34;) } } In this example, the body property returns some View, abstracting the specific view type (Text). This allows SwiftUI to provide type safety while hiding implementation details from the user.\nSummary Understanding the difference between opaque types and generics helps us write more expressive, safe, and reusable code. Here’s a recap:\nAspect Generics Opaque Types Flexibility Allows functions to accept or return multiple types Fixed type hidden behind a protocol or constraint Return Type Known and inferred from the caller’s input Hidden and defined within the function itself Best For Functions or types that operate with various types APIs that need to provide a type-safe abstraction Conclusion Swift’s opaque types and generics offer two powerful ways to handle abstraction, but they are optimized for different use cases. Use generics when you need to support multiple types flexibly, and reach for opaque types when you want to hide implementation details while enforcing a specific protocol or constraint. By understanding their differences and applying them in the right contexts, you can create robust, flexible, and type-safe Swift code.\n","tags":["Swift"],"title":"Opaque Types vs Generics in Swift"},{"categories":["Blog"],"date":"October 19, 2024","permalink":"https://mahigarg.github.io/blogs/lru-cache-implementation-in-swift/","section":"blogs","summary":"An LRU (Least Recently Used) Cache is a data structure that keeps track of the most recently used items and efficiently removes the least recently used ones when it reaches capacity. It’s commonly used to optimize memory usage in systems that handle large data sets by retaining only frequently accessed items.\nIn this blog, we’ll walk through the key concepts of an LRU Cache and then build it in Swift using Doubly Linked Lists and Dictionaries.\nWhat is an LRU Cache? An LRU Cache operates on a principle of maintaining the most frequently accessed items while discarding the least accessed ones. It functions with the following behaviors:\nGet: Retrieve a value based on a key. If the key exists, it’s marked as the most recently used. Put: Insert or update a key-value pair. If the cache exceeds capacity, it removes the least recently used item. This allows for a cache where lookup, insertions, and deletions can be done in constant time, O(1).\nDesign of an LRU Cache To implement an LRU Cache, we need two primary components:\nDoubly Linked List: Helps in constant time removal of the least recently used item. Dictionary (Hash Map): Maps keys to nodes in the doubly linked list, allowing quick access. We’ll be implementing this in Swift, where:\nThe dictionary stores key-node pairs. The doubly linked list maintains the order of usage, with the most recently used items at the head and the least recently used at the tail. Step-by-Step Implementation of an LRU Cache in Swift Step 1: Create the Doubly Linked List Node Each node in our doubly linked list will hold a key, value, and pointers to the next and previous nodes.\nclass DoublyLinkedListNode\u0026lt;Key, Value\u0026gt; { var key: Key var value: Value var next: DoublyLinkedListNode? var prev: DoublyLinkedListNode? init(key: Key, value: Value) { self.key = key self.value = value } } Step 2: Implement the Doubly Linked List The doubly linked list will maintain the order of items, with the most recently used items at the head and the least recently used items at the tail. We’ll add functions to add a node to the head and to remove a node from the list.\nclass DoublyLinkedList\u0026lt;Key, Value\u0026gt; { private var head: DoublyLinkedListNode\u0026lt;Key, Value\u0026gt;? private var tail: DoublyLinkedListNode\u0026lt;Key, Value\u0026gt;? init() { head = DoublyLinkedListNode(key: \u0026#34;head\u0026#34; as! Key, value: \u0026#34;head\u0026#34; as! Value) tail = DoublyLinkedListNode(key: \u0026#34;tail\u0026#34; as! Key, value: \u0026#34;tail\u0026#34; as! Value) head?.next = tail tail?.prev = head } func addNodeToHead(_ node: DoublyLinkedListNode\u0026lt;Key, Value\u0026gt;) { node.next = head?.next node.prev = head head?.next?.prev = node head?.next = node } func removeNode(_ node: DoublyLinkedListNode\u0026lt;Key, Value\u0026gt;) { node.prev?.next = node.next node.next?.prev = node.prev } func removeTail() -\u0026gt; DoublyLinkedListNode\u0026lt;Key, Value\u0026gt;? { if let tailNode = tail?.prev, tailNode !== head { removeNode(tailNode) return tailNode } return nil } } Step 3: Implement the LRU Cache With the linked list structure in place, we can now implement the main LRUCache class. This class will contain methods for get and put, as well as a dictionary to store the cache entries.\nclass LRUCache\u0026lt;Key: Hashable, Value\u0026gt; { private var capacity: Int private var cache: [Key: DoublyLinkedListNode\u0026lt;Key, Value\u0026gt;] private var linkedList: DoublyLinkedList\u0026lt;Key, Value\u0026gt; init(capacity: Int) { self.capacity = capacity self.cache = [Key: DoublyLinkedListNode\u0026lt;Key, Value\u0026gt;]() self.linkedList = DoublyLinkedList\u0026lt;Key, Value\u0026gt;() } func get(_ key: Key) -\u0026gt; Value? { if let node = cache[key] { linkedList.removeNode(node) linkedList.addNodeToHead(node) return node.value } return nil } func put(_ key: Key, _ value: Value) { if let node = cache[key] { linkedList.removeNode(node) node.value = value linkedList.addNodeToHead(node) } else { if cache.count \u0026gt;= capacity, let tailNode = linkedList.removeTail() { cache.removeValue(forKey: tailNode.key) } let newNode = DoublyLinkedListNode(key: key, value: value) linkedList.addNodeToHead(newNode) cache[key] = newNode } } } Explanation of get and put Methods get(key): Checks if the key exists in the cache. If it does, the node is moved to the head of the linked list (marking it as the most recently used). Returns the value if found, or nil if not. put(key, value): If the key exists, it updates the node’s value and moves it to the head. If the key does not exist: If the cache has reached its capacity, it removes the least recently used item from the linked list’s tail and deletes it from the dictionary. Then, it creates a new node, adds it to the head of the linked list, and adds it to the dictionary. Example Usage Let’s create an LRU cache with a capacity of 2 and test it out.\nlet lruCache = LRUCache\u0026lt;String, Int\u0026gt;(capacity: 2) // Adding items lruCache.put(\u0026#34;A\u0026#34;, 1) lruCache.put(\u0026#34;B\u0026#34;, 2) // Accessing an item makes it the most recently used print(lruCache.get(\u0026#34;A\u0026#34;)!) // Output: 1 // Adding another item evicts the least recently used (\u0026#34;B\u0026#34;) lruCache.put(\u0026#34;C\u0026#34;, 3) print(lruCache.get(\u0026#34;B\u0026#34;)) // Output: nil (as \u0026#34;B\u0026#34; is evicted) print(lruCache.get(\u0026#34;C\u0026#34;)!) // Output: 3 print(lruCache.get(\u0026#34;A\u0026#34;)!) // Output: 1 // Adding another item when cache is full, evicts \u0026#34;A\u0026#34; (the LRU) lruCache.put(\u0026#34;D\u0026#34;, 4) print(lruCache.get(\u0026#34;A\u0026#34;)) // Output: nil print(lruCache.get(\u0026#34;C\u0026#34;)!) // Output: 3 print(lruCache.get(\u0026#34;D\u0026#34;)!) // Output: 4 How It Works Cache Initialization: The cache starts with a capacity of 2. Item Access: Accessing or adding an item marks it as recently used by moving it to the head of the linked list. Capacity Limit: When the cache reaches capacity, adding a new item removes the least recently used item (from the tail of the list). Constant-Time Operations: With the combination of the doubly linked list and dictionary, lookups, insertions, and deletions are handled in constant time, O(1). Advantages and Use Cases The LRU Cache pattern is widely used in performance-critical systems to handle large data by retaining only the most relevant data. Here are some common use cases:\nWeb Browsers: Caching pages that users frequently visit. Database Query Caches: Storing results of frequently run queries. Memory Management: Systems with limited memory that need to evict the least used data to make room for new data. Conclusion Implementing an LRU Cache in Swift using a combination of a Doubly Linked List and a Dictionary achieves efficient time complexity and effective memory usage. With this structure, your cache can operate in constant time and manage limited resources effectively, making it an excellent choice for applications that require high-performance data caching.\nThis implementation provides a solid foundation for understanding caching principles and can be further extended to support additional features like custom eviction policies and time-to-live (TTL) for items.\n","tags":["Swift","Programming-Basics"],"title":"LRU Cache Implementation in Swift"},{"categories":["Blog"],"date":"October 17, 2024","permalink":"https://mahigarg.github.io/blogs/access-modifiers-in-swift/","section":"blogs","summary":"Access control is a fundamental feature in Swift that allows you to define the visibility and accessibility of various parts of your code. By using access modifiers, you can encapsulate implementation details and restrict unintended access to your code, ensuring safety and modularity.\nSwift offers five access levels: Open: The most permissive access level; it allows subclassing and overriding outside the module. Public: Allows access outside the module but prevents subclassing and overriding. Internal: Default access level, allowing access within the same module. Fileprivate: Restricts access to the same file. Private: The most restrictive level, limiting access to the enclosing declaration. In this blog, we\u0026rsquo;ll dive into each of these access modifiers, explain their differences, and look at examples.\n1. Open: Maximum Accessibility and Flexibility open is the most permissive access modifier in Swift. It allows the code entity (class, method, or property) to be accessed, subclassed, and overridden from any module, including outside the module in which it is defined. It is primarily used for frameworks where you intend to allow other developers to extend your code.\nExample:\n// Module A open class Animal { open func makeSound() { print(\u0026#34;Some generic sound\u0026#34;) } } // Module B import ModuleA class Cat: Animal { override func makeSound() { print(\u0026#34;Meow!\u0026#34;) } } let myCat = Cat() myCat.makeSound() // Output: \u0026#34;Meow!\u0026#34; In this case, the Animal class and its makeSound() method are marked open, allowing them to be subclassed and overridden in another module.\nKey Points: Accessible: Anywhere (inside and outside the module). Subclassing: Allowed in any module. Overriding: Allowed in any module. 2. Public: Controlled External Access public allows access to entities from outside the module, but unlike open, it prevents subclassing and method overriding outside the module. This modifier is often used for APIs where you want to expose functionality but restrict further modification from external developers.\nExample:\n// Module A public class Car { public var model: String public init(model: String) { self.model = model } public func drive() { print(\u0026#34;\\(model) is driving.\u0026#34;) } } // Module B import ModuleA let myCar = Car(model: \u0026#34;Tesla\u0026#34;) myCar.drive() // Output: \u0026#34;Tesla is driving\u0026#34; // Cannot subclass or override \u0026#39;Car\u0026#39; or \u0026#39;drive\u0026#39; outside the module because \u0026#39;public\u0026#39; does not allow it. Key Points: Accessible: Anywhere (inside and outside the module). Subclassing: Not allowed outside the module. Overriding: Not allowed outside the module. 3. Internal: Default Module-Level Access internal is the default access level in Swift. It allows entities to be accessed from anywhere within the same module but restricts access from outside the module. This is suitable for internal implementation details of a framework or an application that don’t need to be exposed.\nExample:\n// Internal class internal class Bike { internal var brand: String init(brand: String) { self.brand = brand } internal func ride() { print(\u0026#34;\\(brand) is being ridden.\u0026#34;) } } // This class can be accessed anywhere within the same module but not outside. let myBike = Bike(brand: \u0026#34;Yamaha\u0026#34;) myBike.ride() // Output: \u0026#34;Yamaha is being ridden.\u0026#34; Key Points: Accessible: Anywhere within the same module. Subclassing and Overriding: Allowed within the module. 4. Fileprivate: Restricting Access to the Same File fileprivate restricts access to entities within the same source file. This access level is useful when you want multiple classes or extensions within the same file to access shared properties or methods but don\u0026rsquo;t want to expose those entities outside of the file.\nExample:\n// File: Vehicle.swift class Truck { fileprivate var weight: Int = 5000 fileprivate func loadCargo() { print(\u0026#34;Loading \\(weight)kg of cargo.\u0026#34;) } } class Race { func prepareTruck() { let truck = Truck() truck.loadCargo() // This works because \u0026#39;loadCargo\u0026#39; is \u0026#39;fileprivate\u0026#39; and accessed in the same file. } } Trying to access the weight property or loadCargo() method outside the Vehicle.swift file will result in an error.\nKey Points: Accessible: Only within the same file. Subclassing and Overriding: Allowed within the same file. 5. Private: Limiting Access to the Enclosing Scope private is the most restrictive access modifier in Swift. It confines access to the enclosing declaration (such as a class, struct, or extension). This modifier ensures that properties or methods cannot be accessed or modified from outside the class or struct where they are defined, even within the same file (with an exception for extensions in the same file).\nExample:\nclass Person { private var age: Int init(age: Int) { self.age = age } private func displayAge() { print(\u0026#34;Age: \\(age)\u0026#34;) } } let person = Person(age: 30) // person.age // Error: \u0026#39;age\u0026#39; is inaccessible due to \u0026#39;private\u0026#39; protection level. // person.displayAge() // Error: \u0026#39;displayAge\u0026#39; is inaccessible due to \u0026#39;private\u0026#39; protection level. Key Points: Accessible: Only within the enclosing declaration (class, struct, or extension). Subclassing and Overriding: Not allowed outside the enclosing declaration. Summary Table of Access Modifiers Access Modifier Accessibility Subclassing Overriding open Anywhere (in and outside the module) Allowed anywhere Allowed anywhere public Anywhere (in and outside the module) Allowed inside module only Allowed inside module only internal Only within the same module Allowed within module Allowed within module fileprivate Only within the same file Allowed within the file Allowed within the file private Only within the same declaration Not allowed Not allowed Differences Between Open and Public Feature open public Access Accessible from anywhere (inside or outside the module) Accessible from anywhere (inside or outside the module) Subclassing Allowed in any module Allowed only within the same module Overriding Allowed in any module Allowed only within the same module Real-World Use Cases 1. Framework Design: When designing a Swift framework, you might use open for classes or methods that you want others to be able to extend, while using public for functionality that should be exposed but not modified.\n// Public API for a Framework open class Shape { open func draw() { print(\u0026#34;Drawing a shape.\u0026#34;) } } public class Circle: Shape { public override func draw() { print(\u0026#34;Drawing a circle.\u0026#34;) } } In this case, the Shape class is open, allowing external subclassing and overriding, while the Circle class is public, allowing external access but preventing subclassing outside the module.\n2. Encapsulation: Use private to encapsulate sensitive data within a class. This ensures that critical properties and methods cannot be accessed or altered from outside.\nclass Account { private var balance: Double = 0.0 func deposit(amount: Double) { balance += amount } func withdraw(amount: Double) { if amount \u0026lt;= balance { balance -= amount } } } 3. File-Level Sharing: Use fileprivate to share methods or properties between classes within the same file but prevent access from outside.\nfileprivate class Logger { fileprivate func log(message: String) { print(\u0026#34;Log: \\(message)\u0026#34;) } } class LoggerClient { func useLogger() { let logger = Logger() logger.log(message: \u0026#34;This is a log message.\u0026#34;) } } Conclusion Swift\u0026rsquo;s access control system allows developers to manage visibility and control access to various parts of the codebase. By using access modifiers like open, public, internal, fileprivate, and private, you can build safer, more organized, and modular code. Each modifier serves a specific purpose, whether it’s ensuring external access, protecting sensitive data, or controlling subclassing behavior.\nUnderstanding these access modifiers and knowing when to use them helps in maintaining clean code structure and preventing unintended usage or modification of your code.\n","tags":["Swift"],"title":"Access Modifiers in Swift"},{"categories":["Blog"],"date":"October 15, 2024","permalink":"https://mahigarg.github.io/blogs/opaque-in-swift/","section":"blogs","summary":"Swift is known for its powerful type system and support for generics, which allows you to write flexible and reusable code. However, there are situations where generics can become overly complex or expose too much internal detail. To help with this, Swift introduced opaque types (using the some keyword) in Swift 5.1. Opaque types allow us to hide the underlying type while still maintaining strong type safety.\nIn this blog, we\u0026rsquo;ll explore what opaque types are, how they differ from protocols with associated types and existentials, and look at practical examples where using some can simplify code.\nWhat is an Opaque Type? An opaque type in Swift is a way to hide the exact type returned by a function or property while still retaining type information for the compiler. This allows the caller to know the type exists and is the same across invocations but doesn’t reveal the specific type. It is often used with the some keyword, which specifies that the returned value conforms to a particular protocol but keeps the concrete type hidden.\nHere’s a simple example of an opaque type:\nfunc makeOpaqueShape() -\u0026gt; some Shape { return Circle(radius: 5) } In this case, the function makeOpaqueShape returns some type that conforms to the Shape protocol, but the caller does not need to know the specific type (Circle in this case). All the caller knows is that the result conforms to the Shape protocol.\nWhy Use Opaque Types? Opaque types are useful when:\nYou want to hide the implementation details of a type but still maintain type safety. You want to avoid exposing complex or unnecessary type information to the caller. You want to avoid the performance overhead of boxing types (like with protocol existentials). You want a simple alternative to returning types with generics, without making your code overly complex. Opaque types offer several advantages over using protocol types (also known as existentials), especially when you need to preserve the concrete type for operations like comparisons or optimizations that rely on the specific type.\nOpaque Types vs. Protocols with Associated Types Opaque types are different from protocol existentials, especially in cases where associated types or Self requirements are involved. Let’s clarify the distinction with an example.\nProtocol Existentials Example Suppose you have a protocol:\nprotocol Shape { func area() -\u0026gt; Double } And you want to return something that conforms to this protocol:\nfunc makeShape() -\u0026gt; Shape { return Circle(radius: 5) } This works because Circle conforms to Shape. However, the type information is erased, meaning you lose the concrete type and only know that it conforms to Shape. If we want to keep the exact type hidden while ensuring the return type is consistent across invocations, we can use some (an opaque type).\nOpaque Type Example func makeOpaqueShape() -\u0026gt; some Shape { return Circle(radius: 5) } The key difference here is that with some Shape, the caller still knows the return type conforms to Shape, but the compiler also knows that the return type will always be the same specific type across different invocations. In contrast, the existential version (Shape) can return any conforming type, and you lose the specific type information.\nPractical Example: Geometric Shapes Let’s see how this works with a more detailed example involving geometric shapes.\nStep 1: Define a Protocol We’ll define a Shape protocol that requires a method to compute the area of the shape:\nprotocol Shape { func area() -\u0026gt; Double } Step 2: Create Concrete Shape Types Now, we’ll create two concrete shapes that conform to Shape:\nstruct Circle: Shape { let radius: Double func area() -\u0026gt; Double { return .pi * radius * radius } } struct Rectangle: Shape { let width: Double let height: Double func area() -\u0026gt; Double { return width * height } } Step 3: Opaque Return Types We can now create functions that return some Shape (opaque types). These functions will hide the specific type of shape but guarantee that the type conforms to Shape.\nfunc makeCircle() -\u0026gt; some Shape { return Circle(radius: 10) } func makeRectangle() -\u0026gt; some Shape { return Rectangle(width: 10, height: 20) } Here’s how you would use these functions:\nlet shape1 = makeCircle() print(\u0026#34;Area of circle: \\(shape1.area())\u0026#34;) // Output: Area of circle: 314.159... let shape2 = makeRectangle() print(\u0026#34;Area of rectangle: \\(shape2.area())\u0026#34;) // Output: Area of rectangle: 200.0 The important point here is that we can perform operations on the returned shape (shape1 and shape2) knowing they conform to the Shape protocol, but we don’t know the exact underlying type unless we examine the implementation of the function.\nOpaque Types in SwiftUI SwiftUI, Apple’s declarative UI framework, extensively uses opaque types. For example, the some View return type is commonly used in SwiftUI to hide the complex underlying view hierarchy while ensuring type safety.\nHere’s a simple SwiftUI example:\nimport SwiftUI struct ContentView: View { var body: some View { VStack { Text(\u0026#34;Hello, World!\u0026#34;) Button(action: { print(\u0026#34;Button tapped\u0026#34;) }) { Text(\u0026#34;Tap me\u0026#34;) } } } } In the ContentView struct, the body property returns some View. This indicates that the returned view will conform to the View protocol, but SwiftUI’s internal view composition details are hidden. This makes SwiftUI more efficient and less complex for developers to work with, without exposing the underlying types of each view.\nOpaque Types vs. Generics Opaque types and generics both serve similar purposes in Swift but are used in slightly different contexts.\nGeneric Function Example A generic function that works with any Shape might look like this:\nfunc printArea\u0026lt;T: Shape\u0026gt;(of shape: T) { print(\u0026#34;Area: \\(shape.area())\u0026#34;) } This function can accept any type that conforms to the Shape protocol:\nlet circle = Circle(radius: 5) printArea(of: circle) // Output: Area: 78.539... let rectangle = Rectangle(width: 5, height: 10) printArea(of: rectangle) // Output: Area: 50.0 Generics are powerful and flexible, but in some cases, you don’t need the complexity of generics when returning from a function. If you simply want to return a type that conforms to a protocol but don’t need to make it generic, opaque types are a cleaner alternative.\nOpaque Type vs. Generic Return Type With a generic return type, you would need to do this:\nfunc makeGenericShape\u0026lt;T: Shape\u0026gt;(_ type: T.Type) -\u0026gt; T { if type == Circle.self { return Circle(radius: 5) as! T } else { return Rectangle(width: 10, height: 20) as! T } } This can be cumbersome compared to the simplicity of using an opaque return type:\nfunc makeOpaqueShape() -\u0026gt; some Shape { return Circle(radius: 5) } Limitations of Opaque Types While opaque types are incredibly useful, they do come with some limitations:\nSingle Return Type: Opaque types must return the same concrete type for every execution of the function. You cannot return different types based on runtime conditions. // This will NOT compile because Circle and Rectangle are different types. func makeShape() -\u0026gt; some Shape { if someCondition { return Circle(radius: 5) } else { return Rectangle(width: 10, height: 20) } } Cannot be Type-Casted: Since the specific type is hidden, you cannot cast an opaque type to another concrete type: let shape = makeOpaqueShape() let circle = shape as? Circle // This will result in a compile error Limited to Return Types: You can only use some for return types, not for parameters or stored properties. Conclusion Opaque types (some) provide a powerful way to hide complex or unnecessary type details while maintaining strong type safety in Swift. They are especially useful when you want to return a value that conforms to a protocol but don’t want to expose the concrete type to the caller. Opaque types simplify code, enhance abstraction, and are widely used in frameworks like SwiftUI.\nBy leveraging opaque types, you can write cleaner, more concise code while still taking full advantage of Swift’s type system.\n","tags":["Swift"],"title":"Opaque in Swift"},{"categories":["Blog"],"date":"October 12, 2024","permalink":"https://mahigarg.github.io/blogs/some-vs-any-in-swift/","section":"blogs","summary":"Swift 5.7 introduced two powerful keywords, some and any, to work with protocols in generic programming. Although they serve different purposes, they both deal with protocols and types. If you\u0026rsquo;re unfamiliar with how to use them or what sets them apart, this blog post will clarify their differences and show you practical examples.\nWhat are some and any? Before Swift 5.7, protocols with associated types and generic constraints often made code complex to read. Swift introduced some and any as simpler, more powerful tools for abstracting over types that conform to protocols.\nsome: Refers to an opaque type — a specific type that conforms to a protocol but the exact type isn\u0026rsquo;t revealed. It enforces that the type remains the same throughout the function or property. any: Refers to an existential type — any type that conforms to a protocol, allowing multiple conforming types to be used interchangeably. Let\u0026rsquo;s break these down further.\nUsing some for Opaque Types When you use some, Swift returns a concrete, specific type that conforms to a protocol, but you don’t know exactly which type it is. The compiler enforces that the same type is returned each time, ensuring consistency.\nExample: some in Action Consider a function that returns a value conforming to the Shape protocol:\nprotocol Shape { func area() -\u0026gt; Double } struct Circle: Shape { let radius: Double func area() -\u0026gt; Double { return .pi * radius * radius } } struct Square: Shape { let side: Double func area() -\u0026gt; Double { return side * side } } func makeShape() -\u0026gt; some Shape { return Circle(radius: 5) } let shape = makeShape() print(shape.area()) // Output: 78.53981633974483 In this example, the makeShape() function returns some Shape, meaning it returns a specific type that conforms to Shape — in this case, a Circle. However, users of the function don\u0026rsquo;t need to know that the return type is Circle; they only need to know it conforms to Shape.\nKey point: The type returned by some must remain consistent. For example, you cannot return both Circle and Square from the same function using some Shape.\nfunc makeShape(basedOn value: Int) -\u0026gt; some Shape { if value \u0026gt; 5 { return Circle(radius: 5) } else { return Square(side: 4) // Error: Inconsistent return types } } The above example will throw a compilation error because the return type changes between Circle and Square. Swift requires that the same concrete type is returned consistently when using some.\nUsing any for Existential Types When using any, you\u0026rsquo;re telling Swift that the function can return any type that conforms to the protocol. Unlike some, any allows different types to be returned as long as they all conform to the specified protocol.\nExample: any in Action Let’s rewrite our previous example to use any:\nfunc makeShape(basedOn value: Int) -\u0026gt; any Shape { if value \u0026gt; 5 { return Circle(radius: 5) } else { return Square(side: 4) } } let shape = makeShape(basedOn: 3) print(shape.area()) // Output: 16.0 Now, the function works fine because any Shape allows the function to return either Circle or Square, as long as both conform to Shape. This is because any does not care if the types are different, just that they conform to the Shape protocol.\nKey Differences between some and any Type Consistency: some enforces that the same concrete type is returned, while any allows multiple types to be returned. Performance: Since some represents a specific type known at compile time, it’s generally more performant. any adds a layer of abstraction, which may involve runtime type checking. Use Case: Use some when you want type safety and consistency, and use any when you need flexibility with different types. When to use some vs any Use some when you need type consistency: If you need a function or property to always return a specific, but hidden, concrete type conforming to a protocol, use some. This can provide better performance and clarity. Example: You have a method returning a particular type of Shape, such as Circle, and you want the user to interact with it via the Shape protocol.\nUse any when you need flexibility: If your function might return different types that all conform to the same protocol, use any. This is ideal when you need dynamic behavior or don\u0026rsquo;t care about the concrete type. Example: You have a method that can return either a Circle or a Square based on input, and both conform to the Shape protocol.\nPractical Example: A Drawing App Suppose you’re building a drawing app where users can create different shapes.\nWith some: func createShape() -\u0026gt; some Shape { Circle(radius: 10) } let shape1 = createShape() let shape2 = createShape() print(type(of: shape1)) // Circle print(type(of: shape2)) // Circle With any: func createRandomShape() -\u0026gt; any Shape { if Bool.random() { return Circle(radius: 5) } else { return Square(side: 4) } } let shape3 = createRandomShape() print(type(of: shape3)) // Could be Circle or Square Here, createShape() always returns a Circle, whereas createRandomShape() can return either a Circle or a Square, depending on random logic.\nConclusion Use some when you want to abstract away the type while ensuring it stays consistent. Use any when you need the flexibility of working with different types that conform to the same protocol. ","tags":["Swift"],"title":"Some vs Any in Swift"},{"categories":["Blog"],"date":"October 11, 2024","permalink":"https://mahigarg.github.io/blogs/one-sided-range-in-swift/","section":"blogs","summary":"Swift provides a powerful way to work with collections through ranges, which define a sequence of values with a start and an end. In addition to the traditional closed (...) and half-open (..\u0026lt;) ranges, Swift introduces one-sided ranges, a feature that makes working with sequences and collections more flexible and concise.\nIn this post, we\u0026rsquo;ll explore what one-sided ranges are, how to use them, and some practical examples to demonstrate their power.\nWhat is a One-Sided Range? In Swift, ranges typically have both a start and an end. However, there are scenarios where you might only care about one side of the range — either the starting point or the endpoint. That\u0026rsquo;s where one-sided ranges come in.\nTypes of One-Sided Ranges There are two types of one-sided ranges in Swift:\nFrom a starting index to the end: start... From the beginning to an ending index: ...end These ranges don\u0026rsquo;t require both a starting and an ending index, allowing you to specify only one side.\nOne-Sided Range Syntax From a Starting Index to the End (start\u0026hellip;) The one-sided range start... starts at the specified start index and goes all the way to the end of the collection.\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] let subset = numbers[3...] // Starts from index 3 to the end print(subset) // Output: [4, 5, 6, 7, 8, 9, 10] In this example, 3... is a one-sided range that starts at index 3 (which is the number 4 in the numbers array) and goes to the end of the array.\nFrom the Beginning to an Ending Index (\u0026hellip;end) The one-sided range ...end starts from the beginning of the collection and goes up to the specified end index.\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] let subset = numbers[...4] // Ends at index 4 (inclusive) print(subset) // Output: [1, 2, 3, 4, 5] Here, the range ...4 means \u0026ldquo;from the beginning to index 4\u0026rdquo;, and it includes the value at index 4, which is the number 5.\nPractical Examples of One-Sided Ranges 1. Slicing an Array One-sided ranges are especially useful for slicing arrays. You can grab either the \u0026ldquo;tail\u0026rdquo; or \u0026ldquo;head\u0026rdquo; of an array in a very concise way.\nlet letters = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;g\u0026#34;] // Extract the tail from index 3 to the end let tail = letters[3...] print(tail) // Output: [\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;g\u0026#34;] // Extract the head from the beginning to index 2 let head = letters[...2] print(head) // Output: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] This approach is cleaner than using explicit ranges like 3..\u0026lt;letters.count or 0...2.\n2. Using One-Sided Ranges with Strings You can also use one-sided ranges with strings, which allows you to efficiently extract parts of the string.\nlet text = \u0026#34;Hello, Swift!\u0026#34; // From the 7th character to the end let substring = text[text.index(text.startIndex, offsetBy: 7)...] print(substring) // Output: \u0026#34;Swift!\u0026#34; // From the beginning to the 5th character let prefix = text[...text.index(text.startIndex, offsetBy: 4)] print(prefix) // Output: \u0026#34;Hello\u0026#34; This allows you to work with strings in a way that doesn\u0026rsquo;t require you to manually compute the range.\n3. Custom Ranges in Loops One-sided ranges can also be used in loops, where you might want to iterate from or up to a certain point in a collection.\nlet numbers = [10, 20, 30, 40, 50, 60] // Loop from index 2 to the end of the array for number in numbers[2...] { print(number) } // Output: // 30 // 40 // 50 // 60 This is a more readable way to iterate through a slice of a collection, compared to manually computing the range.\nCombining One-Sided Ranges with Other Ranges You can mix one-sided ranges with other ranges for even more flexibility. For example, combining a one-sided range with the prefix or suffix methods of a collection:\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] // Use a one-sided range with prefix to get the first 4 elements let firstFour = numbers.prefix(4) print(firstFour) // Output: [1, 2, 3, 4] // Use a one-sided range with suffix to get the last 3 elements let lastThree = numbers.suffix(3) print(lastThree) // Output: [8, 9, 10] This helps create concise and readable code when working with array slices.\nBenefits of One-Sided Ranges Concise: One-sided ranges make code cleaner by removing the need to manually calculate indices or define both endpoints. Expressive: They clearly express the intent to either \u0026ldquo;go from here to the end\u0026rdquo; or \u0026ldquo;from the start up to here\u0026rdquo;, improving code readability. Flexible: One-sided ranges can be used across different types like arrays, strings, and even in loops. Conclusion One-sided ranges in Swift are a simple yet powerful tool that allows developers to work more effectively with sequences and collections. They provide cleaner syntax for slicing arrays, strings, and other collections, and are especially useful when you only need to define one side of a range.\nBy understanding how to use one-sided ranges, you can write more concise and expressive Swift code, reducing the complexity of index calculations and improving readability.\n","tags":["Swift"],"title":"One Sided Range in Swift"},{"categories":["Blog"],"date":"October 6, 2024","permalink":"https://mahigarg.github.io/blogs/class-hierarchy-of-uibutton-uilabel-and-uiimageview-in-swift/","section":"blogs","summary":"When building user interfaces in iOS applications, UIKit provides a wide array of components, each designed for specific use cases. Three of the most commonly used UI components are UIButton, UILabel, and UIImageView. These components share a common ancestor in the UIKit class hierarchy but serve different purposes and exhibit different behaviors.\nIn this blog, we will explore and compare the class hierarchy of these three key UIKit elements, starting from their root superclass and understanding the differences in their inheritance trees.\n1. UIButton Class Hierarchy UIButton is a user-interactive component that triggers actions in response to user events such as taps. As a subclass of UIControl, it provides various control-specific behaviors such as touch handling and event generation. Let’s break down its class hierarchy:\nNSObject UIResponder UIView UIControl UIButton Explanation: NSObject: The root class of most Objective-C and Swift classes, it provides fundamental behavior such as memory management. UIResponder: Inherited from NSObject, it enables event handling, including touch events, gestures, and motion events. Every UI element that can handle user interactions is a subclass of UIResponder. UIView: As a subclass of UIView, UIButton gains the ability to render itself on the screen, manage layout, and respond to touch events. UIControl: UIControl introduces event-handling features specific to user controls, such as buttons, sliders, or switches. It enables the UIButton to trigger actions and handle UI events like touches and taps. UIButton: The final class in the hierarchy, UIButton, adds additional functionality for handling user taps, configuring titles, images, and styling. Key Features: User interaction enabled. Supports customizable titles, images, and states (e.g., highlighted, disabled). Triggers events when tapped. 2. UILabel Class Hierarchy UILabel is a non-interactive UI element primarily used for displaying static or dynamic text. It provides text styling and layout options, but it doesn’t inherit from UIControl as it doesn’t handle user events.\nNSObject UIResponder UIView UILabel Explanation: The first three superclasses are the same as those of UIButton, meaning UILabel also inherits fundamental behaviors such as memory management (NSObject), event handling (UIResponder), and rendering capabilities (UIView). However, unlike UIButton, UILabel does not inherit from UIControl, as it is not intended for direct user interaction. Its primary function is to display text without responding to user taps or gestures. UILabel: The subclass that specializes in rendering and managing text. It supports various text styles, alignment, truncation, and multi-line capabilities. Key Features: Displays text with various font, color, and alignment options. Non-interactive; primarily used for read-only text. Can display attributed text for rich styling. 3. UIImageView Class Hierarchy UIImageView is another non-interactive UI component, used for displaying images. It offers a simple way to render an image or a series of images (for animations). Like UILabel, it doesn’t inherit from UIControl, as it doesn’t need to handle user interaction by default.\nNSObject UIResponder UIView UIImageView Explanation: Again, the first three superclasses are identical to those of UIButton and UILabel, which provide fundamental object behavior, event handling, and rendering on the screen. UIImageView: A specialized subclass of UIView that is optimized for displaying images. It can be configured with a single image, or a sequence of images to create simple animations. While UIImageView is typically not user-interactive, it can be made interactive by adding gesture recognizers or making it part of a control structure. Key Features: Displays images or animates a sequence of images. Non-interactive by default, but can support user interaction when required. Efficient memory management for large image assets. Class Hierarchy Comparison Class UIButton UILabel UIImageView NSObject ✔ ✔ ✔ UIResponder ✔ ✔ ✔ UIView ✔ ✔ ✔ UIControl ✔ ✘ ✘ Final Class UIButton UILabel UIImageView Primary Purpose Interactive button that responds to user taps. Non-interactive label for displaying text. Non-interactive view for displaying images. ### Key Differences Inheritance of UIControl: UIButton inherits from UIControl, which gives it the ability to handle user interaction and trigger events such as taps. This makes it an active UI element. UILabel and UIImageView are passive elements that do not handle user interaction by default, as they do not inherit from UIControl. Interactivity: UIButton is designed for user interaction. It responds to user taps, can be enabled or disabled, and changes state based on user interaction. UILabel is purely for text display and does not interact with users, while UIImageView focuses on rendering images with no default interaction. Use Case Focus: UIButton is for interactive elements that require user input. UILabel is used for text display. UIImageView is used for image display or animation. Conclusion The class hierarchy of UIButton, UILabel, and UIImageView in Swift reflects their roles within the UIKit framework. UIButton, being interactive, inherits from UIControl, while UILabel and UIImageView are non-interactive, inheriting only from UIView. This hierarchy structure provides each class with its specific functionality, allowing developers to use these components according to their application\u0026rsquo;s needs.\nUnderstanding these class hierarchies helps you leverage the capabilities of these UIKit elements more effectively in your iOS development projects. Whether you\u0026rsquo;re building buttons, displaying text, or rendering images, UIKit\u0026rsquo;s well-structured class hierarchy ensures that you have the right tools for the job.\n","tags":["Swift"],"title":"Class Heirarchy of UIButton, UILabel and UIImageView in Swift"},{"categories":["Blog"],"date":"October 1, 2024","permalink":"https://mahigarg.github.io/blogs/try-catch-and-throws-error-handling-in-swift/","section":"blogs","summary":"Error handling is an essential feature of modern programming languages, allowing developers to gracefully manage runtime issues without crashing an app. Swift has a robust error-handling system based on the concepts of throwing, catching, propagating, and handling errors. In this blog, we will explore how error handling works in Swift using try, catch, and throws with detailed explanations and practical examples.\nWhat is Error Handling? Error handling in Swift enables you to anticipate and handle potential failures in your code. Instead of allowing your app to crash when it encounters a problem, error handling lets you catch the error, examine it, and decide how to respond—whether by fixing the issue, retrying, or informing the user.\nIn Swift, functions or methods that can throw errors are marked with the throws keyword, and any error handling is done using do, try, catch, and throw statements.\nDefining Errors Errors in Swift must conform to the Error protocol. Typically, errors are represented using enum types because they are ideal for listing various error conditions.\nHere’s a basic example of how to define custom errors:\nenum FileError: Error { case fileNotFound case unreadable case encodingFailed } In this example, FileError represents a few potential issues when dealing with files: the file might not exist, it might be unreadable, or encoding the file’s contents might fail.\nThrowing Errors A function or method can indicate that it might throw an error by adding the throws keyword to its declaration. When you need to signal an error in such a function, use the throw keyword followed by an error value.\nfunc readFile(named filename: String) throws -\u0026gt; String { guard filename == \u0026#34;example.txt\u0026#34; else { throw FileError.fileNotFound } return \u0026#34;File contents here\u0026#34; } In the readFile function, an error is thrown if the file’s name is anything other than example.txt. This function is marked with throws to indicate that it can throw errors.\nHandling Errors with do, try, and catch When you call a function that throws an error, you must handle the potential error. This is where the do, try, and catch keywords come into play.\ndo defines a block of code that can throw an error. try is used to call a function that can throw an error. catch handles the error if it occurs. Here’s an example of how to handle errors:\ndo { let content = try readFile(named: \u0026#34;example.txt\u0026#34;) print(content) } catch FileError.fileNotFound { print(\u0026#34;File not found.\u0026#34;) } catch { print(\u0026#34;An unexpected error occurred: \\(error).\u0026#34;) } In this example:\nWe use try to call the readFile function. The do block wraps the code that might throw an error. catch handles the FileError.fileNotFound error specifically, and a general catch block catches any other unexpected errors. If the filename passed to readFile is example.txt, the file’s content will be printed. If the file is not found, the catch block will print \u0026ldquo;File not found.\u0026rdquo;\nUsing try? for Optional Error Handling Sometimes, you don’t want to deal with the complexity of error handling and are okay with receiving nil if an error occurs. In such cases, you can use try?, which converts the thrown error into an optional value (nil in case of error).\nlet content = try? readFile(named: \u0026#34;missing.txt\u0026#34;) if let fileContent = content { print(fileContent) } else { print(\u0026#34;Failed to load file.\u0026#34;) } Here, if the readFile function throws an error, content will be nil. If the file is successfully read, the content is unwrapped and printed.\nUsing try! for Forced Error Handling If you are confident that a function will not throw an error, you can use try! to force the function to succeed. If the function throws an error, the app will crash. Therefore, use try! only when you are certain that the function will not fail.\nlet content = try! readFile(named: \u0026#34;example.txt\u0026#34;) print(content) In this case, if the file example.txt exists, the content will be printed. However, if the file is missing, the program will crash.\nPropagating Errors Sometimes, you may want to let the error propagate to the calling function instead of handling it immediately. You can propagate the error by marking the calling function with throws.\nfunc processFile(named filename: String) throws { let content = try readFile(named: filename) print(content) } Now, processFile does not handle the error itself—it propagates the error to the code that calls processFile.\nError Handling in File Operations Let’s combine everything we’ve learned into a more comprehensive example. Suppose we’re writing a function to read and process files.\nenum FileError: Error { case fileNotFound case unreadable case encodingFailed } func readFile(named filename: String) throws -\u0026gt; String { guard filename == \u0026#34;example.txt\u0026#34; else { throw FileError.fileNotFound } // Simulate reading the file return \u0026#34;File content for \\(filename)\u0026#34; } func processFile(named filename: String) throws { let content = try readFile(named: filename) print(\u0026#34;Processing file: \\(content)\u0026#34;) } do { try processFile(named: \u0026#34;example.txt\u0026#34;) } catch FileError.fileNotFound { print(\u0026#34;The file could not be found.\u0026#34;) } catch FileError.unreadable { print(\u0026#34;The file is unreadable.\u0026#34;) } catch FileError.encodingFailed { print(\u0026#34;Failed to encode the file contents.\u0026#34;) } catch { print(\u0026#34;An unexpected error occurred: \\(error).\u0026#34;) } Breakdown: Error definition: We define FileError to cover possible file-related issues. readFile function: This function throws an error if the file isn’t found. processFile function: Calls readFile and handles the file content. Error handling: The do block wraps the call to processFile, while various catch blocks handle specific errors. In this case, if the file example.txt exists, the content is processed and printed. If the file isn’t found, a specific error message is shown.\nCustomizing Error Messages You can provide more detailed error messages by conforming to the LocalizedError protocol, which allows you to provide a custom error description:\nenum FileError: Error, LocalizedError { case fileNotFound case unreadable case encodingFailed var errorDescription: String? { switch self { case .fileNotFound: return \u0026#34;The file could not be located.\u0026#34; case .unreadable: return \u0026#34;The file is not readable.\u0026#34; case .encodingFailed: return \u0026#34;The file could not be encoded.\u0026#34; } } } do { try processFile(named: \u0026#34;missing.txt\u0026#34;) } catch { print(error.localizedDescription) } In this example, each FileError case has a custom description that provides more specific details when printed.\nConclusion Swift’s error handling system using try, catch, and throws provides a robust mechanism for managing and recovering from runtime errors. Whether you’re dealing with file operations, network requests, or any other operation that might fail, handling errors gracefully improves your app’s stability and user experience.\nBy combining various features like try? and try!, customizing error messages, and propagating errors, Swift gives you the flexibility to manage errors in a way that best suits your application. Error handling in Swift ensures that you can build resilient apps that handle failure scenarios smoothly without crashing or causing unexpected behavior.\n","tags":["Swift"],"title":"Try Catch and Throws: Error Handling in Swift"},{"categories":["Blog"],"date":"September 28, 2024","permalink":"https://mahigarg.github.io/blogs/round-vs-floor-vs-ceil-swift/","section":"blogs","summary":"In Swift, working with floating-point numbers often requires you to round values to their nearest whole number or perform specific types of rounding. The three primary functions that help with this are:\nround(): Rounds a number to the nearest integer. floor(): Rounds a number down to the largest integer less than or equal to the number. ceil(): Rounds a number up to the smallest integer greater than or equal to the number. In this blog post, we\u0026rsquo;ll break down the differences between these functions, how and when to use each one, and show practical examples for real-world applications.\nThe round() Function The round() function in Swift rounds a floating-point number to the nearest integer. If the decimal part of the number is 0.5 or greater, round() will round up; otherwise, it rounds down.\nExample: let value1 = 5.4 let roundedValue1 = value1.rounded() print(roundedValue1) // Output: 5.0 let value2 = 5.6 let roundedValue2 = value2.rounded() print(roundedValue2) // Output: 6.0 Key points: Rounding down: Numbers less than 0.5 will round down to the nearest whole number. Rounding up: Numbers greater than or equal to 0.5 will round up to the nearest whole number. Example with negative numbers: let negativeValue1 = -5.4 print(negativeValue1.rounded()) // Output: -5.0 let negativeValue2 = -5.6 print(negativeValue2.rounded()) // Output: -6.0 With negative numbers, round() behaves similarly: if the decimal part is less than -0.5, it rounds away from zero (down in magnitude); otherwise, it rounds toward zero.\nThe floor() Function The floor() function always rounds a floating-point number down to the largest integer less than or equal to the number. This behavior remains consistent regardless of the decimal part of the number.\nExample: let value1 = 5.4 let flooredValue1 = floor(value1) print(flooredValue1) // Output: 5.0 let value2 = 5.6 let flooredValue2 = floor(value2) print(flooredValue2) // Output: 5.0 Key points: Always rounds down: Even if the decimal part is above 0.5, it rounds down to the nearest integer. Negative numbers: For negative numbers, it rounds further away from zero. Example with negative numbers: let negativeValue1 = -5.4 print(floor(negativeValue1)) // Output: -6.0 let negativeValue2 = -5.6 print(floor(negativeValue2)) // Output: -6.0 For negative numbers, floor() moves the value away from zero, making the number more negative.\nThe ceil() Function The ceil() function always rounds a floating-point number up to the smallest integer greater than or equal to the number. Just like floor(), ceil() works irrespective of the decimal part.\nExample: let value1 = 5.4 let ceiledValue1 = ceil(value1) print(ceiledValue1) // Output: 6.0 let value2 = 5.6 let ceiledValue2 = ceil(value2) print(ceiledValue2) // Output: 6.0 Key points: Always rounds up: No matter the decimal part, it rounds up to the nearest whole number. Negative numbers: For negative numbers, it rounds closer to zero. Example with negative numbers: let negativeValue1 = -5.4 print(ceil(negativeValue1)) // Output: -5.0 let negativeValue2 = -5.6 print(ceil(negativeValue2)) // Output: -5.0 For negative numbers, ceil() rounds the value toward zero, making it less negative.\nWhen to Use round(), floor(), and ceil() Understanding when to use each function depends on your specific use case.\nround(): Use round() when you want to round a value to the nearest whole number, following the standard rounding rules (half up). Example use case: Rounding prices, weights, or any measurement to the nearest whole number.\nlet price = 99.99 let roundedPrice = price.rounded() // 100.0 floor(): Use floor() when you need to round a value down to the nearest integer, regardless of the decimal part. Example use case: You might use floor() in a game or physics engine to move a character to the nearest whole coordinate below the current position.\nlet playerPosition = 3.8 let flooredPosition = floor(playerPosition) // 3.0 ceil(): Use ceil() when you need to round a value up to the nearest integer, irrespective of the decimal part. Example use case: Allocating memory blocks or tasks where you need to ensure that a certain amount of resources is always sufficient and not less than what’s required.\nlet requiredBlocks = 4.2 let allocatedBlocks = ceil(requiredBlocks) // 5.0 Round vs Floor vs Ceil Function Behavior (Positive Numbers) Behavior (Negative Numbers) round() Rounds to the nearest integer (0.5 and above rounds up) Same rule, rounds away from zero if \u0026gt;= -0.5, else toward zero floor() Always rounds down to the nearest whole number Always rounds down (away from zero) ceil() Always rounds up to the nearest whole number Always rounds up (toward zero) Conclusion In Swift, round(), floor(), and ceil() provide powerful tools for managing floating-point numbers in different contexts. Understanding when and how to use each function can significantly impact the precision and correctness of your calculations. Whether you\u0026rsquo;re working with prices, positions in a game, or even resource allocation, these rounding functions help ensure your numbers are handled properly.\nBy using these functions effectively, you can write more robust and error-free code that deals with floating-point rounding issues gracefully!\n","tags":["Swift"],"title":"Round vs Floor vs Ceil : Swift"},{"categories":["Blog"],"date":"September 25, 2024","permalink":"https://mahigarg.github.io/blogs/associated-types-in-swift/","section":"blogs","summary":"Swift\u0026rsquo;s powerful generics system allows developers to write flexible and reusable code. One of the core features of generics is associated types, which are used in protocols to define placeholder types that get specified later when the protocol is adopted by a class, struct, or enum. Understanding associated types is crucial when working with Swift’s protocols, and in this blog, we\u0026rsquo;ll explore their concept, usage, and real-world examples.\nWhat Are Associated Types? Associated types in Swift are placeholders that define types that will be provided when a protocol is adopted. They allow protocols to work with generic types without specifying what those types are upfront. When you declare an associated type, you\u0026rsquo;re essentially saying, \u0026ldquo;I don\u0026rsquo;t care what the type is right now, but the conforming type will specify it later.\u0026rdquo;\nSyntax You declare an associated type in a protocol using the associatedtype keyword:\nprotocol SomeProtocol { associatedtype Item func doSomething(with item: Item) } In this protocol, Item is an associated type. Any type that conforms to SomeProtocol will need to define what Item refers to.\nWhy Use Associated Types? Associated types make protocols more flexible by allowing them to work with generic types. Instead of defining a protocol that works with one specific type, you can define a protocol that works with any type, which will be specified later when the protocol is implemented.\nBasic Example Let’s start with a simple example. Suppose we want to create a protocol for a container that can hold items of any type. We don\u0026rsquo;t know the type of the items at the time of protocol declaration, but the conforming type will specify it later.\nprotocol Container { associatedtype Item var items: [Item] { get set } func add(item: Item) func getItem(at index: Int) -\u0026gt; Item } Here, Container is a protocol that defines an associated type Item. The protocol also defines an array items that holds elements of type Item and functions to add and retrieve items from the container.\nNow, let’s conform to this protocol using a StringContainer that holds strings:\nstruct StringContainer: Container { var items: [String] = [] func add(item: String) { items.append(item) } func getItem(at index: Int) -\u0026gt; String { return items[index] } } In this case, the associated type Item is specified as String when the protocol is adopted by StringContainer. We can now use the StringContainer to store strings:\nvar myContainer = StringContainer() myContainer.add(item: \u0026#34;Hello\u0026#34;) myContainer.add(item: \u0026#34;World\u0026#34;) print(myContainer.getItem(at: 0)) // Output: Hello Using Associated Types with Multiple Types Associated types are not limited to single types; you can create more complex examples where protocols have multiple associated types.\nFor instance, let’s say we want to create a protocol for a dictionary-like data structure that maps keys to values.\nprotocol KeyValueStore { associatedtype Key associatedtype Value func setValue(_ value: Value, forKey key: Key) func getValue(forKey key: Key) -\u0026gt; Value? } Here, the protocol KeyValueStore defines two associated types: Key and Value. This protocol can be used to build any dictionary-like structure that maps any type of key to any type of value.\nWe can now create a struct that conforms to this protocol:\nstruct DictionaryStore: KeyValueStore { var storage: [String: Int] = [:] func setValue(_ value: Int, forKey key: String) { storage[key] = value } func getValue(forKey key: String) -\u0026gt; Int? { return storage[key] } } Here, the associated types Key and Value are specified as String and Int, respectively. Now, we can use this store to map strings to integers:\nvar store = DictionaryStore() store.setValue(42, forKey: \u0026#34;Answer\u0026#34;) print(store.getValue(forKey: \u0026#34;Answer\u0026#34;) ?? \u0026#34;Not found\u0026#34;) // Output: 42 Associated Types with Constraints You can add constraints to associated types by specifying that they must conform to a certain protocol. This is useful when you want to restrict the types used in a protocol to specific kinds of types.\nFor example, let\u0026rsquo;s modify the Container protocol to ensure that the items it holds must conform to the Equatable protocol:\nprotocol Container { associatedtype Item: Equatable var items: [Item] { get set } func add(item: Item) func contains(item: Item) -\u0026gt; Bool } By using Item: Equatable, we specify that Item must conform to the Equatable protocol. Now, any type that conforms to Container must use a type that supports equality comparison.\nHere’s how we can adopt this modified Container protocol:\nstruct IntContainer: Container { var items: [Int] = [] func add(item: Int) { items.append(item) } func contains(item: Int) -\u0026gt; Bool { return items.contains(item) } } Since Int conforms to Equatable, this implementation works fine:\nvar intContainer = IntContainer() intContainer.add(item: 5) intContainer.add(item: 10) print(intContainer.contains(item: 5)) // Output: true print(intContainer.contains(item: 7)) // Output: false Associated Types and Type Erasure One of the challenges with associated types is that they make it harder to work with protocols in a generic way. Since associated types are not concrete until a type conforms to the protocol, you can\u0026rsquo;t use the protocol as a type by itself. This can be solved using type erasure.\nFor example, if we try to use the Container protocol as a type directly, Swift won’t allow it because the associated type is not specified:\n// This won\u0026#39;t compile because `Container` has an associated type. var container: Container To work around this, we use type erasure to create a concrete type that hides the associated type, allowing us to use the protocol as a type. A common way to do this is by creating a wrapper around the protocol:\nstruct AnyContainer\u0026lt;T: Equatable\u0026gt;: Container { private let _add: (T) -\u0026gt; Void private let _contains: (T) -\u0026gt; Bool private var _items: [T] var items: [T] { get { return _items } set { _items = newValue } } init\u0026lt;C: Container\u0026gt;(_ container: C) where C.Item == T { _items = container.items _add = container.add _contains = container.contains } func add(item: T) { _add(item) } func contains(item: T) -\u0026gt; Bool { return _contains(item) } } Now, you can use AnyContainer as a concrete type:\nlet container = AnyContainer(IntContainer()) Real-World Example: Swift’s Collection Protocol Swift’s standard library uses associated types extensively. One prominent example is the Collection protocol, which defines how types like arrays, sets, and dictionaries behave.\nprotocol Collection { associatedtype Element var count: Int { get } func element(at index: Int) -\u0026gt; Element } Collection defines an associated type Element, which represents the type of the items stored in the collection. When you adopt Collection, you specify what Element will be, allowing the protocol to be used with any type of collection.\nConclusion Associated types are a powerful feature in Swift’s generics system, allowing protocols to define placeholder types that are specified when the protocol is adopted. They make protocols flexible and adaptable to different types, enabling developers to write highly reusable and efficient code. Whether you\u0026rsquo;re defining containers, key-value stores, or working with Swift\u0026rsquo;s standard library protocols, associated types are key to mastering Swift’s protocol-oriented programming.\n","tags":["Swift"],"title":"Associated Types in Swift"},{"categories":["Blog"],"date":"September 21, 2024","permalink":"https://mahigarg.github.io/blogs/property-observers-willset-didset-in-swift/","section":"blogs","summary":"Property observers in Swift are an incredibly useful feature that allows you to monitor and respond to changes in a property’s value. They are especially handy when you want to perform additional tasks whenever a property is set or updated, such as updating the UI, logging data, or enforcing business logic.\nIn this blog, we\u0026rsquo;ll dive into what property observers are, how they work, and how to use them in your Swift code with practical examples.\nWhat are Property Observers? Property observers observe and respond to changes in a property’s value. You can define property observers for both stored properties (properties with an initial value) and computed properties. Property observers do not trigger for the initial assignment (when the property is first initialized); they only react when the property’s value is explicitly set.\nSwift provides two kinds of property observers: willSet: Called just before the value is set. didSet: Called immediately after the value has been set. Syntax for Property Observers Here is the basic syntax:\nvar property: Type { willSet { // Code executed just before the property is set } didSet { // Code executed immediately after the property is set } } Let’s now explore these observers with examples.\nUsing didSet to Track Property Changes Suppose we have a class that represents a UserProfile where we want to keep track of the user\u0026rsquo;s age. We can use the didSet observer to react whenever the age property changes:\nclass UserProfile { var age: Int = 0 { didSet { print(\u0026#34;User\u0026#39;s age changed from \\(oldValue) to \\(age)\u0026#34;) } } } let profile = UserProfile() profile.age = 25 // Output: User\u0026#39;s age changed from 0 to 25 profile.age = 30 // Output: User\u0026#39;s age changed from 25 to 30 In the above example:\nThe didSet observer is called every time the age property is updated. The oldValue constant holds the property’s previous value.\nUsing willSet to Perform Actions Before Changing a Property Let’s modify the previous example to use the willSet observer. This will allow us to perform some action just before the property is updated.\nclass UserProfile { var age: Int = 0 { willSet { print(\u0026#34;About to change user\u0026#39;s age from \\(age) to \\(newValue)\u0026#34;) } } } let profile = UserProfile() profile.age = 25 // Output: About to change user\u0026#39;s age from 0 to 25 profile.age = 30 // Output: About to change user\u0026#39;s age from 25 to 30 In this case:\nThe willSet observer is called just before the property’s value changes. The newValue constant holds the property’s future value.\nCombining willSet and didSet You can combine both willSet and didSet in the same property if you want to perform actions before and after the change:\nclass UserProfile { var age: Int = 0 { willSet { print(\u0026#34;About to change age from \\(age) to \\(newValue)\u0026#34;) } didSet { print(\u0026#34;User\u0026#39;s age changed from \\(oldValue) to \\(age)\u0026#34;) } } } let profile = UserProfile() profile.age = 25 // Output: About to change age from 0 to 25 // Output: User\u0026#39;s age changed from 0 to 25 In this example, both willSet and didSet observers are triggered when the age property is updated.\nApplying Property Observers in Real-world Scenarios Imagine you are building a temperature sensor for a weather app, where you need to display a warning if the temperature exceeds a certain threshold.\nclass TemperatureSensor { var temperature: Double = 0.0 { didSet { if temperature \u0026gt; 30.0 { print(\u0026#34;Warning: High temperature!\u0026#34;) } } } } let sensor = TemperatureSensor() sensor.temperature = 25.0 // No output sensor.temperature = 32.0 // Output: Warning: High temperature! In this example, we monitor the temperature property and print a warning if the value exceeds 30 degrees.\nProperty Observers and Computed Properties You cannot directly attach property observers (willSet and didSet) to computed properties. However, you can achieve similar behavior by adding the logic directly inside the getter or setter of a computed property.\nHere\u0026rsquo;s an example using a computed property:\nclass Rectangle { var width: Double = 0 var height: Double = 0 var area: Double { get { return width * height } set { width = newValue / height print(\u0026#34;Area updated, new width is \\(width)\u0026#34;) } } } let rectangle = Rectangle() rectangle.height = 10 rectangle.area = 50 // Output: Area updated, new width is 5.0 In this example, the area property is a computed property, and its setter contains logic to update the width when the area is set.\nLimitations of willSet and didSet in Swift While willSet and didSet are powerful features in Swift, there are a few limitations and nuances you should be aware of when using them. These limitations can affect how and when you can apply property observers effectively in your projects.\n1. Not Available for let Constants You can only use property observers with var (mutable) properties. If a property is declared as a constant using let, you cannot attach willSet or didSet observers to it because constants cannot be modified after their initial value is set.\nExample:\nlet someValue = 10 // You cannot add willSet or didSet to a constant property like this 2. No Support for Computed Properties You cannot directly use willSet and didSet on computed properties. Computed properties already have a getter and setter, and their value is determined dynamically. Instead, if you want to observe changes in a computed property, you need to add logic inside the computed property’s setter.\nExample (not allowed):\nvar value: Int { willSet { // This is not allowed for computed properties } didSet { // This is also not allowed for computed properties } } Instead, you would handle changes in the computed property’s setter like this:\nvar value: Int { get { return someStoredValue } set { someStoredValue = newValue // Handle change here } } 3. Cannot Use with Lazy Properties Lazy properties are initialized only when they are accessed for the first time. Since property observers depend on knowing when the property value changes, you cannot use willSet and didSet with lazy properties. The reasoning is that a lazy property might not even be initialized by the time you want to observe its changes.\nExample (not allowed):\nlazy var someProperty: Int = 10 { willSet { print(\u0026#34;This won\u0026#39;t work\u0026#34;) } } 4. Initial Value Setting Doesn’t Trigger Observers Property observers are not triggered when the initial value of a property is set during initialization. They only get triggered when the property value is explicitly changed after the object has been initialized.\nExample:\nclass UserProfile { var age: Int = 20 { didSet { print(\u0026#34;Age changed to \\(age)\u0026#34;) } } } let profile = UserProfile() // No output since didSet is not called on initialization profile.age = 25 // Output: Age changed to 25 In this example, the didSet observer is not called when age is initialized with 20, only when it is changed to 25 later.\n5. Risk of Infinite Loops If you modify a property inside its own didSet or willSet observer, you may accidentally trigger an infinite loop. This happens when the observer modifies the property, which triggers the observer again, and so on.\nExample:\nvar count: Int = 0 { didSet { count += 1 // This will trigger didSet again, causing an infinite loop } } In this case, the didSet observer modifies count, which causes the observer to run again, leading to an infinite loop and eventually a crash.\n6. No Observers for Global and Local Variables Property observers work only for class, struct, or enum instance properties. You cannot attach willSet or didSet to global or local variables outside the scope of these types.\nExample (not allowed):\nvar someGlobalValue: Int = 10 { willSet { // Will not work on global variables } didSet { // Will not work on global variables } } 7. Cannot Use with Property Wrappers If you’re using Swift’s property wrappers (@propertyWrapper), you cannot directly combine them with willSet and didSet observers. This is because property wrappers themselves manage the storage and behavior of the property, overriding the need for traditional observers. However, you can often achieve the desired behavior inside the wrapper.\nExample (not allowed):\n@propertyWrapper struct Lowercase { var wrappedValue: String { didSet { wrappedValue = wrappedValue.lowercased() // This does not work directly with observers } } } You would need to implement such behavior within the property wrapper’s logic.\nSummary of Limitations Here’s a quick overview of the limitations:\nNo support for let constants: willSet and didSet only work with var properties. No direct use with computed properties: Use logic inside the getter and setter instead. Cannot use with lazy properties: Lazy properties defer initialization, making property observers incompatible. No observers on initialization: Property observers are not triggered when the property is first initialized. Risk of infinite loops: Be cautious when modifying a property inside its own observer. No observers for global or local variables: They only work for properties within classes, structs, or enums. Cannot combine with property wrappers: Direct use of willSet and didSet with property wrappers is not allowed. Despite these limitations, property observers remain a powerful feature for managing state changes in Swift, especially when used appropriately within the constraints mentioned. Best Practices for Using Property Observers Avoid Complex Logic in Observers: Property observers should be lightweight. If you need to perform complex operations, consider moving that logic to a separate function. Use willSet Sparingly: In many cases, you’ll only need the didSet observer, which is more useful for validating or reacting to a change that has already occurred. Avoid Infinite Loops: Be cautious of updating a property inside its own didSet or willSet observer. Doing so can cause an infinite loop if you’re not careful. Conclusion Property observers (willSet and didSet) are powerful tools in Swift that allow you to monitor and respond to changes in property values efficiently. They make it easy to track data changes, enforce rules, or update other parts of your application, such as the UI. Whether you’re developing simple applications or complex systems, mastering property observers can help you write cleaner, more reactive Swift code.\nUnderstanding when and how to use property observers will enable you to handle state changes more effectively and build more dynamic, responsive applications.\nHappy coding!\n","tags":["Swift"],"title":"Property Observers (WillSet \u0026 DidSet) in Swift"},{"categories":["Blog"],"date":"August 25, 2024","permalink":"https://mahigarg.github.io/blogs/count-with-where-clause-in-swift/","section":"blogs","summary":"In Swift, the count(where:) method is a powerful tool for filtering and counting elements in a collection that meet specific criteria. This method is part of the Swift Standard Library\u0026rsquo;s extensions to Sequence and allows for a concise and expressive way to determine how many elements in a collection match a given predicate.\ncount(where:) method is introduced in Swift 6.0 that performs the equivalent of a filter() and count in a single pass. This saves the creation of a new array that gets immediately discarded, and provides a clear and concise solution to a common problem. Keep in mind this is only available from Swift 6.0 only.\nWhat is count(where:)? The count(where:) method returns the number of elements in a collection that satisfy a specified condition (predicate). It\u0026rsquo;s a convenient way to count elements without having to filter the collection first and then count the resulting array, which makes the code both more readable and efficient.\nSyntax The general syntax for count(where:) is:\nlet count = collection.count(where: { predicate }) //or let count = collection.count { predicate } Here, collection is the sequence you are working with, and { predicate } is a closure that takes an element of the sequence and returns a Bool indicating whether the element should be counted.\nExamples Using Different Types of Sequences 1. Array An array is an ordered collection that can contain duplicates and allows random access.\nExample: Count Odd Numbers in an Array\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] let oddCount = numbers.count { $0 % 2 != 0 } print(\u0026#34;There are \\(oddCount) odd numbers.\u0026#34;) // Output: There are 5 odd numbers. Here, we use an array of integers and count how many of them are odd using the predicate { $0 % 2 != 0 }.\n2. Set A set is an unordered collection of unique elements.\nExample: Count Strings with More Than Three Characters in a Set\nlet fruits: Set\u0026lt;String\u0026gt; = [\u0026#34;apple\u0026#34;, \u0026#34;kiwi\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;pear\u0026#34;, \u0026#34;fig\u0026#34;] let longFruitCount = fruits.count { $0.count \u0026gt; 3 } print(\u0026#34;There are \\(longFruitCount) fruits with more than three characters.\u0026#34;) // Output: There are 4 fruits with more than three characters. This example uses a set of strings and counts how many strings have more than three characters.\n3. Dictionary A dictionary is a collection of key-value pairs where each key is unique.\nExample: Count Dictionary Values That Are True\nlet numberAvailability: [String: Bool] = [ \u0026#34;One\u0026#34;: true, \u0026#34;Two\u0026#34;: false, \u0026#34;Three\u0026#34;: true, \u0026#34;Four\u0026#34;: false, \u0026#34;Five\u0026#34;: true ] let availableNumbersCount = numberAvailability.count { $0.value } print(\u0026#34;There are \\(availableNumbersCount) available numbers.\u0026#34;) // Output: There are 3 available numbers. In this case, we have a dictionary of number spot and their availability (as a Bool). The predicate { $0.value } checks if the number is available.\n4. Range A range is a sequence of numbers, often used to generate numbers in a specific interval.\nExample: Count Numbers Greater Than 50 in a Range\nlet numberRange = 1...100 let greaterThanFiftyCount = numberRange.count { $0 \u0026gt; 50 } print(\u0026#34;There are \\(greaterThanFiftyCount) numbers greater than 50.\u0026#34;) // Output: There are 50 numbers greater than 50. Here, we use a closed range from 1 to 100 and count how many numbers are greater than 50.\n5. String A string in Swift is a collection of characters, and it conforms to Sequence.\nExample: Count Vowels in a String\nlet text = \u0026#34;Hello, World!\u0026#34; let vowels = \u0026#34;aeiouAEIOU\u0026#34; let vowelCount = text.count { vowels.contains($0) } print(\u0026#34;There are \\(vowelCount) vowels in the text.\u0026#34;) // Output: There are 3 vowels in the text. In this example, we count the number of vowels in a string using a predicate that checks if each character is a vowel.\nConclusion The count(where:) method in Swift is a built-in utility that provides a concise, readable, and efficient way to count elements in a collection that meet a specific condition. It can be used with any type that conforms to the Sequence protocol, such as arrays, sets, dictionaries, ranges, and strings. While it is powerful and expressive, it\u0026rsquo;s essential to consider performance and suitability when using it, especially in cases involving large collections or complex predicates.\nBy understanding these limitations and using count(where:) appropriately, you can write cleaner and more efficient Swift code that leverages the capabilities of the Swift standard library.\n","tags":["Swift"],"title":"Count with where clause (count(where:)) in Swift"},{"categories":["Gist"],"date":"February 17, 2024","permalink":"https://mahigarg.github.io/gists/find-k-closest-elements-leetcode/","section":"gists","summary":"Find K Closest Elements - LeetCode\nGiven a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.\nAn integer a is closer to x than an integer b if:\n|a - x| \u0026lt; |b - x|, or |a - x| == |b - x| and a \u0026lt; b Example 1:\nInput: arr = [1,2,3,4,5], k = 4, x = 3\nOutput: [1,2,3,4]\nExample 2:\nInput: arr = [1,2,3,4,5], k = 4, x = -1\nOutput: [1,2,3,4]\nConstraints:\n1 \u0026lt;= k \u0026lt;= arr.length 1 \u0026lt;= arr.length \u0026lt;= 10^4 arr is sorted in ascending order. -10^4 \u0026lt;= arr[i], x \u0026lt;= 10^4 Solution class Solution { func findClosestElements(_ arr: [Int], _ k: Int, _ x: Int) -\u0026gt; [Int] { var low = 0 var high = arr.count - 1 while(high - low + 1 \u0026gt; k) { if abs(arr[low] - x) \u0026gt; abs(arr[high] - x) { low += 1 } else { high -= 1 } } return Array(arr[low...high]) } } ","tags":["DSA","LeetCode"],"title":"Find K Closest Elements - LeetCode : Swift"},{"categories":["Gist"],"date":"February 15, 2024","permalink":"https://mahigarg.github.io/gists/intersection-of-two-arrays-leetcode/","section":"gists","summary":"Intersection of Two Arrays - LeetCode\nGiven two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\nExample 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]\nExample 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4]\nExplanation: [4,9] is also accepted.\nConstraints:\n1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 1000 Solution class Solution { func intersection(_ nums1: [Int], _ nums2: [Int]) -\u0026gt; [Int] { var set: Set\u0026lt;Int\u0026gt; = Set(nums1), ans: Set\u0026lt;Int\u0026gt; = [] for item in nums2 { if set.contains(item) { ans.insert(item) } } return Array(ans) } } ","tags":["DSA","LeetCode"],"title":"Intersection of Two Arrays - LeetCode : Swift"},{"categories":["Gist"],"date":"February 9, 2024","permalink":"https://mahigarg.github.io/gists/contains-duplicate-ii-leetcode/","section":"gists","summary":"Contains Duplicate II - LeetCode\nGiven an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) \u0026lt;= k.\nExample 1:\nInput: nums = [1,2,3,1], k = 3\nOutput: true\nExample 2:\nInput: nums = [1,0,1,1], k = 1\nOutput: true\nExample 3:\nInput: nums = [1,2,3,1,2,3], k = 2\nOutput: false\nConstraints:\n1 \u0026lt;= nums.length \u0026lt;= 10^5 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 0 \u0026lt;= k \u0026lt;= 10^5 Solution class Solution { func containsNearbyDuplicate(_ nums: [Int], _ k: Int) -\u0026gt; Bool { var hash: [Int: Int] = [:] for i in 0..\u0026lt;nums.count { if let value = hash[nums[i]], abs(value - i) \u0026lt;= k { return true } else { hash[nums[i]] = i } } return false } } ","tags":["DSA","LeetCode"],"title":"Contains Duplicate II - LeetCode : Swift"},{"categories":["Gist"],"date":"February 9, 2024","permalink":"https://mahigarg.github.io/gists/minimum-size-subarray-sum-leetcode/","section":"gists","summary":"Minimum Size Subarray Sum - LeetCode\nGiven an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\nExample 1:\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\nExample 2:\nInput: target = 4, nums = [1,4,4]\nOutput: 1\nExample 3:\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\nConstraints:\n1 \u0026lt;= target \u0026lt;= 10^9 1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^4 Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\nSolution class Solution { func minSubArrayLen(_ target: Int, _ nums: [Int]) -\u0026gt; Int { var ans = Int.max , sum = 0, low = 0 for i in 0..\u0026lt;nums.count { sum += nums[i] while (sum \u0026gt;= target) { ans = min(ans, i - low + 1) sum -= nums[low] low += 1 } } return ans == Int.max ? 0 : ans } } ","tags":["DSA","LeetCode"],"title":"Minimum Size Subarray Sum - LeetCode : Swift"},{"categories":["Gist"],"date":"February 9, 2024","permalink":"https://mahigarg.github.io/gists/repeated-dna-sequences-leetcode/","section":"gists","summary":"Repeated DNA Sequences - LeetCode\nThe DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.\nFor example, \u0026quot;ACGAATTCCG\u0026quot; is a DNA sequence. When studying DNA, it is useful to identify repeated sequences within the DNA.\nGiven a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.\nExample 1:\nInput: s = \u0026ldquo;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\u0026rdquo;\nOutput: [\u0026ldquo;AAAAACCCCC\u0026rdquo;,\u0026ldquo;CCCCCAAAAA\u0026rdquo;]\nExample 2:\nInput: s = \u0026ldquo;AAAAAAAAAAAAA\u0026rdquo;\nOutput: [\u0026ldquo;AAAAAAAAAA\u0026rdquo;]\nConstraints:\n1 \u0026lt;= s.length \u0026lt;= 10^5 s[i] is either 'A', 'C', 'G', or 'T'. Solution class Solution { func findRepeatedDnaSequences(_ s: String) -\u0026gt; [String] { if s.count \u0026lt; 10 { return [] } var myStr: String = String(s.prefix(10)) let s = Array(s) var set: Set\u0026lt;String\u0026gt; = [myStr] var ans: Set\u0026lt;String\u0026gt; = [] for i in 10..\u0026lt;s.count { myStr = String(myStr.dropFirst()) myStr.append(s[i]) if set.contains(myStr) { ans.insert(myStr) } else { set.insert(myStr) } } return Array(ans) } } ","tags":["DSA","LeetCode"],"title":"Repeated DNA Sequences - LeetCode : Swift"},{"categories":["Gist"],"date":"February 3, 2024","permalink":"https://mahigarg.github.io/gists/longest-substring-without-repeating-characters-leetcode/","section":"gists","summary":"Longest Substring Without Repeating Characters - LeetCode\nGiven a string s, find the length of the longest substring without repeating characters.\nExample 1:\nInput: s = \u0026ldquo;abcabcbb\u0026rdquo;\nOutput: 3\nExplanation: The answer is \u0026ldquo;abc\u0026rdquo;, with the length of 3.\nExample 2:\nInput: s = \u0026ldquo;bbbbb\u0026rdquo;\nOutput: 1\nExplanation: The answer is \u0026ldquo;b\u0026rdquo;, with the length of 1.\nExample 3:\nInput: s = \u0026ldquo;pwwkew\u0026rdquo;\nOutput: 3\nExplanation: The answer is \u0026ldquo;wke\u0026rdquo;, with the length of 3.\nNotice that the answer must be a substring, \u0026ldquo;pwke\u0026rdquo; is a subsequence and not a substring.\nConstraints:\n0 \u0026lt;= s.length \u0026lt;= 5 * 10^4 s consists of English letters, digits, symbols and spaces. Solution class Solution { func lengthOfLongestSubstring(_ ar: String) -\u0026gt; Int { let ar = Array(ar) var low = 0, set: Set\u0026lt;Character\u0026gt; = [], count = 0 for i in 0..\u0026lt;ar.count { if !set.contains(ar[i]) { set.insert(ar[i]) } else { while ar[low] != ar[i] { set.remove(ar[low]) low += 1 } low += 1 } count = max(count, i - low + 1) } return count } } ","tags":["DSA","LeetCode"],"title":"Longest Substring Without Repeating Characters - LeetCode : Swift"},{"categories":["Gist"],"date":"January 31, 2024","permalink":"https://mahigarg.github.io/gists/majority-element-leetcode/","section":"gists","summary":"Majority Element - LeetCode\nGiven an array nums of size n, return the majority element.\nThe majority element is the element that appears more than [n / 2] times. You may assume that the majority element always exists in the array.\nExample 1:\nInput: nums = [3,2,3]\nOutput: 3\nExample 2:\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\nConstraints:\nn == nums.length 1 \u0026lt;= n \u0026lt;= 5 * 10^4 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 Follow-up: Could you solve the problem in linear time and in O(1) space?\nSolution class Solution { func majorityElement(_ nums: [Int]) -\u0026gt; Int { var maj = nums[0], count = 0 for num in nums { if num == maj { count += 1 } else { maj = (count - 1) != 0 ? maj : num count -= (count - 1) != 0 ? 1 : 0 } } return maj } } ","tags":["DSA","LeetCode"],"title":"Majority Element - LeetCode : Swift"},{"categories":["Gist"],"date":"January 25, 2024","permalink":"https://mahigarg.github.io/gists/longest-substring-with-at-least-k-repeating-characters-leetcode/","section":"gists","summary":"Longest Substring with At Least K Repeating Characters - LeetCode\nGiven a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.\nif no such substring exists, return 0.\nExample 1:\nInput: s = \u0026ldquo;aaabb\u0026rdquo;, k = 3\nOutput: 3\nExplanation: The longest substring is \u0026ldquo;aaa\u0026rdquo;, as \u0026lsquo;a\u0026rsquo; is repeated 3 times.\nExample 2:\nInput: s = \u0026ldquo;ababbc\u0026rdquo;, k = 2\nOutput: 5\nExplanation: The longest substring is \u0026ldquo;ababb\u0026rdquo;, as \u0026lsquo;a\u0026rsquo; is repeated 2 times and \u0026lsquo;b\u0026rsquo; is repeated 3 times.\nConstraints:\n1 \u0026lt;= s.length \u0026lt;= 10^4 s consists of only lowercase English letters. 1 \u0026lt;= k \u0026lt;= 10^5 Solution class Solution { func longestSubstring(_ s: String, _ k: Int) -\u0026gt; Int { var hash: [Character: Int] = [:] , ans = 0 var ar = Array(s), splits = [Int]() , start = 0 for item in ar { hash[item] = hash[item, default: 0] + 1 } for i in 0..\u0026lt;ar.count { if hash[ar[i]]! \u0026lt; k { splits.append(i) } } if splits.count == 0 { return ar.count } for sp in splits { ans = max(ans, longestSubstring(String(Array(ar[start..\u0026lt;sp])), k) ) start += 1 } return max(ans, longestSubstring(String(Array(ar[start...])),k) ) } } ","tags":["DSA","LeetCode"],"title":"Longest Substring with At Least K Repeating Characters - LeetCode : Swift"},{"categories":["Gist"],"date":"September 15, 2023","permalink":"https://mahigarg.github.io/gists/search-insert-position-leetcode/","section":"gists","summary":"Search Insert Position - LeetCode\nGiven a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\nExample 2:\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\nExample 3:\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\nConstraints:\n1 \u0026lt;= nums.length \u0026lt;= 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums contains distinct values sorted in ascending order. -104 \u0026lt;= target \u0026lt;= 104 Solution class Solution { func searchInsert(_ nums: [Int], _ target: Int) -\u0026gt; Int { var low = 0 var high = nums.count - 1 var mid: Int = 0 var value = 0 if nums[0] \u0026gt; target { return 0 } else if nums[nums.count - 1] \u0026lt; target { return nums.count } while(low \u0026lt;= high) { mid = (low + high) / 2 if nums[mid] == target { return mid } else if nums[mid] \u0026lt; target { low = mid + 1 value = low } else if nums[mid] \u0026gt; target { high = mid - 1 value = high } } if value \u0026gt;= 0 { if nums[value] \u0026gt; target { return value } else { return value + 1 } } return 0 } } ","tags":["Programming-Basics"],"title":"Search Insert Position - LeetCode : Swift"},{"categories":["Gist"],"date":"September 14, 2023","permalink":"https://mahigarg.github.io/gists/find-peak-element-leetcode/","section":"gists","summary":"Find Peak Element - LeetCode\nA peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\nExample 2:\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\nConstraints:\n1 \u0026lt;= nums.length \u0026lt;= 1000 -231 \u0026lt;= nums[i] \u0026lt;= 2^231 - 1 nums[i] != nums[i + 1] for all valid i. Solution class Solution { func findPeakElement(_ nums: [Int]) -\u0026gt; Int { if nums.count == 1 { return 0 } else if nums[0] \u0026gt; nums[1] { return 0 } else if nums[nums.count - 1] \u0026gt; nums[nums.count - 2]{ return nums.count - 1 } for index in 1..\u0026lt;(nums.count - 1) { if nums[index] \u0026gt; nums[index + 1] \u0026amp;\u0026amp; nums[index] \u0026gt; nums[index - 1] { return index } } return -1 } } ","tags":["Programming-Basics"],"title":"Find Peak Element - LeetCode : Swift"},{"categories":["Gist"],"date":"September 13, 2023","permalink":"https://mahigarg.github.io/gists/search-a-2d-matrix-leetcode/","section":"gists","summary":"Search a 2D Matrix - LeetCode\nYou are given an m x n integer matrix matrix with the following two properties:\nEach row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.\nExample 1:\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\nExample 2:\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\nConstraints:\nm == matrix.length n == matrix[i].length 1 \u0026lt;= m, n \u0026lt;= 100 -104 \u0026lt;= matrix[i][j], target \u0026lt;= 104 Solution class Solution { func searchMatrix(_ matrix: [[Int]], _ target: Int) -\u0026gt; Bool { var array = matrix.flatMap { $0} var low = 0 var mid = 0 var high = array.count - 1 while(low \u0026lt;= high) { mid = (low + high) / 2 if array[mid] == target { return true } else if array[mid] \u0026lt; target { low = mid + 1 } else if array[mid] \u0026gt; target { high = mid - 1 } } return false } } ","tags":["Programming-Basics"],"title":"Search a 2D Matrix - LeetCode : Swift"},{"categories":["Gist"],"date":"September 12, 2023","permalink":"https://mahigarg.github.io/gists/length-of-last-word-leetcode/","section":"gists","summary":"Length of Last Word - LeetCode\nGiven a string s consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only.\nExample 1:\nInput: s = \u0026ldquo;Hello World\u0026rdquo;\nOutput: 5\nExplanation: The last word is \u0026ldquo;World\u0026rdquo; with length 5.\nExample 2:\nInput: s = \u0026quot; fly me to the moon \u0026quot;\nOutput: 4\nExplanation: The last word is \u0026ldquo;moon\u0026rdquo; with length 4.\nExample 3:\nInput: s = \u0026ldquo;luffy is still joyboy\u0026rdquo;\nOutput: 6\nExplanation: The last word is \u0026ldquo;joyboy\u0026rdquo; with length 6.\nConstraints:\n1 \u0026lt;= s.length \u0026lt;= 104 s consists of only English letters and spaces ' '. There will be at least one word in s. Solution class Solution { func lengthOfLastWord(_ s: String) -\u0026gt; Int { var str = (s as NSString).trimmingCharacters(in: [\u0026#34; \u0026#34;]) if let spaceIndex = str.lastIndex(of: \u0026#34; \u0026#34;) { return str.count - 1 - str.distance(from: str.startIndex, to: spaceIndex) } return str.count } } ","tags":["Programming-Basics"],"title":"Length of Last Word - LeetCode : Swift"},{"categories":["Gist"],"date":"September 11, 2023","permalink":"https://mahigarg.github.io/gists/roman-to-integer-leetcode/","section":"gists","summary":"Roman to Integer - LeetCode\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Example 1:\nInput: s = \u0026ldquo;III\u0026rdquo;\nOutput: 3\nExplanation: III = 3.\nExample 2:\nInput: s = \u0026ldquo;LVIII\u0026rdquo;\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 3:\nInput: s = \u0026ldquo;MCMXCIV\u0026rdquo;\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\nConstraints:\n1 \u0026lt;= s.length \u0026lt;= 15 s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M'). It is guaranteed that s is a valid roman numeral in the range [1, 3999]. Solution class Solution { func romanToInt(_ s: String) -\u0026gt; Int { let st = Array(s) var value = 0 var result = 0 for index in 0..\u0026lt;s.count { if st[index] == \u0026#34;I\u0026#34; { value = 1 } else if st[index] == \u0026#34;V\u0026#34; { value = 5 } else if st[index] == \u0026#34;X\u0026#34; { value = 10 } else if st[index] == \u0026#34;L\u0026#34; { value = 50 } else if st[index] == \u0026#34;C\u0026#34; { value = 100 } else if st[index] == \u0026#34;D\u0026#34; { value = 500 } else if st[index] == \u0026#34;M\u0026#34; { value = 1000 } if index + 1 \u0026lt; st.count { if st[index] == \u0026#34;I\u0026#34; \u0026amp;\u0026amp; (st[index + 1] == \u0026#34;V\u0026#34; || st[index + 1] == \u0026#34;X\u0026#34; ){ value = -1 * value } else if st[index] == \u0026#34;X\u0026#34; \u0026amp;\u0026amp; (st[index + 1] == \u0026#34;L\u0026#34; || st[index + 1] == \u0026#34;C\u0026#34; ){ value = -1 * value } else if st[index] == \u0026#34;C\u0026#34; \u0026amp;\u0026amp; (st[index + 1] == \u0026#34;D\u0026#34; || st[index + 1] == \u0026#34;M\u0026#34; ){ value = -1 * value } } result = result + value } return result } } ","tags":["Programming-Basics"],"title":"Roman to Integer - LeetCode : Swift"},{"categories":["Gist"],"date":"September 10, 2023","permalink":"https://mahigarg.github.io/gists/remove-duplicates-from-sorted-array-ii-leetcode/","section":"gists","summary":"Remove Duplicates from Sorted Array || - LeetCode\nGiven an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,,]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nConstraints:\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums is sorted in non-decreasing order. Solution class Solution { func removeDuplicates(_ nums: inout [Int]) -\u0026gt; Int { var count: Int = 0 var result: [Int] = [] if nums.count \u0026lt; 2 { return nums.count } for index in 0..\u0026lt;nums.count { if count \u0026lt; 2 { result.append(nums[index]) } if (index + 1) \u0026lt; nums.count { if nums[index] == nums[index + 1] { count += 1 } else if nums[index] != nums[index + 1] { count = 0 } } } nums = result return nums.count } } ","tags":["Programming-Basics"],"title":"Remove Duplicates from Sorted Array II - LeetCode : Swift"},{"categories":["Gist"],"date":"September 9, 2023","permalink":"https://mahigarg.github.io/gists/best-time-to-buy-and-sell-stock-leetcode/","section":"gists","summary":"Best Time to Buy and Sell Stock - LeetCode\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\nConstraints:\n1 \u0026lt;= prices.length \u0026lt;= 105 0 \u0026lt;= prices[i] \u0026lt;= 104 Solution class Solution { func maxProfit(_ prices: [Int]) -\u0026gt; Int { var buy: Int = prices[0] var profit: Int = 0 for price in prices { if buy \u0026gt; price { buy = price } let profitnow = price - buy if profitnow \u0026gt; profit { profit = profitnow } } return profit } } ","tags":["Programming-Basics"],"title":"Best Time to Buy and Sell Stock - LeetCode : Swift"},{"categories":["Gist"],"date":"September 8, 2023","permalink":"https://mahigarg.github.io/gists/rotate-array-leetcode-swift/","section":"gists","summary":"Rotate Array - LeetCode\nGiven an integer array nums, rotate the array to the right by k steps, where k is non-negative.\nExample 1:\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\nExample 2:\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation:\nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\nConstraints:\n1 \u0026lt;= nums.length \u0026lt;= 105 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 0 \u0026lt;= k \u0026lt;= 105 Solution class Solution { func rotate(_ nums: inout [Int], _ k: Int) { if nums.count \u0026gt; 1 \u0026amp;\u0026amp; k \u0026gt; 0 { for index in 1...k { if let value = nums.last { nums.removeLast() nums.insert(value, at: 0) } } } } } ","tags":["Programming-Basics"],"title":"Rotate Array - LeetCode : Swift"},{"categories":["Gist"],"date":"September 6, 2023","permalink":"https://mahigarg.github.io/gists/remove-duplicates-from-sorted-array-leetcode/","section":"gists","summary":"Remove Duplicates from Sorted Array - LeetCode\nGiven an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [\u0026hellip;]; // Input array int[] expectedNums = [\u0026hellip;]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,,,,,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).\nConstraints:\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -100 \u0026lt;= nums[i] \u0026lt;= 100 nums is sorted in non-decreasing order.\nSolution class Solution { func removeDuplicates(_ nums: inout [Int]) -\u0026gt; Int { var result: [Int] = [] for index in 0..\u0026lt;nums.count { if !result.contains(nums[index]) { result.append(nums[index]) } } nums = result return result.count } } ","tags":["Programming-Basics"],"title":"Remove Duplicates from Sorted Array - LeetCode : Swift"},{"categories":["Gist"],"date":"September 5, 2023","permalink":"https://mahigarg.github.io/gists/remove-element-leetcode/","section":"gists","summary":"Remove Element - LeetCode\nGiven an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [\u0026hellip;]; // Input array int val = \u0026hellip;; // Value to remove int[] expectedNums = [\u0026hellip;]; // The expected answer with correct length. // It is sorted with no values equaling val.\nint k = removeElement(nums, val); // Calls your implementation\nassert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i \u0026lt; actualLength; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,,] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,1,2,2,3,0,4,2], val = 2 Output: 5, nums = [0,1,4,0,3,,,_] Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores).\nConstraints:\n0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100 Solution class Solution { func removeElement(_ nums: inout [Int], _ val: Int) -\u0026gt; Int { var result: [Int] = [] for item in nums { if item != val { result.append(item) } } nums = result return nums.count } } ","tags":["Programming-Basics"],"title":"Remove Element - LeetCode : Swift"},{"categories":["Gist"],"date":"September 4, 2023","permalink":"https://mahigarg.github.io/gists/merge-sorted-array-leetcode-swift/","section":"gists","summary":"Merge Sorted Array - LeetCode\nYou are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\nExample 2:\nInput: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1].\nExample 3:\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\nConstraints:\nnums1.length == m + n nums2.length == n 0 \u0026lt;= m, n \u0026lt;= 200 1 \u0026lt;= m + n \u0026lt;= 200 -109 \u0026lt;= nums1[i], nums2[j] \u0026lt;= 109\nSolution class Solution { func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) { var result: [Int] = [] var c1 = 0 var c2 = 0 for _ in 0...(m + n ) { if c1 == m { result.append(contentsOf: nums2[c2..\u0026lt;n]) break } else if c2 == n { result.append(contentsOf: nums1[c1..\u0026lt;m]) break } else if nums1[c1] \u0026lt;= nums2[c2] { result.append(nums1[c1]) c1 += 1 } else if nums2[c2] \u0026lt; nums1[c1] { result.append(nums2[c2]) c2 += 1 } } nums1 = result } } ","tags":["Programming-Basics"],"title":"Merge Sorted Array - LeetCode : Swift"},{"categories":["Gist"],"date":"September 3, 2023","permalink":"https://mahigarg.github.io/gists/next-greater-element-i-leetcode/","section":"gists","summary":"Next Greater Element I - LeetCode\nThe next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 \u0026lt;= i \u0026lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.\nExample 1:\nInput: nums1 = [4,1,2], nums2 = [1,3,4,2] Output: [-1,3,-1] Explanation: The next greater element for each value of nums1 is as follows:\n4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3. 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4] Output: [3,-1] Explanation: The next greater element for each value of nums1 is as follows:\n2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3. 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1. Constraints:\n1 \u0026lt;= nums1.length \u0026lt;= nums2.length \u0026lt;= 1000 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 104 All integers in nums1 and nums2 are unique. All the integers of nums1 also appear in nums2.\nSolution class Solution { func nextGreaterElement(_ num1: [Int], _ num2: [Int]) -\u0026gt; [Int] { var result: [Int] = [] for i in 0..\u0026lt;num1.count { var x = num1[i] var resultAppended = false var numFound = false for j in 0..\u0026lt;num2.count { if (numFound \u0026amp;\u0026amp; num2[j] \u0026gt; x){ resultAppended = true result.append(num2[j]) break } if num2[j] == x { numFound = true } } if !resultAppended { result.append(-1) } } return result } } ","tags":["Programming-Basics"],"title":"Next Greater Element I - LeetCode : Swift"},{"categories":["Gist"],"date":"September 2, 2023","permalink":"https://mahigarg.github.io/gists/longest-common-prefix-leetcode/","section":"gists","summary":"Longest Common Prefix - LeetCode\nWrite a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \u0026quot;\u0026quot;.\nExample 1:\nInput: strs = [\u0026ldquo;flower\u0026rdquo;,\u0026ldquo;flow\u0026rdquo;,\u0026ldquo;flight\u0026rdquo;] Output: \u0026ldquo;fl\u0026rdquo;\nExample 2:\nInput: strs = [\u0026ldquo;dog\u0026rdquo;,\u0026ldquo;racecar\u0026rdquo;,\u0026ldquo;car\u0026rdquo;] Output: \u0026quot;\u0026quot; Explanation: There is no common prefix among the input strings.\nConstraints:\n1 \u0026lt;= strs.length \u0026lt;= 200 0 \u0026lt;= strs[i].length \u0026lt;= 200 strs[i] consists of only lowercase English letters. Solution class Solution { func longestCommonPrefix(_ strs: [String]) -\u0026gt; String { var key = \u0026#34;\u0026#34; let tem = Array(strs[0]) for i in 0..\u0026lt;tem.count { key.append(tem[i]) for item in strs { if !item.hasPrefix(key) { return String(key.dropLast(1)) } } } return key } } ","tags":["Programming-Basics"],"title":"Longest Common Prefix - LeetCode : Swift"},{"categories":["Gist"],"date":"September 1, 2023","permalink":"https://mahigarg.github.io/gists/two-sum-leetcode-swift/","section":"gists","summary":"Two Sum - LeetCode\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\nInput: nums = [3,2,4], target = 6 Output: [1,2]\nExample 3:\nInput: nums = [3,3], target = 6 Output: [0,1]\nConstraints:\n2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 Only one valid answer exists. Solution class Solution { func twoSum(_ nums: [Int], _ target: Int) -\u0026gt; [Int] { var map: [Int : Int] = [:] for (index, value) in nums.enumerated() { if let value2 = map[target - value] { return [index, value2] } map[nums[index]] = index } return [0, 0] } } ","tags":["Programming-Basics"],"title":"Two Sum - LeetCode : Swift"},{"categories":["Gist"],"date":"August 30, 2023","permalink":"https://mahigarg.github.io/gists/fidget-loader-swiftui/","section":"gists","summary":"The Fidget Loader is a dynamic and visually engaging iOS component built using SwiftUI, designed to enhance user experience by providing elegant loading animations within any iOS application. This component serves as an intuitive and customizable loading indicator, seamlessly integrating into various app interfaces.\n","tags":["SwiftUI"],"title":"Fidget Loader : SwiftUI"},{"categories":["Gist"],"date":"August 29, 2023","permalink":"https://mahigarg.github.io/gists/lazy-loader-swiftui/","section":"gists","summary":"The Lazy Loader is a dynamic and visually engaging iOS component built using SwiftUI, designed to enhance user experience by providing elegant loading animations within any iOS application. This component serves as an intuitive and customizable loading indicator, seamlessly integrating into various app interfaces.\n","tags":["SwiftUI"],"title":"Lazy Loader : SwiftUI"},{"categories":["Gist"],"date":"August 28, 2023","permalink":"https://mahigarg.github.io/gists/arc-progress-loader-swiftui/","section":"gists","summary":"The Arc Progress Loader is a dynamic and visually engaging iOS component built using SwiftUI, designed to enhance user experience by providing elegant loading animations within any iOS application. This component serves as an intuitive and customizable loading indicator, seamlessly integrating into various app interfaces.\n","tags":["SwiftUI"],"title":"Arc Progress Loader : SwiftUI"},{"categories":["Gist"],"date":"August 27, 2023","permalink":"https://mahigarg.github.io/gists/four-sided-fidget-loader-swiftui/","section":"gists","summary":"The Four Sided Fidget Loader is a dynamic and visually engaging iOS component built using SwiftUI, designed to enhance user experience by providing elegant loading animations within any iOS application. This component serves as an intuitive and customizable loading indicator, seamlessly integrating into various app interfaces.\n","tags":["SwiftUI"],"title":"Four Sided Fidget Loader: SwiftUI"},{"categories":["Gist"],"date":"August 26, 2023","permalink":"https://mahigarg.github.io/gists/ripple-loader-swiftui/","section":"gists","summary":"The Ripple Loader is a dynamic and visually engaging iOS component built using SwiftUI, designed to enhance user experience by providing elegant loading animations within any iOS application. This component serves as an intuitive and customizable loading indicator, seamlessly integrating into various app interfaces.\n","tags":["SwiftUI"],"title":"Ripple Loader : SwiftUI"},{"categories":["Gist"],"date":"August 25, 2023","permalink":"https://mahigarg.github.io/gists/ring-and-circle-loader-swiftui/","section":"gists","summary":"The Ring and Circle Loader is a dynamic and visually engaging iOS component built using SwiftUI, designed to enhance user experience by providing elegant loading animations within any iOS application. This component serves as an intuitive and customizable loading indicator, seamlessly integrating into various app interfaces.\n","tags":["SwiftUI"],"title":"Ring and Circle Loader : SwiftUI"},{"categories":["Gist"],"date":"August 24, 2023","permalink":"https://mahigarg.github.io/gists/rotating-circular-sticks-loader-swiftui/","section":"gists","summary":"The Rotating Circular Sticks Loader is a dynamic and visually engaging iOS component built using SwiftUI, designed to enhance user experience by providing elegant loading animations within any iOS application. This component serves as an intuitive and customizable loading indicator, seamlessly integrating into various app interfaces.\n","tags":["SwiftUI"],"title":"Rotating Circular Sticks Loader : SwiftUI"},{"categories":["Gist"],"date":"August 23, 2023","permalink":"https://mahigarg.github.io/gists/rotating-square-loader-swiftui/","section":"gists","summary":"The Rotating Square Loader is a dynamic and visually engaging iOS component built using SwiftUI, designed to enhance user experience by providing elegant loading animations within any iOS application. This component serves as an intuitive and customizable loading indicator, seamlessly integrating into various app interfaces.\n","tags":["SwiftUI"],"title":"Rotating Square Loader : SwiftUI"},{"categories":["Blog"],"date":"August 19, 2023","permalink":"https://mahigarg.github.io/blogs/initializer-in-swift/","section":"blogs","summary":"In Swift, initializers are fundamental building blocks that allow you to create instances of classes, structures, and enumerations by setting up their initial state. Swift\u0026rsquo;s initializer syntax is expressive and versatile, offering a variety of ways to customize instance creation.\nWhat are Initializers? Initializers in Swift are special methods that prepare an instance of a class, structure, or enumeration for use. They set up the initial values of properties and perform any necessary setup. Default initializers are provided by Swift for types that don\u0026rsquo;t have any initializers defined explicitly.\nInitializer Syntax: Parameterized Initializers These allow you to customize the initialization process by accepting parameters.\nstruct Point { var x: Double var y: Double init(x: Double, y: Double) { self.x = x self.y = y } } Convenience Initializers These are secondary initializers that call designated initializers and provide a more convenient way to initialize an instance.\nextension Point { init() { self.init(x: 0.0, y: 0.0) } } Initializer Delegation: Designated Initializers: These are the primary initializers of a class or structure that initialize all properties introduced by that class or structure. Convenience Initializers Calling Designated Initializers: Convenience initializers can call designated initializers to ensure that initialization is properly delegated. Failable Initializers: Handling Initialization Failure: Failable initializers are initializers that can return nil if initialization fails due to invalid input.\nReturning nil from Failable Initializers:\nstruct PositiveNumber { var value: Int init?(value: Int) { if value \u0026lt;= 0 { return nil } self.value = value } } Required Initializers: When a class inherits from another class and the superclass has a designated initializer that needs to be overridden in the subclass, you can mark that initializer as \u0026ldquo;required.\u0026rdquo; This means that any subclass must provide an implementation for that initializer, ensuring that the initialization requirements are met throughout the inheritance chain.\nclass Vehicle { var wheels: Int required init(no: Int) { self.wheels = no } } class Car: Vehicle { var color: String init(color: String){ self.color = color super.init(no: 4) } required init(no: Int) { fatalError(\u0026#34;init(no:) has not been implemented\u0026#34;) } } Initializer Inheritance: Overriding Initializers in Subclasses: You can override designated initializers in subclasses using the override keyword.\nAutomatic Inheritance of Required Initializers: Required initializers defined in protocols are automatically inherited by conforming classes.\nConclusion: Initializers in Swift are vital for creating instances with proper initial state. Whether you\u0026rsquo;re defining custom initializers, handling failure cases, or working with inheritance, understanding Swift\u0026rsquo;s initializer system is essential for writing robust and well-structured code. By mastering initializers, you\u0026rsquo;ll be better equipped to create flexible and reliable Swift applications.\nRemember to refer to official Swift documentation and experiment with code to deepen your understanding of initializers and their various nuances. Happy coding!\n","tags":["Swift"],"title":"Initializer in Swift"},{"categories":["Blog"],"date":"August 16, 2023","permalink":"https://mahigarg.github.io/blogs/thread-safety-in-swift/","section":"blogs","summary":"Thread safety refers to a programming concept where data or resources are accessed and modified in a way that ensures correct behavior and prevents conflicts when multiple threads (concurrent execution units) are working with the same data simultaneously. In multi-threaded environments, without proper thread safety measures, unpredictable and erroneous behavior can occur due to race conditions and data inconsistencies.\nDevelopers implement thread safety using various techniques, such as locks, semaphores, atomic operations, and synchronization mechanisms. These techniques help control access to shared resources, ensuring that only one thread can modify or access the resource at a time, while others wait or perform their operations without causing conflicts.\nThread safety is crucial to prevent data corruption, crashes, and unexpected behavior in concurrent programs, and it\u0026rsquo;s especially important in languages like Swift, where multi-threading is common due to the use of Grand Central Dispatch (GCD) and other concurrency frameworks.\nWays to achieve thread safety In Swift, there are several common ways to achieve thread safety when dealing with concurrent programming. Here are some of the most widely used approaches:\nSerial Queues with GCD: Using Grand Central Dispatch (GCD), you can create serial queues that ensure only one task is executed at a time. This is a straightforward way to achieve thread safety.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.serialQueue\u0026#34;) serialQueue.async { // Perform thread-safe operations } Concurrent Queues with GCD: Concurrent queues allow multiple tasks to run concurrently, while still managing synchronization. This can be useful for improving performance when multiple threads can work independently.\nlet concurrentQueue = DispatchQueue(label: \u0026#34;com.example.concurrentQueue\u0026#34;, attributes: .concurrent) concurrentQueue.async { // Perform thread-safe operations } Dispatch Barrier for Read-Write Access: GCD\u0026rsquo;s dispatch barriers are useful for implementing read-write locks. They ensure that a block of code executes exclusively when performing write operations while allowing concurrent read operations.\nlet concurrentQueue = DispatchQueue(label: \u0026#34;com.example.concurrentQueue\u0026#34;, attributes: .concurrent) concurrentQueue.async(flags: .barrier) { // Perform thread-safe write operations } Atomic Properties: In Swift, you can use atomic properties provided by the AtomicValue type from the Swift Atomics library. These properties ensure thread-safe access to the value they encapsulate.\nimport Atomics var atomicValue = ManagedAtomic\u0026lt;Int\u0026gt;.create(initialValue: 0) let newValue = atomicValue.add(1) Actor Model (Swift Concurrency): Swift\u0026rsquo;s concurrency model introduces the actor concept, which encapsulates both data and behavior. Only one task can access an actor\u0026rsquo;s methods and properties at a time, ensuring thread safety.\nactor Counter { private var value = 0 func increment() { value += 1 } } let counter = Counter() await counter.increment() DispatchSemaphore: A semaphore is a synchronization primitive that allows a certain number of threads to access a resource concurrently. It\u0026rsquo;s useful when you want to limit the number of concurrent accesses.\nlet semaphore = DispatchSemaphore(value: 2) DispatchQueue.global().async { semaphore.wait() // Perform thread-safe operations semaphore.signal() } Choose the method that best suits your application\u0026rsquo;s requirements, considering factors like performance, ease of implementation, and compatibility with Swift\u0026rsquo;s evolving concurrency features. The introduction of Swift Concurrency and the Actor model in recent Swift versions provides powerful tools for achieving thread safety in a more natural and structured way.\n","tags":["Swift"],"title":"Thread Safety in Swift"},{"categories":["Blog"],"date":"August 14, 2023","permalink":"https://mahigarg.github.io/blogs/unowned-vs-optional-unowned-references-in-swift/","section":"blogs","summary":"Memory management is a critical consideration in Swift development, and managing references is a key aspect of this. Two reference types that come into play are unowned and optional unowned references. Both are used to prevent strong reference cycles and manage memory efficiently. In this blog, we\u0026rsquo;ll delve into the differences between unowned and optional unowned references with examples to help you understand their applications.\nUnowned References An unowned reference is used when you are certain that the referenced object will never be nil during the lifetime of the reference. If you attempt to access an unowned reference after the referenced object has been deallocated, it will result in a runtime crash. Unowned references are great for situations where the lifetime of the referenced object is guaranteed.\nHere\u0026rsquo;s an example to illustrate the usage of unowned references:\nclass Magazine { let title: String unowned let subscriber: Person init(title: String, subscriber: Person) { self.title = title self.subscriber = subscriber print(\u0026#34;Magazine \\(title) is initialized.\u0026#34;) } deinit { print(\u0026#34;Magazine \\(title) is deallocated.\u0026#34;) } } class Person { let name: String var magazineSubscription: Magazine? init(name: String) { self.name = name print(\u0026#34;Person \\(name) is initialized.\u0026#34;) } deinit { print(\u0026#34;Person \\(name) is deallocated.\u0026#34;) } } var person: Person? var magazine: Magazine? person = Person(name: \u0026#34;Alice\u0026#34;) magazine = Magazine(title: \u0026#34;Tech Today\u0026#34;, subscriber: person!) person = nil // Person Alice is deallocated // Accessing magazine.subscriber now would lead to a runtime error magazine = nil // Magazine Tech Today is deallocated In this example, the unowned reference subscriber in the Magazine class assumes that the referenced subscriber will never be nil as long as the magazine instance exists.\nOptional Unowned References An optional unowned reference, on the other hand, is a variation of the unowned reference that can be nil. This is useful when you need an unowned reference, but there might be situations where the referenced object has already been deallocated. Accessing an optional unowned reference after the referenced object has been deallocated will not result in a crash; instead, it will simply return nil.\nLet\u0026rsquo;s examine the usage of optional unowned references through an example:\nclass School { let name: String weak var principal: Person? init(name: String) { self.name = name print(\u0026#34;School \\(name) is initialized.\u0026#34;) } deinit { print(\u0026#34;School \\(name) is deallocated.\u0026#34;) } } class Person { let name: String var almaMater: School? init(name: String) { self.name = name print(\u0026#34;Person \\(name) is initialized.\u0026#34;) } deinit { print(\u0026#34;Person \\(name) is deallocated.\u0026#34;) } } var school: School? var principal: Person? school = School(name: \u0026#34;Swift High School\u0026#34;) principal = Person(name: \u0026#34;John\u0026#34;) school?.principal = principal principal?.almaMater = school principal = nil // Person John is deallocated // Accessing school.principal now would return nil school = nil // School Swift High School is deallocated In this example, the optional unowned reference principal in the School class allows for the possibility that the referenced principal might already be deallocated.\nDifferences Between Unowned and Optional Unowned References Here\u0026rsquo;s a summary of the key differences between unowned and optional unowned references:\nUnowned References: Assumes that the referenced object will never be nil. Accessing an unowned reference after the referenced object is deallocated results in a runtime error. Suitable when the referenced object\u0026rsquo;s existence is guaranteed. Optional Unowned References: Can be nil, accommodating situations where the referenced object might no longer exist. Accessing an optional unowned reference after the referenced object is deallocated returns nil. Useful when the referenced object\u0026rsquo;s existence is uncertain, and you want to handle the possibility of nil gracefully. Conclusion Understanding the differences between unowned and optional unowned references is crucial for effective memory management in Swift. Unowned references assume the referenced object\u0026rsquo;s existence during the lifetime of the reference, and accessing them after deallocation results in a runtime error. On the other hand, optional unowned references allow for nil values, accommodating situations where the referenced object might no longer exist. By choosing the appropriate reference type based on the certainty of the referenced object\u0026rsquo;s existence, developers can create memory-efficient Swift applications that handle object lifetimes gracefully. Happy coding!\n","tags":["Swift"],"title":"Unowned vs Optional Unowned References in Swift"},{"categories":["Blog"],"date":"August 12, 2023","permalink":"https://mahigarg.github.io/blogs/weak-vs-unowned-references-in-swift/","section":"blogs","summary":"Memory management is a vital consideration when developing applications, and Swift provides developers with different reference types to manage memory effectively. Two of these reference types, weak and unowned, are essential in preventing memory leaks and managing object lifetimes. In this blog, we\u0026rsquo;ll explore the differences between weak and unowned references through examples, helping you understand when to use each type.\nWeak References Weak references are used to avoid strong reference cycles, which can lead to memory leaks. A strong reference cycle occurs when two or more objects reference each other, creating a loop that prevents them from being deallocated. To break this cycle, weak references are employed. A weak reference doesn\u0026rsquo;t increase the reference count of an object, and when the object it references is deallocated, the weak reference automatically becomes nil.\nHere\u0026rsquo;s an example demonstrating the usage of weak references:\nclass Car { let model: String weak var owner: Person? init(model: String) { self.model = model print(\u0026#34;Car \\(model) is initialized.\u0026#34;) } deinit { print(\u0026#34;Car \\(model) is deallocated.\u0026#34;) } } class Person { let name: String var car: Car? init(name: String) { self.name = name print(\u0026#34;Person \\(name) is initialized.\u0026#34;) } deinit { print(\u0026#34;Person \\(name) is deallocated.\u0026#34;) } } var alice: Person? var herCar: Car? alice = Person(name: \u0026#34;Alice\u0026#34;) herCar = Car(model: \u0026#34;Toyota Corolla\u0026#34;) alice?.car = herCar herCar?.owner = alice alice = nil // Person Alice is deallocated, car.owner becomes nil herCar = nil // Car Toyota Corolla is deallocated In this example, the weak reference owner in the Car class prevents a strong reference cycle between alice and herCar. When alice is deallocated, the weak reference owner becomes automatically nil.\nUnowned References Unowned references are also used to break strong reference cycles, but unlike weak references, they assume that the referenced object will never be nil during the lifetime of the reference. If you access an unowned reference after the referenced object has been deallocated, a runtime error occurs. This makes unowned references suitable when the referenced object\u0026rsquo;s existence is guaranteed.\nHere\u0026rsquo;s an example illustrating the usage of unowned references:\nclass Library { let name: String unowned let librarian: Person init(name: String, librarian: Person) { self.name = name self.librarian = librarian print(\u0026#34;Library \\(name) is initialized.\u0026#34;) } deinit { print(\u0026#34;Library \\(name) is deallocated.\u0026#34;) } } var librarian: Person? var library: Library? librarian = Person(name: \u0026#34;John\u0026#34;) library = Library(name: \u0026#34;Swiftville Library\u0026#34;, librarian: librarian!) librarian = nil // Person John is deallocated // Accessing library.librarian now would lead to a runtime error library = nil // Library Swiftville Library is deallocated In this example, the unowned reference librarian in the Library class assumes that the referenced librarian will never be nil as long as the library instance exists.\nWeak vs Unowned Rerference Here\u0026rsquo;s a summary of the key differences between weak and unowned references:\nWeak References: Automatically become nil when the referenced object is deallocated. Used to prevent strong reference cycles and memory leaks. Ideal when the referenced object\u0026rsquo;s existence is uncertain or temporary. Unowned References: Assumes that the referenced object will never be nil. Accessing an unowned reference after the referenced object is deallocated results in a runtime error. Suitable when the referenced object\u0026rsquo;s existence is guaranteed. Conclusion In Swift, choosing between weak and unowned references depends on the object\u0026rsquo;s lifecycle and the relationships between objects. Weak references are used to break strong reference cycles and automatically become nil when the referenced object is deallocated. Unowned references assume the referenced object\u0026rsquo;s existence and lead to runtime errors if accessed after deallocation. By understanding the distinctions between these two reference types, you can make informed decisions about which one to use in your code, ensuring effective memory management in your Swift applications. Happy coding!\n","tags":["Swift"],"title":"Weak vs Unowned References in Swift"},{"categories":["Blog"],"date":"August 10, 2023","permalink":"https://mahigarg.github.io/blogs/strong-vs-weak-vs-unowned-references-in-swift/","section":"blogs","summary":"In the world of Swift programming, memory management is a critical aspect that developers need to consider to create efficient and reliable apps. One of the core concepts in memory management is the use of references to objects, which determine how objects are retained and released in memory. In Swift, there are three types of references that play a crucial role: strong, weak, and unowned references. In this blog, we will explore these three types of references with clear examples to help you understand their significance.\nStrong References A strong reference is the default type of reference in Swift. When you create a new instance of a class and assign it to a property, a strong reference is established. Strong references increase the retain count of an object, ensuring that it remains in memory as long as there are strong references pointing to it. Let\u0026rsquo;s consider an example involving two classes that reference each other:\nclass Author { let name: String var book: Book? init(name: String) { self.name = name print(\u0026#34;\\(name) is an author.\u0026#34;) } deinit { print(\u0026#34;\\(name) is no longer an author.\u0026#34;) } } class Book { let title: String var author: Author? init(title: String) { self.title = title print(\u0026#34;\\(title) is a book.\u0026#34;) } deinit { print(\u0026#34;\\(title) is no longer a book.\u0026#34;) } } var author: Author? var book: Book? author = Author(name: \u0026#34;J.K. Rowling\u0026#34;) book = Book(title: \u0026#34;Harry Potter and the Sorcerer\u0026#39;s Stone\u0026#34;) author?.book = book book?.author = author author = nil // Neither Author nor Book instance is deallocated book = nil The primary difference with strong references is that they keep the referenced object in memory as long as there is at least one strong reference to it. In the example above, even though both author and book are set to nil, neither instance is deallocated because the strong references maintain a reference cycle between them.\nWeak References Weak references are used to avoid strong reference cycles, also known as retain cycles, which can lead to memory leaks. When you declare a reference as weak, it doesn\u0026rsquo;t increase the retain count of the object. If the object it points to is deallocated, the weak reference automatically becomes nil. Let\u0026rsquo;s see this in action:\nclass Customer { let name: String weak var creditCard: CreditCard? init(name: String) { self.name = name print(\u0026#34;\\(name) is a customer.\u0026#34;) } deinit { print(\u0026#34;\\(name) is no longer a customer.\u0026#34;) } } class CreditCard { let number: String var owner: Customer? init(number: String) { self.number = number print(\u0026#34;\\(number) is a credit card.\u0026#34;) } deinit { print(\u0026#34;\\(number) is no longer a credit card.\u0026#34;) } } var customer: Customer? var card: CreditCard? customer = Customer(name: \u0026#34;Alice\u0026#34;) card = CreditCard(number: \u0026#34;1234-5678-9012-3456\u0026#34;) customer?.creditCard = card card?.owner = customer customer = nil // Customer instance is deallocated // The CreditCard\u0026#39;s owner weak reference becomes nil automatically card = nil The key distinction of weak references is that they do not prevent the object they reference from being deallocated. In the example above, when the customer instance is deallocated, the weak reference in the card instance becomes automatically nil, preventing a retain cycle.\nUnowned References Unowned references are similar to weak references in that they also avoid retain cycles. However, unlike weak references, unowned references assume that the referenced object will always exist as long as the unowned reference exists. If the referenced object is deallocated, accessing the unowned reference will result in a runtime error. Here\u0026rsquo;s an example to illustrate this:\nclass Teacher { let name: String unowned var school: School init(name: String, school: School) { self.name = name self.school = school print(\u0026#34;\\(name) is a teacher.\u0026#34;) } deinit { print(\u0026#34;\\(name) is no longer a teacher.\u0026#34;) } } class School { let name: String var teacher: Teacher? init(name: String) { self.name = name print(\u0026#34;\\(name) is a school.\u0026#34;) } deinit { print(\u0026#34;\\(name) is no longer a school.\u0026#34;) } } var school: School? var teacher: Teacher? school = School(name: \u0026#34;Swift High School\u0026#34;) teacher = Teacher(name: \u0026#34;John Smith\u0026#34;, school: school!) school = nil // School instance is deallocated // Accessing teacher.school will result in a runtime error teacher = nil Unowned references provide a balance between strong and weak references. They don\u0026rsquo;t increase the retain count like strong references, yet they require the referenced object to be valid during the entire lifetime of the unowned reference. In the example above, if the school instance is deallocated, accessing teacher.school will lead to a runtime error.\nDifferences Between Strong, Weak, and Unowned References Strong References: Keep the referenced object in memory as long as at least one strong reference exists. Setting a strong reference to nil does not immediately deallocate the object. Weak References: Do not prevent the referenced object from being deallocated. Automatically become nil when the referenced object is deallocated. Used to avoid retain cycles and potential memory leaks. Unowned References: Do not increase the retain count of the referenced object. Assume the referenced object\u0026rsquo;s existence during the lifetime of the unowned reference. Accessing an unowned reference after the referenced object is deallocated leads to a runtime error. Conclusion Understanding the differences between strong, weak, and unowned references is crucial for effective memory management in Swift. Strong references keep objects in memory as long as they are referenced, weak references prevent retain cycles and become nil when the referenced object is deallocated, and unowned references assume the referenced object\u0026rsquo;s existence and lead to runtime errors if accessed after deallocation. By choosing the appropriate reference type based on the requirements of your code, developers can create stable and memory-efficient Swift applications. Happy coding!\n","tags":["Swift"],"title":"Strong vs Weak vs Unowned References in Swift"},{"categories":["Blog"],"date":"August 8, 2023","permalink":"https://mahigarg.github.io/blogs/coredata-swiftui/","section":"blogs","summary":"Merge data management seamlessly with UI. Model, persist, and update app data effortlessly using declarative syntax. Fetch, sort, and filter data effortlessly, ensuring a responsive and engaging user experience. Simplify synchronization between data and UI layers for efficient, scalable app development.\nLet us understand the setup of Core Data in SwiftUI\nCreate Core Data Model Create new file of type Data Model under Core Data. Add entity by tapping on + button. Then add attributes. Your file will look like below after adding EmployeeModel with EmployeeEntity and name and id as attributes Create Core View Model This swift file will contain initialization and methods required to work core data.\nLet us give a look on the code.\nInitialization of Core Data import CoreData class EmployeeViewModel: ObservableObject { var context: NSPersistentContainer @Published var employeeEntity: [EmployeeEntity] = [] init(){ context = NSPersistentContainer(name: \u0026#34;EmployeeModel\u0026#34;) context.loadPersistentStores { description, error in if let error = error { print(\u0026#34;error loading: \\(error)\u0026#34;) } } } } Here, EmployeeModel is initialized using NSPersistentContainer.\nFetching Core Data func fetchData() { let request = NSFetchRequest\u0026lt;EmployeeEntity\u0026gt;(entityName: \u0026#34;EmployeeEntity\u0026#34;) do { employeeEntity = try context.viewContext.fetch(request) } catch (let error) { print(\u0026#34;error fetching: \\(error)\u0026#34;) } } Adding data to Core Data Entity func addData(name: String, id: Int16) { let newEmployee = EmployeeEntity(context: context.viewContext) newEmployee.id = id newEmployee.name = name self.saveData() } Saving Core Data func saveData() { do { try context.viewContext.save() } catch (let error) { print(\u0026#34;error saving: \\(error)\u0026#34;) } } Deleting data from Core Data func deleteData(indexSet: IndexSet) { guard let index = indexSet.first else { return } let entity = employeeEntity[index] context.viewContext.delete(entity) self.saveData() } Using Core Data in swiftUI View Create a @StateObject variable Viewmodel. Use the publised property of Core Data Entity to updae the UI. Publised property of Core Data Entity will work similarly as an data array. Data an be displayed by Using ForEach in stack (HStack or VStack) or List view can also be used to do so.\nstruct EmployeeView: View { @StateObject var viewModel = EmployeeViewModel() /// code Feel free to refer my demo project on Core Data in SwiftUI coredata-swiftui\n","tags":["SwiftUI"],"title":"CoreData in SwiftUI"},{"categories":["Blog"],"date":"August 6, 2023","permalink":"https://mahigarg.github.io/blogs/conditional-expressions-in-swift/","section":"blogs","summary":"Conditional expressions lie at the heart of programming, allowing developers to make decisions and control the flow of their code. In Swift, these expressions provide the foundation for branching logic and executing different paths based on conditions. In this blog, we\u0026rsquo;ll delve into the world of conditional expressions in Swift, exploring their syntax, various constructs, and providing practical examples to demonstrate their power and versatility.\nConditional Expressions Conditional expressions evaluate a condition and execute a certain block of code based on whether the condition is true or false. In Swift, these expressions are primarily implemented using if, else if, and else constructs.\nBasic if Statements The simplest form of a conditional expression is the if statement. Let\u0026rsquo;s consider a scenario where we determine if a given number is positive or negative:\nlet number = 10 if number \u0026gt; 0 { print(\u0026#34;The number is positive.\u0026#34;) } else if number \u0026lt; 0 { print(\u0026#34;The number is negative.\u0026#34;) } else { print(\u0026#34;The number is zero.\u0026#34;) } Here, the if statement evaluates the condition, and if it\u0026rsquo;s true, the corresponding block of code is executed. If not, the code within the else block is executed.\nUsing switch Statements for Multiple Conditions Swift\u0026rsquo;s switch statement is a powerful tool for handling multiple conditions efficiently. Let\u0026rsquo;s create a grade classification based on test scores:\nlet score = 85 switch score { case 90...100: print(\u0026#34;A\u0026#34;) case 80..\u0026lt;90: print(\u0026#34;B\u0026#34;) case 70..\u0026lt;80: print(\u0026#34;C\u0026#34;) case 60..\u0026lt;70: print(\u0026#34;D\u0026#34;) default: print(\u0026#34;F\u0026#34;) } In this example, the switch statement evaluates the score variable against different ranges and prints the corresponding grade classification.\nTernary Conditional Operator The ternary conditional operator (a ? b : c) offers a concise way to perform conditional operations. Let\u0026rsquo;s determine if a user is of legal drinking age:\nlet age = 21 let canDrink = age \u0026gt;= 21 ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34; print(\u0026#34;Can the user drink? \\(canDrink)\u0026#34;) The ternary operator evaluates the condition, and if true, it assigns the value on the left of the colon. Otherwise, it assigns the value on the right.\nUsing if let for Optional Unwrapping The if let construct is invaluable for safely unwrapping optionals and performing conditional logic. Consider extracting an optional value from an array:\nlet optionalNumber: Int? = 42 if let unwrappedNumber = optionalNumber { print(\u0026#34;The unwrapped number is \\(unwrappedNumber)\u0026#34;) } else { print(\u0026#34;The optional number is nil.\u0026#34;) } The if let statement unwraps the optional and executes the block of code if the unwrapping is successful. Otherwise, the else block is executed.\nGuard Statements for Early Exits Swift\u0026rsquo;s guard statement is used for early exits from a block of code. It ensures that specific conditions are met before proceeding with the execution:\nfunc divide(_ a: Double, by b: Double) -\u0026gt; Double? { guard b != 0 else { print(\u0026#34;Division by zero is not allowed.\u0026#34;) return nil } return a / b } if let result = divide(10, by: 2) { print(\u0026#34;Result: \\(result)\u0026#34;) } In this example, the guard statement ensures that division by zero is prevented before performing the calculation.\nConclusion Conditional expressions are the building blocks of decision-making in Swift programming. By mastering the use of if, else, switch, the ternary operator, if let, and the guard statement, you can confidently navigate through complex logic scenarios. Whether you\u0026rsquo;re making simple decisions, safely unwrapping optionals, or orchestrating intricate algorithms, conditional expressions empower you to control the flow of your Swift applications with precision and elegance. Happy coding! 🚀\n","tags":["Swift"],"title":"Conditional Expressions in Swift"},{"categories":["Blog"],"date":"August 6, 2023","permalink":"https://mahigarg.github.io/blogs/retain-cycle-in-swift/","section":"blogs","summary":"Swift\u0026rsquo;s automatic reference counting (ARC) system does a great job of managing memory, there\u0026rsquo;s a phenomenon called retain cycle that can sneakily lead to memory leaks. In this blog post, we\u0026rsquo;ll delve into the world of retain cycles, understand how they occur, and learn effective strategies to prevent them.\nUnderstanding Retain Cycles A retain cycle, also known as a circular reference, occurs when two or more objects reference each other strongly, preventing them from being deallocated. As a result, memory leaks can occur, leading to your app consuming more memory than necessary.\nImagine two classes, Person and Apartment, where each Person owns an Apartment, and each Apartment has a reference to its Tenant. If the references between these objects are strong, a retain cycle can form.\nclass Person { var apartment: Apartment? init() { print(\u0026#34;Person initialized\u0026#34;) } deinit { print(\u0026#34;Person deinitialized\u0026#34;) } } class Apartment { var tenant: Person? init() { print(\u0026#34;Apartment initialized\u0026#34;) } deinit { print(\u0026#34;Apartment deinitialized\u0026#34;) } } var person: Person? var apartment: Apartment? person = Person() apartment = Apartment() person?.apartment = apartment apartment?.tenant = person person = nil apartment = nil Preventing Retain Cycles To avoid retain cycles and the memory leaks they cause, Swift provides several strategies:\nWeak References Use the weak keyword to create a weak reference. A weak reference doesn\u0026rsquo;t keep a strong hold on the referenced object, and it automatically becomes nil when the object it references is deallocated.\nclass Person { var apartment: Apartment? init() { print(\u0026#34;Person initialized\u0026#34;) } deinit { print(\u0026#34;Person deinitialized\u0026#34;) } } class Apartment { weak var tenant: Person? init() { print(\u0026#34;Apartment initialized\u0026#34;) } deinit { print(\u0026#34;Apartment deinitialized\u0026#34;) } } var person: Person? var apartment: Apartment? person = Person() apartment = Apartment() person?.apartment = apartment apartment?.tenant = person person = nil apartment = nil Unowned References An unowned reference is similar to a weak reference, but it\u0026rsquo;s assumed that the reference will never be nil. Be cautious when using unowned references, as they can lead to crashes if accessed after the referenced object has been deallocated.\nCapture Lists When using closures, especially in scenarios like delegates, use capture lists to prevent retain cycles. A capture list defines the relationship between the closure and the objects it references. Declare these references as weak or unowned within the capture list.\nclass ViewController: UIViewController { var dataManager: DataManager! override func viewDidLoad() { super.viewDidLoad() dataManager.loadData { [weak self] result in self?.handleData(result) } } func handleData(_ result: Result\u0026lt;Data, Error\u0026gt;) { // Handle the data } } Conclusion Retain cycles can be subtle and tricky, causing memory leaks in your app. However, by understanding how retain cycles occur and employing strategies like using weak and unowned references and capture lists, you can effectively prevent these memory leaks. As a responsible Swift developer, mastering retain cycle prevention is a crucial step towards building efficient and reliable applications.\n","tags":["Swift"],"title":"Retain Cycle in Swift"},{"categories":["Blog"],"date":"August 4, 2023","permalink":"https://mahigarg.github.io/blogs/objc-in-swift/","section":"blogs","summary":"The @objc attribute in Swift facilitates seamless interaction between Swift and Objective-C codebases by exposing Swift declarations to the Objective-C runtime. It\u0026rsquo;s used to bridge the gap when working with Objective-C frameworks, allowing Swift properties, methods, and classes to be recognized by the Objective-C world. This attribute plays a crucial role in achieving interoperability and integration between the two languages.\nUnderstanding the @objc Attribute The @objc attribute in Swift is used to expose Swift declarations (such as classes, properties, methods, enums, and protocols) to the Objective-C runtime. This attribute bridges the gap between Swift and Objective-C, allowing interoperability between the two languages.\nUsage Scenarios 1. Interacting with Objective-C APIs When you\u0026rsquo;re working with Objective-C frameworks or libraries, you often need to create Swift code that can be understood by the Objective-C runtime. By adding the @objc attribute, you can expose your Swift code to the Objective-C world seamlessly.\n2. Exposing Swift Properties and Methods to Objective-C Consider a scenario where you have a Swift class with properties and methods that you want to access from Objective-C code. Using the @objc attribute, you can make these elements available to the Objective-C runtime.\n@objc class MySwiftClass: NSObject { @objc var name: String @objc func greet() { print(\u0026#34;Hello from Swift!\u0026#34;) } } 3. Creating Subclasses in Objective-C By marking your Swift class with @objc, you can create subclasses of that class in Objective-C. This can be useful when you want to take advantage of Swift\u0026rsquo;s features while still working within an Objective-C codebase.\n@objc class MyBaseClass: NSObject { // Swift implementation } class MySubclass: MyBaseClass { // Swift subclass implementation } Limitations and Considerations While @objc provides a powerful bridge between Swift and Objective-C, there are some limitations and considerations to keep in mind:\nPerformance Overhead: Using @objc can introduce a performance overhead, as the Objective-C runtime imposes certain dynamic dispatch mechanisms that Swift doesn\u0026rsquo;t typically utilize. Type Safety: When you expose Swift code to the Objective-C runtime, you might lose some of Swift\u0026rsquo;s type safety features, leading to potential runtime errors. Feature Availability: Not all Swift features are automatically available in Objective-C. Some Swift-specific features might not work as expected or might need additional annotations or adjustments. Real-World Example: Integrating Swift with Objective-C UI Imagine you\u0026rsquo;re working on a Swift project and need to incorporate an Objective-C UI component. You can use the @objc attribute to make your Swift code interact seamlessly with the Objective-C UI.\nimport UIKit @objc class MySwiftViewController: UIViewController { @objc func presentObjectiveCViewController() { let objectiveCViewController = ObjectiveCViewController() present(objectiveCViewController, animated: true, completion: nil) } } In this example, the MySwiftViewController class exposes the presentObjectiveCViewController method to Objective-C, allowing it to be called from an Objective-C context.\nConclusion The @objc attribute serves as a vital bridge between Swift and Objective-C, enabling you to integrate the two languages and take advantage of both their features. By understanding its usage scenarios, limitations, and real-world examples, you can confidently leverage the power of @objc to create applications that seamlessly combine the strengths of both languages. Whether you\u0026rsquo;re interacting with Objective-C APIs or creating interoperable codebases, @objc is a valuable tool in your Swift development toolkit.\n","tags":["Swift"],"title":"@objc in swift"},{"categories":["Blog"],"date":"August 2, 2023","permalink":"https://mahigarg.github.io/blogs/classes-vs-struct-swift/","section":"blogs","summary":"In the realm of Swift programming, the choice between using classes or structs can significantly impact your code\u0026rsquo;s design, efficiency, and behavior. In this blog, we\u0026rsquo;ll embark on a journey through class and struct differences, focusing on scenarios where classes outshine structs. By exploring practical examples, we\u0026rsquo;ll illuminate the unique capabilities that classes bring to the table.\nUnderstanding the Basics Before diving into the specifics, let\u0026rsquo;s recap the fundamental contrasts between classes and structs:\nClasses: Reference types Support inheritance Have a deinit method for custom deallocation Allow for shared instances with reference semantics Structs: Value types No inheritance but support protocol conformance No deinit since they\u0026rsquo;re automatically deallocated Create distinct copies for each instance Harnessing Class Power Example: Hierarchical Relationships When your application demands a hierarchy of related entities with shared properties and behaviors, classes excel. Consider modeling a vehicle fleet:\nclass Vehicle { var brand: String init(brand: String) { self.brand = brand } func startEngine() { print(\u0026#34;Engine started for \\(brand)\u0026#34;) } } class Car: Vehicle { var passengers: Int init(brand: String, passengers: Int) { self.passengers = passengers super.init(brand: brand) } override func startEngine() { super.startEngine() print(\u0026#34;Car is ready to roll!\u0026#34;) } } Here, using classes enables you to establish a hierarchy by subclassing Vehicle with a specialized class Car.\nExample: Shared Instances When dealing with complex data models or entities that require shared state, classes shine. Let\u0026rsquo;s consider managing a shopping cart:\nclass ShoppingCart { static let shared = ShoppingCart() var items: [String] = [] private init() {} } let cart1 = ShoppingCart.shared let cart2 = ShoppingCart.shared cart1.items.append(\u0026#34;Item A\u0026#34;) print(cart2.items) // Output: [\u0026#34;Item A\u0026#34;] In this case, the shared instance of ShoppingCart serves as a centralized storage for shopping items, thanks to classes\u0026rsquo; reference semantics.\nExample: Custom Deinitialization If you need to perform cleanup operations before an instance is deallocated, classes offer the deinit method. Consider a database connection:\nclass DatabaseConnection { init() { print(\u0026#34;Database connection established\u0026#34;) } deinit { print(\u0026#34;Database connection closed\u0026#34;) } } var connection: DatabaseConnection? = DatabaseConnection() connection = nil // Output: Database connection closed Here, the deinit method ensures proper resource release, showcasing classes\u0026rsquo; capacity for custom cleanup.\nConclusion While structs have their merits in scenarios like immutability and simple data structures, classes provide indispensable features like inheritance, reference semantics, and custom deinitialization. Through real-world examples, we\u0026rsquo;ve uncovered how classes outperform structs in handling hierarchical relationships, shared instances, and cleanup tasks. By recognizing these distinctions, you\u0026rsquo;ll adeptly wield both classes and structs to create efficient, organized, and powerful Swift codebases.\n","tags":["Swift"],"title":"class vs struct: Swift"},{"categories":["Blog"],"date":"July 30, 2023","permalink":"https://mahigarg.github.io/blogs/nested-methods-in-swift/","section":"blogs","summary":"Nested methods in Swift allow you to define a function within the body of another function. This inner function is only accessible within the enclosing function. It\u0026rsquo;s a powerful mechanism for modularizing code and keeping related functionality together.\nBasic Nested Method Let\u0026rsquo;s consider a simple example where we calculate the area of a rectangle using nested methods:\nfunc calculateRectangleArea(length: Double, width: Double) -\u0026gt; Double { func multiply() -\u0026gt; Double { return length * width } return multiply() } let area = calculateRectangleArea(length: 5.0, width: 3.0) print(\u0026#34;Rectangle Area: \\(area)\u0026#34;) // Output: Rectangle Area: 15.0 In this example, the multiply function is nested within calculateRectangleArea, keeping the area calculation logic contained.\nBenefits of Nested Methods: Encapsulation: Nested methods help keep related code together, enhancing code organization and readability. Scope Isolation: Nested methods are only accessible within their parent function, reducing the risk of naming conflicts. Code Reusability: You can create specialized functions for a particular task within a broader context without cluttering the global scope. Nested Method with Parameters Here\u0026rsquo;s an example demonstrating a nested method with parameters:\nfunc greet(name: String) { func getGreeting() -\u0026gt; String { return \u0026#34;Hello, \\(name)!\u0026#34; } let greeting = getGreeting() print(greeting) } greet(name: \u0026#34;Alice\u0026#34;) // Output: Hello, Alice! Practical Use Case Nested methods are particularly handy for scenarios like data validation:\nfunc validateInput(email: String, password: String) -\u0026gt; Bool { func isValidEmail() -\u0026gt; Bool { // Check email format return true } func isValidPassword() -\u0026gt; Bool { // Check password complexity return true } return isValidEmail() \u0026amp;\u0026amp; isValidPassword() } let isValid = validateInput(email: \u0026#34;example@email.com\u0026#34;, password: \u0026#34;SecureP@ssw0rd\u0026#34;) print(\u0026#34;Input Valid: \\(isValid)\u0026#34;) // Output: Input Valid: true Considerations: Nested methods should be used judiciously, primarily for code organization purposes. Overuse of nested methods can lead to overly complex code. For intricate functionalities, consider extracting separate functions.\nConclusion: Swift\u0026rsquo;s nested methods are a valuable tool for encapsulating related functionality within a function\u0026rsquo;s scope, promoting clean code organization and enhanced readability. By understanding their benefits and leveraging examples, developers can use nested methods effectively to streamline their Swift programming projects.\n","tags":["Swift"],"title":"Nested Methods in swift"},{"categories":["Blog"],"date":"July 28, 2023","permalink":"https://mahigarg.github.io/blogs/super-in-swift/","section":"blogs","summary":"In the dynamic world of Swift programming, the super keyword serves as a bridge connecting the past and present—enabling seamless inheritance and collaboration between parent and child classes. Understanding the capabilities of the super keyword is essential for effective object-oriented design and maintaining code coherence. In this blog, we\u0026rsquo;ll dive deep into the intricacies of the super keyword in Swift, illustrated through practical examples.\nDecoding the super Keyword At its essence, the super keyword in Swift refers to the parent class or superclass. It provides a mechanism for accessing and invoking methods, properties, and initializers of the parent class within a subclass.\nUsing super to Access Overridden Methods In an inheritance hierarchy, subclasses can override methods defined in their parent class. The super keyword plays a pivotal role in calling the overridden implementation of the method. Let\u0026rsquo;s consider a scenario involving geometric shapes:\nclass Shape { var description: String { return \u0026#34;This is a shape.\u0026#34; } } class Circle: Shape { var radius: Double init(radius: Double) { self.radius = radius } override var description: String { return super.description + \u0026#34; It is a circle with radius \\(radius).\u0026#34; } } let circle = Circle(radius: 5.0) print(circle.description) In this example, the super keyword is used within the overridden description property of the Circle class to access and extend the behavior of the parent class\u0026rsquo;s description.\nInvoking Superclass Initializers Subclasses often have their own specialized initializers, but they can also inherit initializers from their parent class. The super keyword allows you to invoke the initializer of the superclass, enabling a streamlined initialization process. Let\u0026rsquo;s explore a scenario involving a Vehicle superclass and a Car subclass:\nclass Vehicle { var make: String init(make: String) { self.make = make } } class Car: Vehicle { var model: String init(make: String, model: String) { self.model = model super.init(make: make) } } let car = Car(make: \u0026#34;Toyota\u0026#34;, model: \u0026#34;Corolla\u0026#34;) print(\u0026#34;Car: \\(car.make) \\(car.model)\u0026#34;) By using super.init(make: make) within the Car subclass\u0026rsquo;s initializer, we invoke the Vehicle class\u0026rsquo;s initializer to initialize the common property.\nCollaborating with Parent Class Methods The super keyword is not limited to properties and initializers—it can also be used to call methods defined in the parent class. Let\u0026rsquo;s explore an example involving a BankAccount superclass and a SavingsAccount subclass:\nclass BankAccount { var balance: Double init(balance: Double) { self.balance = balance } func deposit(amount: Double) { balance += amount } } class SavingsAccount: BankAccount { var interestRate: Double init(balance: Double, interestRate: Double) { self.interestRate = interestRate super.init(balance: balance) } func addInterest() { let interest = balance * interestRate deposit(amount: interest) } } let savingsAccount = SavingsAccount(balance: 1000.0, interestRate: 0.05) savingsAccount.addInterest() print(\u0026#34;Updated Balance: \\(savingsAccount.balance)\u0026#34;) In this example, the super.init(balance: balance) call initializes the SavingsAccount subclass with the initial balance from the BankAccount superclass.\nConclusion The super keyword in Swift serves as a bridge that spans the inheritance hierarchy, facilitating collaboration between parent and child classes. From accessing overridden methods and properties to invoking superclass initializers and methods, the super keyword empowers you to create structured, maintainable, and efficient code. By mastering the art of using \u0026ldquo;super,\u0026rdquo; you\u0026rsquo;ll unlock the full potential of inheritance and object-oriented programming in Swift, enabling you to build robust and cohesive software solutions. Happy coding! 🚀\n","tags":["Swift"],"title":"Super in Swift"},{"categories":["Blog"],"date":"July 26, 2023","permalink":"https://mahigarg.github.io/blogs/swift-enum-in-detail/","section":"blogs","summary":"Enumerations, commonly known as enums, are a versatile feature in Swift that allow you to define a group of related values in a structured manner. Enums provide a way to define a type with a limited set of related values. They help make code more readable, self-documenting, and type-safe by enforcing specific cases.\nBasic Enum Definition: enum CompassDirection { case north case south case east case west } let direction: CompassDirection = .north Enum with Associated Values: Enums can also hold associated values, allowing them to represent more complex data structures.\nenum Result\u0026lt;T, E\u0026gt; { case success(T) case failure(E) } let successResult: Result\u0026lt;Int, String\u0026gt; = .success(42) let failureResult: Result\u0026lt;Int, String\u0026gt; = .failure(\u0026#34;Error: Data not found\u0026#34;) Raw Value Enumerations: Enums can have raw values assigned to each case, making them particularly useful when working with data that needs to be serialized or compared.\nenum Weekday: Int { case sunday = 1, monday, tuesday, wednesday, thursday, friday, saturday } let today: Weekday = .wednesday print(\u0026#34;Today is \\(today.rawValue)\u0026#34;) // Output: Today is 4 Associated Values and Methods: Enums can have methods associated with them, enabling behavior specific to each case.\nenum Shape { case circle(radius: Double) case rectangle(width: Double, height: Double) func area() -\u0026gt; Double { switch self { case .circle(let radius): return Double.pi * radius * radius case .rectangle(let width, let height): return width * height } } } let circleShape = Shape.circle(radius: 5.0) let rectangleShape = Shape.rectangle(width: 4.0, height: 3.0) print(\u0026#34;Circle Area: \\(circleShape.area())\u0026#34;) // Output: Circle Area: 78.53981633974483 print(\u0026#34;Rectangle Area: \\(rectangleShape.area())\u0026#34;) // Output: Rectangle Area: 12.0 Enum Iteration: Enums can be iterated, making them useful for generating a list of cases.\nenum Fruit: CaseIterable { case apple, orange, banana, grape } for fruit in Fruit.allCases { print(fruit) } Conclusion: Swift enums provide a structured and type-safe way to define a group of related values. Whether you need to represent simple cases, associate values with them, or even assign raw values, enums offer a powerful mechanism to enhance code readability and maintainability. By understanding the concepts and examples covered in this article, you\u0026rsquo;ll be better equipped to utilize enums effectively in your Swift programming projects.\n","tags":["Swift"],"title":"Swift Enum in detail"},{"categories":["Blog"],"date":"July 24, 2023","permalink":"https://mahigarg.github.io/blogs/self-in-swift/","section":"blogs","summary":"In the realm of Swift programming, mastering the self keyword is essential for crafting clean and efficient code. This small but mighty keyword plays a significant role in object-oriented design, allowing developers to access and manipulate instance-specific properties and methods. In this blog, we\u0026rsquo;ll embark on a journey to unravel the mysteries of the self keyword in Swift, complete with real-world examples that showcase its versatility and importance.\nThe Essence of self in Swift At its core, the self keyword is a reference to the current instance of a class or structure. It\u0026rsquo;s akin to a mirror reflecting an object\u0026rsquo;s internal state, giving you the power to interact with properties and methods from within the instance itself.\nDistinguishing Properties Using self One of the most common use cases for the self keyword is to disambiguate between instance properties and method parameters that share the same name. Let\u0026rsquo;s illustrate this with a simple class:\nclass Person { var name: String init(name: String) { self.name = name } func introduce() { print(\u0026#34;Hello, my name is \\(self.name).\u0026#34;) } } let person = Person(name: \u0026#34;Alice\u0026#34;) person.introduce() By using self.name inside the method, we explicitly refer to the instance\u0026rsquo;s property, avoiding any confusion with the method parameter.\nAverting Ambiguity with Closures and self Closures within Swift can sometimes introduce capture lists that require careful handling of the self keyword. Let\u0026rsquo;s explore a scenario where we use a closure to asynchronously load data:\nclass DataLoader { var data: [String] = [] func fetchData(completion: @escaping () -\u0026gt; Void) { APIManager.fetchDataFromAPI { [weak self] newData in guard let self = self else { return } self.data = newData completion() } } } In this example, we use a [weak self] capture list to prevent potential memory leaks. The self keyword within the closure helps ensure that we\u0026rsquo;re working with the instance in a safe and efficient manner.\nConclusion The self keyword is a powerful tool in the Swift programmer\u0026rsquo;s arsenal, enabling precise communication and interaction between instances and their internals. From resolving naming conflicts to managing closures and embracing the world of class and static methods, self is your guide to navigating the intricate landscape of Swift programming. By mastering the art of using self,\u0026quot; you\u0026rsquo;ll not only write clearer and more expressive code but also unlock the true potential of Swift\u0026rsquo;s object-oriented paradigm. So, go forth and wield the self keyword with confidence, and watch your Swift applications come to life! Happy coding! 🚀\n","tags":["Swift"],"title":"Self in Swift"},{"categories":["Blog"],"date":"July 22, 2023","permalink":"https://mahigarg.github.io/blogs/error-handling-with-do-catch-in-swift/","section":"blogs","summary":"Error handling is a crucial aspect of writing robust and reliable software applications. In Swift, the do-catch construct provides a powerful mechanism for handling errors and gracefully recovering from unexpected situations. In this blog post, we\u0026rsquo;ll delve into the world of do-catch in Swift, exploring its syntax, best practices, and real-world examples to help you master this essential feature.\nUnderstanding do-catch: The do-catch statement is used to enclose code that might throw an error, allowing you to handle the error in a controlled manner. The basic syntax is as follows:\ndo { // Code that might throw an error } catch { // Handle the error } Handling Errors with catch: You can use the catch clause to specify how to handle specific errors or error patterns. Swift allows you to use pattern matching to catch specific error cases.\nenum NetworkError: Error { case noConnection case serverError(statusCode: Int) } func fetchData() throws { // Simulate a network error throw NetworkError.noConnection } do { try fetchData() } catch NetworkError.noConnection { print(\u0026#34;No internet connection.\u0026#34;) } catch NetworkError.serverError(let statusCode) { print(\u0026#34;Server error with status code: \\(statusCode)\u0026#34;) } catch { print(\u0026#34;An unknown error occurred.\u0026#34;) } Using try? and try!: You can use try? to convert errors into optional values, and try! to indicate that you believe an error won\u0026rsquo;t be thrown. However, be cautious when using try! as it can lead to runtime crashes if an error does occur.\nfunc convertToNumber(_ string: String) throws -\u0026gt; Int { guard let number = Int(string) else { throw NSError(domain: \u0026#34;ConversionError\u0026#34;, code: 1, userInfo: nil) } return number } let result1 = try? convertToNumber(\u0026#34;42\u0026#34;) // Returns an optional Int let result2 = try? convertToNumber(\u0026#34;abc\u0026#34;) // Returns nil let result3 = try! convertToNumber(\u0026#34;123\u0026#34;) // Forced unwrapping, assumes no error defer Statements: The defer statement is used to execute code just before a function returns, regardless of whether an error was thrown or not. It\u0026rsquo;s often used for cleanup tasks.\nfunc processFile(filename: String) throws { let file = openFile(filename) defer { closeFile(file) } // Process the file } do { try processFile(filename: \u0026#34;data.txt\u0026#34;) } catch { print(\u0026#34;Error processing file: \\(error)\u0026#34;) } Chaining do-catch Blocks: You can chain multiple do-catch blocks to handle errors at different levels of your code.\nfunc performComplexTask() throws { do { try task1() try task2() try task3() } catch { print(\u0026#34;An error occurred while performing complex task: \\(error)\u0026#34;) throw error } } Conclusion: The do-catch construct is a powerful tool in Swift for handling errors and ensuring the stability and reliability of your applications. By understanding the syntax, leveraging pattern matching, and employing techniques like try?, try!, and defer, you can gracefully handle errors and take appropriate actions to keep your code robust and maintainable. Incorporate these error handling practices into your Swift projects to create software that can gracefully handle unexpected situations and deliver a better user experience. Happy error-free coding! 🚀\n","tags":["Swift"],"title":"Error Handling with do-catch in Swift"},{"categories":["Blog"],"date":"July 20, 2023","permalink":"https://mahigarg.github.io/blogs/as-operator-in-swift/","section":"blogs","summary":"Type casting is a fundamental concept in Swift that allows you to work with instances of different types in a flexible and safe manner. Swift provides three distinct type casting operators: as, as?, and as!. In this blog post, we\u0026rsquo;ll delve into the differences between these operators, when to use each one, and provide real-world examples to illustrate their usage.\nThe as Operator: The as operator is used for explicit type casting, typically within a known class hierarchy. It allows you to treat an instance as a specific type or its subclass.\nclass Animal { } class Dog: Animal { } let myDog: Animal = Dog() if let realDog = myDog as? Dog { print(\u0026#34;My dog is a real dog!\u0026#34;) } The as? Operator: The as? operator is used for optional type casting. It attempts to perform type casting and returns an optional value that\u0026rsquo;s either the desired type or nil.\nlet value: Any = 42 if let intValue = value as? Int { print(\u0026#34;The value is an integer: \\(intValue)\u0026#34;) } else { print(\u0026#34;The value is not an integer.\u0026#34;) } The as! Operator: The as! operator is used for forced type casting. It asserts that the instance is of the specified type, and if it\u0026rsquo;s not, a runtime error occurs.\nlet someValue: Any = \u0026#34;Hello, Swift\u0026#34; let stringValue = someValue as! String print(\u0026#34;The value is: \\(stringValue)\u0026#34;) Handling Incorrect Type Casting: Using as? can help you gracefully handle situations where the type casting might fail without causing runtime errors.\nlet someValue: Any = 3.14 if let stringValue = someValue as? String { print(\u0026#34;The value is a string: \\(stringValue)\u0026#34;) } else { print(\u0026#34;The value is not a string.\u0026#34;) } as vs as? vs as!: Use as when you\u0026rsquo;re confident about the type and need to explicitly cast an instance. Use as? when you want to conditionally cast and handle potential type mismatches. Use as! only when you\u0026rsquo;re sure about the type, as it can lead to runtime crashes if the cast fails. Conclusion: Understanding the differences between as, as?, and as! operators in Swift is essential for handling type casting efficiently and safely. By utilizing these operators appropriately, you can confidently work with instances of different types, create resilient code, and gracefully handle varying scenarios. Incorporate the concepts and examples covered in this blog post into your Swift projects to enhance your programming skills and build more robust applications. Happy coding! 🚀\n","tags":["Swift"],"title":"As Operator (as vs as? vs as!) in Swift"},{"categories":["Gist"],"date":"July 18, 2023","permalink":"https://mahigarg.github.io/gists/bubble-sort-swift/","section":"gists","summary":"Bubble sort is a simple and straightforward sorting algorithm commonly used in computer science. In Swift language, Bubble sort works by repeatedly swapping adjacent elements if they are in the wrong order until the entire list is sorted. It has a time complexity of O(n^2), making it inefficient for large data sets. The algorithm iterates through the list multiple times, comparing and swapping elements. However, it is easy to understand and implement, making it suitable for small or nearly sorted arrays where simplicity is prioritized over efficiency. For larger data sets, more efficient sorting algorithms like QuickSort or MergeSort are preferred.\n","tags":["Programming-Basics"],"title":"Bubble Sort : Swift"},{"categories":["Blog"],"date":"July 18, 2023","permalink":"https://mahigarg.github.io/blogs/is-operator-in-swift/","section":"blogs","summary":"Type checking is a crucial concept in Swift that allows you to determine the type of an instance or value at runtime. Swift offers three distinct type checking mechanisms: is, is?, and is!. In this blog post, we\u0026rsquo;ll delve into the nuances of these operators, when to use each one, and provide real-world examples to illustrate their functionality.\nThe is Operator: The is operator is used to check if an instance is of a particular type or a subclass thereof. It returns a boolean value, indicating whether the instance conforms to the specified type.\nclass Animal { } class Dog: Animal { } let myDog: Animal = Dog() if myDog is Dog { print(\u0026#34;My dog is indeed a dog!\u0026#34;) } The is? Operator: The is? operator is used for optional type checking. It attempts to determine if an instance is of a particular type, and if successful, it returns the instance as that type, wrapped in an optional value. If the instance isn\u0026rsquo;t of the specified type, it returns nil.\nlet value: Any = 42 if let intValue = value is? Int { print(\u0026#34;The value is an integer: \\(intValue)\u0026#34;) } else { print(\u0026#34;The value is not an integer.\u0026#34;) } The is! Operator: The is! operator is used for forced type checking. It asserts that an instance is of a certain type, and if the assertion fails, a runtime error occurs. This operator should be used with caution, as it can lead to runtime crashes.\nlet someValue: Any = \u0026#34;Hello, Swift\u0026#34; let stringValue = someValue is! String print(\u0026#34;The value is: \\(stringValue)\u0026#34;) Handling Incorrect Type Checking: Using is? can help you gracefully handle cases where type checking might fail, avoiding runtime errors.\nlet someValue: Any = 3.14 if let stringValue = someValue is? String { print(\u0026#34;The value is a string: \\(stringValue)\u0026#34;) } else { print(\u0026#34;The value is not a string.\u0026#34;) } is vs is? vs is!: Use is when you simply want to check if an instance is of a certain type. Use is? when you want to conditionally check the type and obtain the instance if it matches. Use is! only when you\u0026rsquo;re absolutely sure about the type, as it can lead to runtime crashes if the check fails. Conclusion: Understanding the distinctions between is, is?, and is! operators in Swift is vital for effective type checking and handling. By employing these operators judiciously, you can confidently verify instance types, create safer code, and adeptly manage dynamic scenarios. Integrate the insights and examples provided in this blog post into your Swift projects to enhance your coding proficiency and craft more resilient applications. Happy coding! 🚀\n","tags":["Swift"],"title":"Is Operator (is vs is? vs is!) in Swift"},{"categories":["Blog"],"date":"July 16, 2023","permalink":"https://mahigarg.github.io/blogs/try-statement-in-swift/","section":"blogs","summary":"Error handling is an integral part of any programming language, and Swift provides a versatile set of tools to handle errors effectively. In this blog post, we will unravel the differences between try, try?, and try! in Swift. We\u0026rsquo;ll explore the scenarios where each variant is most appropriate and provide real-world examples to illustrate their usage.\nThe Basics of Error Handling in Swift: Before diving into the variations of try, let\u0026rsquo;s understand the fundamental concept of error handling in Swift. When a function can potentially throw an error, you mark it with the throws keyword. To call such a function, you use the try keyword to indicate that you\u0026rsquo;re aware of the possibility of an error being thrown.\nUsing try: The standard try keyword is used to call a function that might throw an error. You wrap the function call in a do-catch block to handle the error gracefully.\nenum NetworkError: Error { case noConnection case serverError(statusCode: Int) } func fetchData() throws { // Simulate a network error throw NetworkError.noConnection } do { try fetchData() } catch { print(\u0026#34;An error occurred: \\(error)\u0026#34;) } Using try?: The try? keyword converts errors into optional values. If the function throws an error, the result is nil; otherwise, you receive an optional value.\nfunc convertToNumber(_ string: String) throws -\u0026gt; Int { guard let number = Int(string) else { throw NSError(domain: \u0026#34;ConversionError\u0026#34;, code: 1, userInfo: nil) } return number } let result1 = try? convertToNumber(\u0026#34;42\u0026#34;) // Returns Optional(42) let result2 = try? convertToNumber(\u0026#34;abc\u0026#34;) // Returns nil Using try!: The try! keyword is used when you are certain that an error will not be thrown. If an error does occur, it will result in a runtime crash. This variant should be used cautiously and only when you are absolutely certain that the operation will succeed.\nlet result3 = try! convertToNumber(\u0026#34;123\u0026#34;) // Forced unwrapping, assumes no error Try vs Try? vs Try! and Use Cases: Use try when you want to handle errors explicitly using a do-catch block. Use try? when you are okay with the function returning nil if an error occurs and you don\u0026rsquo;t need detailed error information. Use try! sparingly and only when you are certain that the operation will succeed, like during app initialization or when a failure would indicate a programming error. Conclusion: In Swift, error handling is a powerful mechanism to ensure the stability and reliability of your applications. The choice between try, try?, and try! depends on the context and your specific needs. Use try for explicit error handling, try? for converting errors into optional values, and try! with caution when you\u0026rsquo;re confident about the success of an operation. By mastering these error handling variants, you can create more resilient and robust Swift code that handles unexpected scenarios gracefully. Happy error-free coding! 🚀\n","tags":["Swift"],"title":"Try Statement (Try vs Try? vs Try!) in SWift"},{"categories":["Gist"],"date":"July 15, 2023","permalink":"https://mahigarg.github.io/gists/carousel-view-swiftui/","section":"gists","summary":"A carousel view is a user interface component commonly used in mobile and web applications to display a collection of items in a horizontally scrolling manner. It allows users to swipe or navigate through a set of images, cards, or other content. The carousel view typically presents a subset of items at a time, with the ability to cycle through the remaining items. It is an engaging and intuitive way to showcase multiple pieces of content within a limited space, providing an interactive and visually appealing user experience.\n","tags":["SwiftUI"],"title":"Carousel View : SwiftUI"},{"categories":["Blog"],"date":"July 14, 2023","permalink":"https://mahigarg.github.io/blogs/type-casting-as-operator-in-swift/","section":"blogs","summary":"Type casting is a powerful feature in Swift that allows you to work with instances of different types in a flexible and safe manner. Whether you\u0026rsquo;re dealing with class hierarchies or protocol conformances, type casting provides the tools to convert and manipulate instances effectively. In this blog post, we\u0026rsquo;ll explore the intricacies of type casting in Swift, complete with syntax explanations and real-world examples.\nUpcasting and Downcasting: Type casting in Swift can be broadly categorized into upcasting and downcasting. Upcasting involves treating an instance as its superclass or a more general type, while downcasting involves treating an instance as its subclass or a more specific type.\nclass Vehicle { func description() -\u0026gt; String { return \u0026#34;This is a vehicle.\u0026#34; } } class Car: Vehicle { override func description() -\u0026gt; String { return \u0026#34;This is a car.\u0026#34; } } let myCar: Vehicle = Car() print(myCar.description()) // Output: This is a car if let myRealCar = myCar as? Car { print(myRealCar.description()) // Output: This is a car } Type Casting with Protocols: Type casting is not limited to class hierarchies; it\u0026rsquo;s also applicable to protocols. You can use type casting to check for protocol conformance and access protocol-specific properties and methods.\nprotocol Shape { var area: Double { get } } struct Circle: Shape { var radius: Double var area: Double { return Double.pi * radius * radius } } struct Square: Shape { var sideLength: Double var area: Double { return sideLength * sideLength } } let shapes: [Shape] = [Circle(radius: 5.0), Square(sideLength: 4.0)] for shape in shapes { print(\u0026#34;Area: \\(shape.area)\u0026#34;) } Forced Type Casting: Sometimes, you might be certain about the type of an instance, and you can use forced type casting (as!) to downcast without optional binding.\nlet myShape: Shape = Circle(radius: 3.0) let myCircle = myShape as! Circle print(\u0026#34;Area of the circle: \\(myCircle.area)\u0026#34;) // Output: Area of the circle: 28.274333882308138 Type Casting Any and AnyObject: Swift also provides Any and AnyObject types for working with instances of unknown types. Type casting is useful when you need to access specific properties or methods of these instances.\nlet someObjects: [Any] = [5, \u0026#34;Hello\u0026#34;, Circle(radius: 2.0)] for object in someObjects { if let shape = object as? Circle { print(\u0026#34;Circle area: \\(shape.area)\u0026#34;) } else if let number = object as? Int { print(\u0026#34;Number: \\(number)\u0026#34;) } else if let text = object as? String { print(\u0026#34;Text: \\(text)\u0026#34;) } } Conclusion: Type casting in Swift is a powerful tool that enables you to work with instances of different types in a seamless and safe manner. Whether you\u0026rsquo;re dealing with class hierarchies, protocol conformances, or instances of Any and AnyObject, type casting allows you to unlock the full potential of your code. By mastering the concepts and examples covered in this blog post, you\u0026rsquo;ll be well-equipped to confidently navigate and manipulate different types in your Swift applications. Happy coding! 🚀\n","tags":["Swift"],"title":"Type Casting (as Operator) in Swift"},{"categories":["Gist"],"date":"July 13, 2023","permalink":"https://mahigarg.github.io/gists/linked-list-implementation-swift/","section":"gists","summary":"A linked list is a data structure in Swift that consists of nodes linked together via pointers or references. Each node contains data and a reference to the next node. Unlike an array, a linked list does not require contiguous memory allocation. Insertions and deletions can be performed efficiently in a linked list by updating the pointers, but accessing elements requires traversing the list linearly. Linked lists are useful when frequent insertions or deletions are expected, and their time complexity for most operations is O(1) or O(n) depending on the operation.\n","tags":["Programming-Basics"],"title":"Linked List Implementation: Swift"},{"categories":["Blog"],"date":"July 12, 2023","permalink":"https://mahigarg.github.io/blogs/type-checking-is-operator-in-swift/","section":"blogs","summary":"Type checking is a fundamental concept in programming languages, including Swift. It enables you to determine the type of a value or an instance at runtime, facilitating dynamic behavior and robust code. In this blog post, we\u0026rsquo;ll delve into the world of type checking in Swift, exploring its syntax, use cases, and providing real-world examples to help you grasp this essential concept.\nType Checking with is and as: In Swift, the is keyword is used for type checking, allowing you to check whether an instance is of a certain class or conforms to a specific protocol. The as keyword, on the other hand, is used for type casting, enabling you to downcast instances to a subclass or a more specific type.\nclass Animal { } class Dog: Animal { } class Cat: Animal { } let myDog = Dog() let myCat = Cat() if myDog is Animal { print(\u0026#34;myDog is an Animal\u0026#34;) } if myCat is Dog { print(\u0026#34;myCat is a Dog\u0026#34;) } else { print(\u0026#34;myCat is not a Dog\u0026#34;) } let someAnimal: Animal = myDog if let someDog = someAnimal as? Dog { print(\u0026#34;someAnimal is a Dog\u0026#34;) } else { print(\u0026#34;someAnimal is not a Dog\u0026#34;) } Using Type Casting to Access Subclass Members: Type casting is particularly useful when you have a hierarchy of classes and want to access members specific to a subclass.\nclass Shape { func area() -\u0026gt; Double { return 0.0 } } class Circle: Shape { var radius: Double init(radius: Double) { self.radius = radius } override func area() -\u0026gt; Double { return Double.pi * radius * radius } } let myShape: Shape = Circle(radius: 5.0) if let myCircle = myShape as? Circle { print(\u0026#34;Area of the circle: \\(myCircle.area())\u0026#34;) } else { print(\u0026#34;Not a circle\u0026#34;) } Type Checking with Protocols: Type checking is also useful when working with protocols. You can determine whether an instance conforms to a protocol and then conditionally use protocol-specific behavior.\nprotocol Printable { func printDetails() } class Book: Printable { var title: String init(title: String) { self.title = title } func printDetails() { print(\u0026#34;Book Title: \\(title)\u0026#34;) } } class Magazine: Printable { var issueNumber: Int init(issueNumber: Int) { self.issueNumber = issueNumber } func printDetails() { print(\u0026#34;Magazine Issue: \\(issueNumber)\u0026#34;) } } let items: [Printable] = [Book(title: \u0026#34;Swift Programming\u0026#34;), Magazine(issueNumber: 42)] for item in items { if let printableItem = item as? Book { printableItem.printDetails() } else if let printableItem = item as? Magazine { printableItem.printDetails() } } Conclusion: Type checking in Swift empowers you to create more dynamic and adaptable code by determining the type of instances at runtime. Whether it\u0026rsquo;s checking class hierarchies or protocol conformance, type checking plays a crucial role in enhancing the flexibility and functionality of your Swift applications. By mastering the is and as keywords and understanding their applications, you can create versatile and robust code that gracefully handles different types and situations. Happy coding! 🚀\n","tags":["Swift"],"title":"Type Checking (is Operator) in Swift"},{"categories":["Gist"],"date":"July 11, 2023","permalink":"https://mahigarg.github.io/gists/remove-duplicate-from-array-swift/","section":"gists","summary":"To remove duplicates from an array in Swift using a dictionary, we can create an empty dictionary and iterate through the array. For each element, we use it as a key in the dictionary and assign a dummy value. The dictionary automatically removes duplicate keys, so we end up with only unique elements. The time complexity of this approach is O(n), where n is the number of elements in the array, making it an efficient solution for removing duplicates..\n","tags":["Programming-Basics"],"title":"Remove duplicates from array: Swift"},{"categories":["Blog"],"date":"July 10, 2023","permalink":"https://mahigarg.github.io/blogs/if-let-vs-guard-let-in-swift/","section":"blogs","summary":"Working with optionals is a common scenario in Swift, allowing us to handle situations where a value might be present or absent. Swift provides two powerful constructs, if let and guard let, to safely unwrap optional values. In this blog post, we\u0026rsquo;ll explore the differences between if let and guard let, understand their best use cases, and provide practical examples to demonstrate their elegance and safety.\nif let Unwrapping if let is used to conditionally unwrap an optional value and execute a block of code only when the value is not nil. Here\u0026rsquo;s a simple example of if let in action:\nfunc calculateSquareRoot(_ number: Double?) { if let value = number { let squareRoot = sqrt(value) print(\u0026#34;The square root of \\(value) is \\(squareRoot)\u0026#34;) } else { print(\u0026#34;Invalid number or nil value.\u0026#34;) } } let inputNumber: Double? = 25 calculateSquareRoot(inputNumber) In this example, the function calculateSquareRoot(_:) takes an optional number as input. Inside the if let block, we unwrap number and bind its unwrapped value to value. If number contains a valid value, the square root is calculated and printed. Otherwise, the else block handles the case when number is nil.\nguard let Unwrapping guard let is used to perform early exits from a function or scope if an optional value is nil. It ensures that the unwrapped value is available for the rest of the function or scope, avoiding nested conditionals. Let\u0026rsquo;s see how guard let works:\nfunc calculateSquareRoot(_ number: Double?) { guard let value = number else { print(\u0026#34;Invalid number or nil value.\u0026#34;) return } let squareRoot = sqrt(value) print(\u0026#34;The square root of \\(value) is \\(squareRoot)\u0026#34;) } let inputNumber: Double? = 25 calculateSquareRoot(inputNumber) In this example, the function calculateSquareRoot(_:) uses guard let to unwrap the number. If number is nil, the function immediately exits, avoiding unnecessary computation. Otherwise, the value is available for the rest of the function to calculate the square root.\nDifferences and Use Cases The primary difference between if let and guard let lies in their behavior and use cases:\nif let: Use if let when you want to conditionally perform an action based on the presence of a value. It\u0026rsquo;s suitable for short-lived local unwrapping and can be used inside loops and nested conditionals. guard let: Use guard let when you want to ensure the presence of a value throughout the function or scope. It\u0026rsquo;s ideal for early exits to avoid nested code blocks and make the code more readable and maintainable. Multiple Optional Unwrapping Both if let and guard let can be used for unwrapping multiple optional values, making them versatile tools in Swift:\nfunc processNumbers(_ firstNumber: Int?, _ secondNumber: Int?) { if let number1 = firstNumber, let number2 = secondNumber { let sum = number1 + number2 print(\u0026#34;The sum of \\(number1) and \\(number2) is \\(sum)\u0026#34;) } else { print(\u0026#34;Invalid numbers or nil values.\u0026#34;) } } let a: Int? = 10 let b: Int? = 20 processNumbers(a, b) In this example, the function processNumbers(_:_:) uses if let to unwrap both firstNumber and secondNumber. If both numbers are non-nil, the sum is calculated and printed. Otherwise, the else block handles the case when either or both numbers are nil.\nConclusion In conclusion, both if let and guard let are indispensable tools for safely unwrapping optional values in Swift. Understanding when and how to use them can significantly enhance your code\u0026rsquo;s readability, maintainability, and safety. Remember the following key points:\nUse if let for conditional unwrapping within a limited scope. Use guard let for early exits and to ensure unwrapped values are available throughout the function or scope. Both constructs can handle multiple optional unwrapping efficiently. As you continue to work with optionals in Swift, keep if let and guard let in your toolkit to handle optional values gracefully, making your code more robust and efficient. Happy coding! 🚀\n","tags":["Swift"],"title":"If let vs Guard let in Swift"},{"categories":["Gist"],"date":"July 8, 2023","permalink":"https://mahigarg.github.io/gists/binary-serach-swift/","section":"gists","summary":"Binary search is an efficient search algorithm used to locate a specific element in a sorted array or list. It works by repeatedly dividing the search space in half until the target element is found. In Swift, binary search is typically implemented recursively or iteratively. The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it highly efficient for large data sets as it eliminates half of the remaining search space at each step, significantly reducing the search time.\n","tags":["Programming-Basics"],"title":"Binary Serach : Swift"},{"categories":["Gist"],"date":"July 8, 2023","permalink":"https://mahigarg.github.io/gists/merge-2-sorted-array-swift/","section":"gists","summary":"Merging two sorted Int arrays in Swift means combining them into a single sorted array while preserving the order. With Swift, you can efficiently implement the merging algorithm. By comparing elements in both arrays and arranging them accordingly, you\u0026rsquo;ll obtain a new sorted array. This process ensures that the elements from both arrays are in ascending order, allowing you to organize your data effectively. The merged sorted Int array can be readily used in your Swift app for various purposes like displaying sorted lists or conducting efficient searches.\n","tags":["Programming-Basics"],"title":"Merge 2 sorted Array: Swift"},{"categories":["Gist"],"date":"July 8, 2023","permalink":"https://mahigarg.github.io/gists/merge-2-sorted-linked-list-swift/","section":"gists","summary":"Merging two sorted linked lists in Swift is like combining two ordered lists into one, while still maintaining the sorted order. You can use Swift to define the linked list structure and implement a merging algorithm. By comparing the elements in both lists and arranging them accordingly, you\u0026rsquo;ll create a new sorted linked list. This process ensures that the elements from both lists are in ascending order, resulting in a single, sorted, and merged linked list that you can use in your Swift app for efficient data organization.\n","tags":["Programming-Basics"],"title":"Merge 2 sorted Linked List: Swift"},{"categories":["Gist"],"date":"July 5, 2023","permalink":"https://mahigarg.github.io/gists/instagram-post-swiftui/","section":"gists","summary":"Coding an Instagram post in SwiftUI is an engaging project. You can use various components like images, text, and buttons to design a post layout. With SwiftUI\u0026rsquo;s simple syntax and powerful features, you can easily arrange the content and customize the post\u0026rsquo;s appearance. Adding interactive features like like and comment buttons makes the post come alive. It\u0026rsquo;s a fun way to learn SwiftUI and create your own unique Instagram-style posts, perfect for displaying your creativity or sharing with friends on social media.\n","tags":["SwiftUI"],"title":"Instagram Post : SwiftUI"},{"categories":["Blog"],"date":"July 5, 2023","permalink":"https://mahigarg.github.io/blogs/lazy-property-in-swift/","section":"blogs","summary":"Swift\u0026rsquo;s lazy properties are a remarkable feature that allows developers to defer the initialization of a property until it is first accessed. This delayed initialization can greatly improve performance, especially when dealing with resource-intensive or time-consuming operations. In this blog, we\u0026rsquo;ll explore lazy properties in Swift, understand how they work, and dive into practical examples where they can significantly enhance the efficiency of your code.\nBasic Usage of Lazy Properties Lazy properties are declared using the lazy keyword. They are particularly useful when dealing with properties that are expensive to compute or require external resource allocation. Let\u0026rsquo;s consider a simple example of a DatabaseManager class that loads a database connection lazily.\nclass DatabaseManager { lazy var databaseConnection: DatabaseConnection = { // Perform resource-intensive database connection setup here let connection = DatabaseConnection() // Additional setup, if needed return connection }() } // Usage let manager = DatabaseManager() // At this point, the database connection is not yet initialized // It will be initialized and set up only when the `databaseConnection` property is accessed for the first time let connection = manager.databaseConnection Lazy Property with Complex Initialization Lazy properties can also be used when initializing complex objects. Consider a UserProfile class that fetches user data from a remote server. Using a lazy property, we can ensure that the data is fetched only when needed.\nclass UserProfile { lazy var userData: [String: Any] = { // Fetch user data from the server let data = fetchUserDataFromServer() // Process the data, if required // ... return data }() private func fetchUserDataFromServer() -\u0026gt; [String: Any] { // Simulate server request delay sleep(2) return [\u0026#34;name\u0026#34;: \u0026#34;Mahi Garg\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;email\u0026#34;: \u0026#34;mahi7garg@gmail.com\u0026#34;] } } // Usage let profile = UserProfile() // The user data is not fetched yet // The data will be fetched and processed only when the `userData` property is accessed let data = profile.userData Lazy Property for Dependency Injection Lazy properties can be beneficial for dependency injection scenarios. Suppose we have a WeatherService class that requires a LocationManager instance to function. By using a lazy property, we can ensure that the LocationManager is only created when needed.\nclass WeatherService { lazy var locationManager: LocationManager = { let manager = LocationManager() // Additional setup, if needed return manager }() func fetchWeatherData() { let currentLocation = locationManager.getCurrentLocation() // Fetch weather data based on the current location // ... } } // Usage let weatherService = WeatherService() weatherService.fetchWeatherData() // The `locationManager` is not initialized until `getCurrentLocation()` is called Lazy Properties in Structs Lazy properties are not limited to classes; they can also be used in structs. Let\u0026rsquo;s look at an example of a Configuration struct with a lazy property for loading a configuration file.\nstruct Configuration { lazy var configDictionary: [String: Any] = { // Load configuration data from file let data = loadConfigurationFromFile() // Parse and process data, if needed // ... return data }() private func loadConfigurationFromFile() -\u0026gt; [String: Any] { // Simulate file loading delay sleep(1) return [\u0026#34;apiKey\u0026#34;: \u0026#34;your_api_key\u0026#34;, \u0026#34;themeColor\u0026#34;: \u0026#34;blue\u0026#34;] } } // Usage let config = Configuration() // The configuration data is not loaded until the `configDictionary` property is accessed let apiKey = config.configDictionary[\u0026#34;apiKey\u0026#34;] as? String Conclusion Lazy properties in Swift offer a powerful way to delay the initialization of properties until they are first accessed. By leveraging lazy properties, you can improve the efficiency of your code, especially when dealing with resource-heavy or time-consuming operations. Whether you\u0026rsquo;re fetching data from servers, initializing complex objects, or managing dependencies, lazy properties provide an elegant solution to optimize your Swift code.\nIntegrate lazy properties into your projects to achieve better performance and responsiveness, ensuring that you allocate resources only when they are genuinely needed. Embrace the efficiency that lazy properties bring to your Swift development endeavors, and elevate the overall quality and responsiveness of your applications. Happy coding! 🚀\n","tags":["Swift"],"title":"Lazy Property in Swift"},{"categories":["Gist"],"date":"July 3, 2023","permalink":"https://mahigarg.github.io/gists/instagram-logo-swiftui/","section":"gists","summary":"Creating the Instagram logo in SwiftUI is an exciting task. Using basic shapes like circles, squares, and colors, you can piece together the iconic camera symbol and colorful gradient background. With SwiftUI\u0026rsquo;s user-friendly syntax and pre-built shape modifiers, you\u0026rsquo;ll enjoy a smooth coding experience. By combining shapes and arranging them creatively, you can replicate the recognizable Instagram logo, ready to be used in your own SwiftUI projects or to explore your coding creativity. Have fun and unleash your artistic side while coding this popular logo!\n","tags":["SwiftUI"],"title":"Instagarm Logo : SwiftUI"},{"categories":["Blog"],"date":"July 2, 2023","permalink":"https://mahigarg.github.io/blogs/computed-property-in-swift/","section":"blogs","summary":"In Swift, computed properties are a powerful and elegant feature that allows developers to define custom accessors for their properties. Unlike stored properties, computed properties do not store a value directly. Instead, they calculate their value on-the-fly based on the getter and, if needed, the setter logic provided by the developer. This flexibility opens up numerous possibilities for streamlining code, encapsulating complex logic, and creating more readable and maintainable code.\nIn this blog, we\u0026rsquo;ll dive into computed properties in Swift, learn how they work, and explore several real-world examples where they can significantly improve your code.\nSimple Computed Property Let\u0026rsquo;s start with a straightforward example. Imagine a Circle struct representing a circle with a given radius. Instead of manually computing the area each time, we can create a computed property area that automatically calculates it for us.\nstruct Circle { let radius: Double var area: Double { return Double.pi * radius * radius } } let circle = Circle(radius: 5) print(\u0026#34;Circle\u0026#39;s area: \\(circle.area)\u0026#34;) Computed Property with Dependencies Computed properties can have dependencies on other properties within the same struct or class. For instance, consider a Rectangle struct with width and height properties. We can create a computed property perimeter that depends on these values.\nstruct Rectangle { var width: Double var height: Double var perimeter: Double { return 2 * (width + height) } } var rectangle = Rectangle(width: 10, height: 5) print(\u0026#34;Rectangle\u0026#39;s perimeter: \\(rectangle.perimeter)\u0026#34;) Read-Only Computed Property Computed properties can be either read-only (with only a getter) or read-write (with both a getter and a setter). Let\u0026rsquo;s take a look at an example of a read-only computed property in the context of a Temperature struct.\nstruct Temperature { var celsius: Double var fahrenheit: Double { return celsius * 9 / 5 + 32 } } let temperature = Temperature(celsius: 25) print(\u0026#34;Temperature in Fahrenheit: \\(temperature.fahrenheit)\u0026#34;) Computed Property in Enums Even enums can benefit from computed properties. Consider a Card enum representing a playing card. We can create a computed property isFaceCard that returns true for face cards (Jacks, Queens, and Kings).\nenum Card { case ace, number(Int), face(String) var isFaceCard: Bool { switch self { case .face, .ace: return true case .number: return false } } } let card1 = Card.ace let card2 = Card.face(\u0026#34;Queen\u0026#34;) print(\u0026#34;Card 1 is a face card: \\(card1.isFaceCard)\u0026#34;) print(\u0026#34;Card 2 is a face card: \\(card2.isFaceCard)\u0026#34;) Conclusion Computed properties in Swift offer a flexible and efficient way to encapsulate logic and simplify code. Whether you need to calculate derived properties, create dependencies between properties, or add custom behavior to your data structures, computed properties are the ideal tool for the job.\nBy embracing computed properties in your Swift code, you can enhance code readability, maintainability, and reduce redundancy. This powerful feature demonstrates Swift\u0026rsquo;s commitment to providing developers with elegant and expressive language features.\nStart leveraging computed properties in your own projects today, and witness the benefits of cleaner, more efficient code! Happy coding! 🚀\n","tags":["Swift"],"title":"Computed Property in Swift"},{"categories":["Gist"],"date":"July 2, 2023","permalink":"https://mahigarg.github.io/gists/insertion-sort-swift/","section":"gists","summary":"Insertion sort is a simple sorting algorithm in Swift that builds the final sorted array one element at a time. It iterates through the array, comparing each element with the sorted portion and placing it in the correct position. This process continues until all elements are sorted. Insertion sort has a time complexity of O(n^2) in the worst case, but it performs well on small data sets or partially sorted arrays. It also has an advantage in that it can efficiently sort elements in real-time as they are received or generated.\n","tags":["Programming-Basics"],"title":"Insertion Sort : Swift"},{"categories":["Blog"],"date":"June 30, 2023","permalink":"https://mahigarg.github.io/blogs/guard-let-in-swift/","section":"blogs","summary":"In the realm of Swift programming, handling optionals with precision is of paramount importance to ensure code safety and maintainability. One of the most elegant constructs for handling optionals is the guard let statement. In this blog, we will delve into the world of guard let and explore how it enables developers to gracefully exit functions early when dealing with optional values. By the end of this blog, you will understand why guard let is a powerful tool in your Swift programming arsenal.\nUnderstanding Optionals in Swift: Before we jump into the wonders of guard let, let\u0026rsquo;s take a moment to understand optionals in Swift. An optional is a type that can either store a value or be nil. The presence of the question mark \u0026lsquo;?\u0026rsquo; after a type indicates that it is an optional type. For instance, String? denotes an optional String.\nThe Purpose of guard let: guard let is a control flow statement that ensures a value exists within an optional and, if so, binds it to a non-optional variable for use within the current scope. If the value is nil, the guard statement mandates an early exit from the current function, guard clause, or loop. It helps to keep the main body of code clean and readable by eliminating deeply nested if statements.\nSyntax of guard let: The syntax of guard let is as follows:\nfunc someFunction() { guard let nonOptionalVar = optionalVar else { // Code to be executed if optionalVar is nil // Return, throw, or continue with the rest of the function\u0026#39;s code } // Code to be executed if optionalVar is not nil // nonOptionalVar is safely unwrapped and ready for use within this scope } Example of guard let: Let\u0026rsquo;s illustrate the power of guard let with an example. Suppose we have a function that accepts an optional Int and performs some operation on it:\nfunc performOperation(value: Int?) { // Ensure value is not nil using guard let guard let unwrappedValue = value else { print(\u0026#34;Value is nil. Operation cannot be performed.\u0026#34;) return } // Continue with the operation using unwrappedValue let result = unwrappedValue * 2 print(\u0026#34;The result is: \\(result)\u0026#34;) } In this example, the guard let statement ensures that the value is not nil. If it is nil, the function prints an error message and exits early using the return statement. Otherwise, it continues with the operation, multiplying the unwrappedValue by 2.\nAdvantages of using guard let: Readability: guard let enhances code readability by making the code more concise and reducing nested if statements. Early Exits: It encourages the practice of early exits from a function or block if necessary conditions are not met, leading to more structured and organized code. Safer Code: By forcing developers to handle the nil case upfront, guard let reduces the likelihood of runtime crashes due to unwrapping nil optionals. Improved Maintainability: The use of guard let allows you to handle edge cases efficiently, leading to more maintainable and future-proof code. Conclusion: In conclusion, guard let is a powerful tool that empowers Swift developers to handle optionals gracefully. By ensuring that optionals contain valid values and providing an elegant early exit strategy, guard let promotes code safety, readability, and maintainability. When dealing with optional values in Swift, remember to embrace the art of guard let to write clean, robust, and efficient code. Happy coding! 🚀\n","tags":["Swift"],"title":"guard let in Swift"},{"categories":["Gist"],"date":"June 28, 2023","permalink":"https://mahigarg.github.io/gists/selection-sort-swift/","section":"gists","summary":"Selection sort is a sorting algorithm in Swift that works by repeatedly finding the minimum element from the unsorted portion of an array and swapping it with the element in the correct position. This process is iterated until the entire array is sorted. While simple to understand and implement, selection sort has a time complexity of O(n^2), making it inefficient for large data sets. However, it has the advantage of having a minimal number of swaps, which can be beneficial in certain memory-constrained scenarios.\n","tags":["Programming-Basics"],"title":"Selection Sort : Swift"},{"categories":["Blog"],"date":"June 24, 2023","permalink":"https://mahigarg.github.io/blogs/default-statement-in-swift/","section":"blogs","summary":"When working with switch statements in Swift, we often encounter situations where we need to handle known cases explicitly. However, there are times when we also want to handle unknown or unexpected cases gracefully. Swift provides us with a powerful tool, the default statement, to manage such scenarios. In this blog post, we\u0026rsquo;ll explore the default statement in Swift and learn how to effectively handle unknown cases with elegance.\nBasic Usage of default Let\u0026rsquo;s start with a simple example of a switch statement to determine the day of the week based on a given number:\nfunc getDayOfWeek(_ dayNumber: Int) -\u0026gt; String { switch dayNumber { case 1: return \u0026#34;Sunday\u0026#34; case 2: return \u0026#34;Monday\u0026#34; case 3: return \u0026#34;Tuesday\u0026#34; case 4: return \u0026#34;Wednesday\u0026#34; case 5: return \u0026#34;Thursday\u0026#34; case 6: return \u0026#34;Friday\u0026#34; case 7: return \u0026#34;Saturday\u0026#34; default: return \u0026#34;Unknown Day\u0026#34; // Handling unknown cases with \u0026#39;default\u0026#39; } } let dayNumber = 9 let dayOfWeek = getDayOfWeek(dayNumber) print(\u0026#34;The day of the week is: \\(dayOfWeek)\u0026#34;) In this example, we use the default statement to handle the case when the dayNumber does not match any of the specified cases. If dayNumber is not in the range of 1 to 7, the default case is executed, returning Unknown Day.\nHandling Enumerations with default Enums are a powerful feature in Swift, but they can sometimes evolve with new cases added in subsequent versions of your app. To handle future cases gracefully, you can use the default statement in a switch that deals with enum values:\nenum Weather { case sunny case cloudy case rainy // case snowy // Uncomment this line to see how \u0026#39;default\u0026#39; handles the new case. } func getWeatherDescription(_ weather: Weather) -\u0026gt; String { switch weather { case .sunny: return \u0026#34;It\u0026#39;s a sunny day.\u0026#34; case .cloudy: return \u0026#34;Expect some clouds today.\u0026#34; case .rainy: return \u0026#34;Don\u0026#39;t forget your umbrella.\u0026#34; default: return \u0026#34;Weather forecast not available.\u0026#34; // Handling future cases with \u0026#39;default\u0026#39; } } let currentWeather = Weather.snowy let weatherDescription = getWeatherDescription(currentWeather) print(\u0026#34;Weather forecast: \\(weatherDescription)\u0026#34;) In this example, we have an enum Weather representing different weather conditions. If you uncomment the snowy case, the default statement will handle it gracefully as the new case wasn\u0026rsquo;t explicitly listed in the switch.\ndefault for Optional Binding Using the default statement with optional binding is another useful technique. Let\u0026rsquo;s consider an example where we retrieve an element from an array using an index, but the index might be out of bounds:\nfunc getElement(at index: Int, in array: [Int]) -\u0026gt; String { guard index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; array.count else { return \u0026#34;Index out of bounds.\u0026#34; // Handling invalid index with \u0026#39;default\u0026#39; } return \u0026#34;Element at index \\(index) is \\(array[index]).\u0026#34; } let numbers = [10, 23, 5, 17, 8] let indexToRetrieve = 10 let element = getElement(at: indexToRetrieve, in: numbers) print(element) In this example, the default statement handles the case where the index provided is out of bounds. Instead of causing a crash or unexpected behavior, we provide a helpful message.\nThe default statement is a powerful tool in Swift, ensuring that your code gracefully handles unknown or unexpected scenarios. It\u0026rsquo;s particularly useful in switch statements when dealing with enumerations or handling user inputs. By using the default statement effectively, you can enhance the robustness and reliability of your Swift applications.\nRemember to use the default statement thoughtfully, considering potential future changes in your code, and provide helpful responses to users to create a seamless and delightful user experience. Happy coding! 🚀\n","tags":["Swift"],"title":"Default Statement in Swift"},{"categories":["Gist"],"date":"June 23, 2023","permalink":"https://mahigarg.github.io/gists/sort-int-array-0-1-2-swift/","section":"gists","summary":"The Dutch National Flag algorithm is a sorting algorithm that partitions an array into three sections: elements less than a given pivot, elements equal to the pivot, and elements greater than the pivot. In Swift, we can implement this algorithm by maintaining three pointers and swapping elements accordingly. The time complexity of the Dutch National Flag algorithm is O(n), where n is the number of elements in the array. It is an efficient algorithm for sorting arrays with a limited range of values, like sorting colors or other categorical data.\n","tags":["Programming-Basics"],"title":"Sort Int Array of 0, 1 and 2 : Swift (Dutch National Flag )"},{"categories":["Gist"],"date":"June 20, 2023","permalink":"https://mahigarg.github.io/gists/list-swiftui/","section":"gists","summary":"In SwiftUI, the List is a powerful tool for creating neat and organized scrolling lists in apps. Imagine it as a virtual scrollable sheet of paper where you can display various items, like names, messages, or to-do tasks. It automatically adjusts its content, so you don\u0026rsquo;t need to worry about updating the list when things change. Whether you want to showcase a bunch of contacts or a menu with different options, List makes it simple and user-friendly. Users can smoothly scroll through the content, making it easy for them to find and interact with the information you present.\n","tags":["SwiftUI"],"title":"List: SwiftUI"},{"categories":["Blog"],"date":"June 16, 2023","permalink":"https://mahigarg.github.io/blogs/if-let-in-swift/","section":"blogs","summary":"Swift is known for its safety and strong typing, and one of its most powerful features is its handling of optionals. Optionals allow developers to express the possibility of a value being absent, preventing runtime crashes due to nil values. One of the key constructs used in Swift to work with optionals is the if let statement. In this blog, we will explore how if let can make your code cleaner and safer by safely unwrapping optionals in a concise manner.\nUnderstanding Optionals in Swift: Before diving into the if let statement, let\u0026rsquo;s quickly review optionals in Swift. An optional is a type that can either hold a value or be nil. It is represented by appending a question mark \u0026lsquo;?\u0026rsquo; after the type. For example, String? represents an optional String.\nHandling Optionals using if let:\nThe if let statement in Swift allows you to conditionally bind the optional to a non-optional temporary variable within the scope of the if block. It enables you to safely check for nil and simultaneously unwrap the optional\u0026rsquo;s value if it exists, avoiding the need for explicit unwrapping using if-else statements or forced unwrapping with the \u0026lsquo;!\u0026rsquo; operator.\nSyntax of if let: if let nonOptionalVar = optionalVar { // Code to be executed if optionalVar is not nil // nonOptionalVar is safely unwrapped and ready for use within this scope } else { // Code to be executed if optionalVar is nil } Example of if let: Let\u0026rsquo;s consider a simple example where we have an optional variable userName of type String?:\nlet userName: String? = \u0026#34;Mahi\u0026#34; if let name = userName { print(\u0026#34;Welcome, \\(name)\u0026#34;) } else { print(\u0026#34;No user name provided.\u0026#34;) } In this example, if userName contains a value (Mahi in this case), the if let statement binds the unwrapped value to the constant name, and the code inside the if block is executed. If userName is nil, the else block is executed.\nAdvantages of using if let: Safety: The if let statement ensures that you work with a valid, non-nil value. This significantly reduces the risk of runtime crashes caused by unwrapping nil values. Conciseness: if let provides a more concise way to handle optionals compared to traditional if-else or forced unwrapping approaches. Readability: The use of if let makes the code more readable and understandable as it clearly expresses the intent of safely unwrapping an optional. Scope: The unwrapped value is only available within the scope of the if block, ensuring that you won\u0026rsquo;t accidentally use it outside that scope, preventing potential bugs. Conclusion: The if let statement in Swift is a powerful and elegant way to handle optionals. It allows you to safely and concisely unwrap optional values, making your code safer and more readable. By leveraging if let, you can confidently work with optionals, avoiding the pitfalls of forced unwrapping and enhancing the overall robustness of your Swift codebase.\n","tags":["Swift"],"title":"if let in Swift"},{"categories":["Blog"],"date":"May 24, 2023","permalink":"https://mahigarg.github.io/blogs/continue-statement-in-swift/","section":"blogs","summary":"Loop control is a fundamental aspect of programming, allowing developers to iterate over collections and execute specific tasks. However, in real-world scenarios, not every iteration requires the same action. Swift provides a powerful tool called the continue statement, which allows you to skip specific iterations and continue to the next one within a loop. In this blog post, we\u0026rsquo;ll explore the continue statement in Swift, along with practical examples to demonstrate its usefulness.\nSkipping Odd Numbers Let\u0026rsquo;s consider a common scenario where we have an array of numbers, and we want to print only the even numbers while skipping the odd ones:\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] for number in numbers { if number % 2 == 1 { continue // Skip odd numbers and proceed to the next iteration } print(\u0026#34;Even number: \\(number)\u0026#34;) } In this example, the continue statement is used inside the loop to skip odd numbers (number % 2 == 1). When the condition is met, the loop immediately proceeds to the next iteration, effectively skipping the code below the continue statement.\nFiltering String Elements The continue statement is not limited to arrays of numbers; it can be used with any type of collection, including arrays of strings. Here\u0026rsquo;s an example where we want to filter out strings with a length greater than a certain value:\nlet fruits = [\u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;kiwi\u0026#34;, \u0026#34;pear\u0026#34;, \u0026#34;mango\u0026#34;] let maxLength = 5 for fruit in fruits { if fruit.count \u0026gt; maxLength { continue // Skip the string with a length greater than \u0026#39;maxLength\u0026#39; } print(\u0026#34;Fruit: \\(fruit)\u0026#34;) } In this case, the continue statement is employed to skip the strings with a length greater than maxLength. The loop continues with the next iteration when the condition is met, resulting in only shorter strings being printed.\nHandling Optionals The continue statement can be particularly useful when working with optionals. Consider an example where we have an array of optional integers, and we want to print only the non-nil values:\nlet optionalNumbers: [Int?] = [10, nil, 35, nil, 54, 78, nil, 22] for num in optionalNumbers { guard let value = num else { continue // Skip nil values and proceed to the next iteration } print(\u0026#34;Number: \\(value)\u0026#34;) } In this example, the guard statement is used to unwrap the optional num. If num is nil, the continue statement is executed, and the loop proceeds to the next iteration. If num contains a non-nil value, the unwrapped value is printed.\nSkipping Specific Values The continue statement can also be applied to skip specific values, not just based on conditions. Let\u0026rsquo;s say we have an array of colors, and we want to exclude the color \u0026ldquo;yellow\u0026rdquo; from our list:\nlet colors = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;purple\u0026#34;] for color in colors { if color == \u0026#34;yellow\u0026#34; { continue // Skip \u0026#34;yellow\u0026#34; and proceed to the next iteration } print(\u0026#34;Color: \\(color)\u0026#34;) } In this example, the continue statement is used to skip the iteration when the color is equal to \u0026ldquo;yellow,\u0026rdquo; effectively excluding it from the output.\nConclusion The continue statement is a powerful tool that enables developers to control the flow of their loops, skipping unnecessary iterations and improving the efficiency of their code. By using the continue statement judiciously, you can write more concise and optimized loops, enhancing the performance of your Swift applications.\nRemember, with great power comes great responsibility, so make sure to use the continue statement wisely and keep your code readable and maintainable. Happy coding! 🚀\n","tags":["Swift"],"title":"Continue Statement in Swift"},{"categories":["Blog"],"date":"May 21, 2023","permalink":"https://mahigarg.github.io/blogs/swift-functions-single-and-multiple-value-returns/","section":"blogs","summary":"In Swift, functions are the building blocks of code that encapsulate logic and perform specific tasks. They can return values to the caller, either as a single value or as multiple values using tuples. In this blog, we\u0026rsquo;ll explore how Swift functions can efficiently return single and multiple values, and how these powerful features can improve code organization and enhance code reuse.\nReturning a Single Value Swift functions can return a single value of any type, making them ideal for encapsulating logic and computing results that need to be passed back to the caller.\nfunc calculateSum(of a: Int, and b: Int) -\u0026gt; Int { return a + b } let result = calculateSum(of: 5, and: 7) print(\u0026#34;The sum is: \\(result)\u0026#34;) Returning Multiple Values with Tuples Swift functions can also return multiple values using tuples. Tuples are lightweight data structures that group multiple values together.\nfunc findMinMax(in array: [Int]) -\u0026gt; (min: Int, max: Int) { var min = Int.max var max = Int.min for num in array { if num \u0026lt; min { min = num } if num \u0026gt; max { max = num } } return (min, max) } let numbers = [10, 3, 7, 25, 1, 15] let result = findMinMax(in: numbers) print(\u0026#34;Minimum: \\(result.min), Maximum: \\(result.max)\u0026#34;) Named Tuples for Clarity Named tuples add clarity to multiple value returns, making the code self-documenting and easy to understand.\nfunc getUserInfo() -\u0026gt; (name: String, age: Int, email: String) { let name = \u0026#34;John Doe\u0026#34; let age = 30 let email = \u0026#34;john.doe@example.com\u0026#34; return (name, age, email) } let userInfo = getUserInfo() print(\u0026#34;Name: \\(userInfo.name), Age: \\(userInfo.age), Email: \\(userInfo.email)\u0026#34;) Ignoring Tuple Values Sometimes, you may not need all the values returned by a function. In such cases, you can use an underscore (_) to ignore specific tuple values.\nfunc divide(_ dividend: Double, by divisor: Double) -\u0026gt; (quotient: Double, remainder: Double) { let quotient = dividend / divisor let remainder = dividend.truncatingRemainder(dividingBy: divisor) return (quotient, remainder) } let divisionResult = divide(25, by: 4) print(\u0026#34;Quotient: \\(divisionResult.quotient), Remainder: \\(divisionResult.remainder)\u0026#34;) Optional Return Values Swift functions can also return optional values, which may be nil in certain cases.\nfunc findIndex(of element: Int, in array: [Int]) -\u0026gt; Int? { for (index, value) in array.enumerated() { if value == element { return index } } return nil } let numbers = [10, 3, 7, 25, 1, 15] if let index = findIndex(of: 7, in: numbers) { print(\u0026#34;Element found at index \\(index)\u0026#34;) } else { print(\u0026#34;Element not found.\u0026#34;) } Conclusion Swift functions are powerful tools that enable code encapsulation and promote code reuse. By efficiently returning single and multiple values, Swift functions become even more versatile and capable of solving various programming challenges.\nWhether you need to perform calculations, search for elements, or return data structures with multiple values, Swift functions can handle it all. With single value returns, you can easily compute and pass back results, while with multiple value returns using tuples, you can efficiently bundle related data together.\nBy incorporating these Swift function features into your projects, you can write more organized, reusable, and efficient code, streamlining your development process and enhancing code readability. Happy coding! 🚀\n","tags":["Swift"],"title":"Swift Functions: Single and Multiple Value Returns"},{"categories":["Blog"],"date":"May 6, 2023","permalink":"https://mahigarg.github.io/blogs/switch-statement-in-swift/","section":"blogs","summary":"Swift\u0026rsquo;s powerful switch statement is a versatile control flow construct that enables developers to handle complex conditions and pattern matching with ease. Far beyond the conventional use cases, the switch statement in Swift boasts several features that make it an indispensable tool in every developer\u0026rsquo;s toolkit. In this blog, we will explore the various facets of Swift\u0026rsquo;s switch statement, discuss its unique capabilities, and delve into real-world examples to illustrate its flexibility and efficiency.\nThe Basics of Switch At its core, a switch statement allows you to evaluate a value against multiple cases and execute the corresponding code block when a match is found. Let\u0026rsquo;s start with a simple example of using a switch statement to handle different days of the week.\nlet day = \u0026#34;Tuesday\u0026#34; switch day { case \u0026#34;Monday\u0026#34;: print(\u0026#34;It\u0026#39;s Monday, the week just started!\u0026#34;) case \u0026#34;Tuesday\u0026#34;: print(\u0026#34;It\u0026#39;s Tuesday, getting into the flow.\u0026#34;) case \u0026#34;Wednesday\u0026#34;: print(\u0026#34;It\u0026#39;s Wednesday, halfway through the week.\u0026#34;) default: print(\u0026#34;It\u0026#39;s another day of the week.\u0026#34;) } Pattern Matching Switch statements in Swift go beyond simple value comparisons; they offer powerful pattern matching capabilities. For instance, you can use ranges to handle different scenarios, such as grading a student\u0026rsquo;s score.\nlet score = 85 switch score { case 0..\u0026lt;60: print(\u0026#34;You failed the exam.\u0026#34;) case 60..\u0026lt;70: print(\u0026#34;You got a D.\u0026#34;) case 70..\u0026lt;80: print(\u0026#34;You got a C.\u0026#34;) case 80..\u0026lt;90: print(\u0026#34;You got a B.\u0026#34;) case 90...100: print(\u0026#34;Congratulations! You got an A!\u0026#34;) default: print(\u0026#34;Invalid score.\u0026#34;) } Compound Cases and Where Clause Swift\u0026rsquo;s switch statement allows you to combine multiple cases into a single block using a comma. Moreover, you can utilize the where clause to add additional conditions within a case.\nlet age = 25 switch age { case 0..\u0026lt;18: print(\u0026#34;You are a minor.\u0026#34;) case 18..\u0026lt;21, 21..\u0026lt;25 where age % 2 == 0: print(\u0026#34;You are a young adult.\u0026#34;) case 21..\u0026lt;25 where age % 2 != 0: print(\u0026#34;You are a unique young adult.\u0026#34;) default: print(\u0026#34;You are an adult.\u0026#34;) } Switch with Enums Swift\u0026rsquo;s switch statement seamlessly integrates with enums, making it an excellent choice for handling various enum cases.\nenum TransportMode { case car(speed: Double) case bicycle(speed: Double) case walking } let currentMode = TransportMode.car(speed: 80.0) switch currentMode { case .car(let speed) where speed \u0026gt; 100: print(\u0026#34;You are driving really fast!\u0026#34;) case .car, .bicycle: print(\u0026#34;You are using a vehicle.\u0026#34;) case .walking: print(\u0026#34;You are walking.\u0026#34;) } Conclusion Swift\u0026rsquo;s switch statement is a versatile and powerful control flow construct that allows developers to handle complex scenarios with ease. From basic value comparisons to intricate pattern matching with ranges and where clauses, the switch statement offers flexibility and readability in managing control flow in Swift code.\nWhether you\u0026rsquo;re handling days of the week, grading scores, dealing with enums, or combining cases, the switch statement empowers you to write concise and efficient code. Its unique features make it an indispensable tool for any developer looking to streamline their control flow logic.\nSo, go ahead and embrace the elegance of Swift\u0026rsquo;s switch statement in your projects, and witness how it simplifies your code, making it more expressive and maintainable. Happy coding! 🚀\n","tags":["Swift"],"title":"Switch Statement in Swift"},{"categories":["Blog"],"date":"April 25, 2023","permalink":"https://mahigarg.github.io/blogs/closures-swift/","section":"blogs","summary":"Closures are a powerful feature of the Swift programming language that allows you to write code that can be passed around and executed at a later time. They are self-contained blocks of functionality.\nClosures are commonly used in Swift to perform tasks like sorting and filtering collections and for handling asynchronous tasks.\nSyntax:\nA closure is defined using curly braces { } and can take in one or more arguments, and returns a value. Here’s a basic syntax of a closure:\n{ (params) -\u0026gt; return type in // Statement } params — any value passed to the closure returnType — specifies the type of value returned by the closure in (optional) — used to separate parameters/returnType from the closure body Statement — code to be executed. Closures need not have the first 3 always. Find the below examples supporting the statement.\nvar sayHi = { print(\u0026#34;Hey!\u0026#34;) } // call the closure sayHi() // output is Hey! This example of closure prints a string. It doesn’t require any parameters. It doesn’t return anything. It just has a single line of code to execute.\nNow let us see other examples of closure where we have either a parameter or a return type.\nlet sayHi = { (name: String) in print(\u0026#34;Hey!, \\(name).\u0026#34;) } // closure call sayHi(\u0026#34;Mahi\u0026#34;) // output is Hey!, Mahi let taskCompleted = { ()-\u0026gt; String in return \u0026#34;Bravo You Are Done!\u0026#34; } // closure call print(taskCompleted()) // output is Bravo You Are Done! Hope you have understood what is closure. How to write closure in Swift. Now let us move to the usage of closure in Swift.\nNow let us consider a block of code that needs to be executed after the method has completed its task. Let us have a look below for example.\nfunc add(first: Int, second: Int, completion: (Int) -\u0026gt; String) { let sum = first + second print(completion(sum)) } add(first: 4, second: 56) { result in return \u0026#34;result is \\(result)\u0026#34; } // output is result is 60 add(first: 4, second: 56) { result in return \u0026#34;sum is \\(result)\u0026#34; } // output is sum is 60 Here method add takes 2 integers and 1 closure as arguments. It performs the sum of 2 numbers. After the addition is done it calls the closure to print the result according to the code written in the closure.\nHere, the first method call defines the closure to return the string “result is 60” while the second return the string “sum is 60”. So we can conclude that closure also gives the power to the method to execute a different set of code depending on where it is called.\n","tags":["Swift"],"title":"Closures: Swift"},{"categories":["Blog"],"date":"April 24, 2023","permalink":"https://mahigarg.github.io/blogs/break-statement-in-swift/","section":"blogs","summary":"Control flow is an essential aspect of any programming language, and Swift is no exception. Swift provides a powerful and flexible control flow mechanism that allows developers to direct the flow of their code execution based on certain conditions. One such tool in the Swift developer\u0026rsquo;s toolbox is the break statement.\nThe break statement is used within loops and switch statements to terminate their execution prematurely. It offers a way to exit a loop or switch block before its normal completion, providing developers with greater control over their code. In this blog post, we will explore the break statement in Swift, along with some practical examples to illustrate its usefulness.\nBreaking Out of a Loop A common use case for the break statement is to exit a loop when a certain condition is met. Let\u0026rsquo;s consider an example where we want to find a specific value in an array and stop the search once we find it:\nfunc findValue(_ value: Int, in array: [Int]) -\u0026gt; Bool { for num in array { if num == value { return true // Value found, exit the loop early } } return false // Value not found } let numbers = [10, 23, 5, 17, 8, 13] let searchValue = 17 if findValue(searchValue, in: numbers) { print(\u0026#34;Value \\(searchValue) found in the array.\u0026#34;) } else { print(\u0026#34;Value \\(searchValue) not found in the array.\u0026#34;) } In this example, we have a function findValue(_:in:) that searches for a specific value in the array using a for-in loop. When the desired value is found, the break statement is not required, as the function immediately returns true, breaking out of the loop and exiting the function.\nEarly Exit in a Switch Statement The break statement can also be utilized within a switch statement to exit the switch block prematurely. This can be helpful when you only need to execute code for a specific case and then exit the switch without considering other cases. Here\u0026rsquo;s an example to demonstrate this:\nenum Direction { case north, south, east, west } func getDescription(for direction: Direction) -\u0026gt; String { switch direction { case .north: return \u0026#34;Head northwards.\u0026#34; case .south: return \u0026#34;Go southwards.\u0026#34; case .east: return \u0026#34;Turn towards the east.\u0026#34; case .west: return \u0026#34;Face the west direction.\u0026#34; } } let userDirection = Direction.south let directionDescription = getDescription(for: userDirection) print(directionDescription) In this case, the switch statement evaluates the userDirection and finds it to be .south. As soon as it matches the .south case, it returns the corresponding description without evaluating the other cases. Here, break is not needed since each case has a return statement, causing an early exit from the getDescription function.\nExiting Nested Loops Sometimes, you may have nested loops where you want to break out of both loops simultaneously when a specific condition is met. Swift allows you to label your loops and use the break statement with a label to exit both loops. Here\u0026rsquo;s an example:\nouterLoop: for i in 1...3 { innerLoop: for j in 1...3 { if i * j == 6 { print(\u0026#34;The product of \\(i) and \\(j) is 6.\u0026#34;) break outerLoop // Exit both loops when the condition is met } } } In this example, we have an outer loop and an inner loop. When the condition i * j == 6 is satisfied, we print the product and then use break outerLoop to exit both loops simultaneously.\nConclusion The break statement is a powerful tool that allows developers to take charge of the flow of their code execution. Whether you need to exit a loop early, break out of a switch block, or exit multiple nested loops at once, the break statement has got you covered.\nAs you continue your journey with Swift, remember to use the break statement judiciously, keeping your code clean and maintainable. Happy coding! 🚀\n","tags":["Swift"],"title":"Break Statement in Swift"},{"categories":["Blog"],"date":"April 20, 2023","permalink":"https://mahigarg.github.io/blogs/ternary-conditional-operator-in-swift/","section":"blogs","summary":"Swift\u0026rsquo;s Ternary Conditional Operator is a concise and powerful tool that allows developers to write compact conditional expressions. It provides a more concise alternative to traditional if-else statements, making code more readable and expressive. In this blog, we\u0026rsquo;ll explore the Ternary Conditional Operator in Swift, understand its syntax and usage, and explore real-world examples to illustrate its efficiency and elegance.\nThe Basics of the Ternary Conditional Operator The Ternary Conditional Operator, represented by ? :, is a shorthand way of expressing conditional statements. It has the following syntax:\ncondition ? trueExpression : falseExpression If condition evaluates to true, the trueExpression is executed; otherwise, the falseExpression is executed.\nBasic Usage Example Let\u0026rsquo;s start with a simple example of using the Ternary Conditional Operator to determine if a number is even or odd.\nlet number = 7 let result = number % 2 == 0 ? \u0026#34;even\u0026#34; : \u0026#34;odd\u0026#34; print(\u0026#34;The number is \\(result).\u0026#34;) Handling Optionals The Ternary Conditional Operator is especially useful for working with optionals. It allows us to provide default values when an optional is nil.\nlet optionalName: String? = \u0026#34;John Doe\u0026#34; let displayName = optionalName != nil ? optionalName! : \u0026#34;Anonymous\u0026#34; print(\u0026#34;User\u0026#39;s Display Name: \\(displayName)\u0026#34;) Nested Ternary Operators Ternary operators can be nested to handle multiple conditions. However, it is essential to use them judiciously to maintain code readability.\nlet age = 25 let accessLevel = age \u0026gt;= 18 ? (age \u0026gt;= 21 ? \u0026#34;Full access\u0026#34; : \u0026#34;Limited access\u0026#34;) : \u0026#34;No access\u0026#34; print(\u0026#34;Access level: \\(accessLevel)\u0026#34;) Assigning Values Ternary operators can also be used to conditionally assign values to variables.\nlet isAdmin = true let accessCode = isAdmin ? \u0026#34;admin123\u0026#34; : \u0026#34;guest456\u0026#34; print(\u0026#34;Access Code: \\(accessCode)\u0026#34;) Coalescing Operator vs. Ternary Operator The Ternary Conditional Operator can sometimes be used interchangeably with the nil-coalescing operator (??). However, they serve different purposes and have specific use cases.\nlet optionalNumber: Int? = nil let number = optionalNumber ?? 0 // Equivalent Ternary Operator: // let number = optionalNumber != nil ? optionalNumber! : 0 print(\u0026#34;Number: \\(number)\u0026#34;) Conclusion Swift\u0026rsquo;s Ternary Conditional Operator is a valuable tool for writing concise and readable conditional expressions. It provides an efficient way to streamline code and handle conditionals with elegance and clarity. From basic usage to handling optionals and nested expressions, the Ternary Conditional Operator offers a versatile and expressive approach to conditional logic.\nHowever, it is crucial to use the Ternary Conditional Operator judiciously and strike a balance between conciseness and readability. In some cases, traditional if-else statements or the nil-coalescing operator may be more appropriate.\nBy embracing the Ternary Conditional Operator in your Swift projects, you can enhance code readability, simplify expressions, and make your code more elegant and expressive. Happy coding! 🚀\n","tags":["Swift"],"title":"Ternary Conditional Operator in Swift"},{"categories":["Blog"],"date":"April 17, 2023","permalink":"https://mahigarg.github.io/blogs/enums-in-swift/","section":"blogs","summary":"When it comes to writing clean, maintainable, and bug-free code, Swift provides a powerful feature called enums or enumerations. Enums are a fundamental data type that allows developers to define a set of related values in a type-safe manner. They play a significant role in improving code readability, eliminating runtime errors, and enhancing overall code quality. In this blog, we\u0026rsquo;ll delve into the world of enums in Swift and explore how they can level up your coding game with some practical examples.\nWhat are Enums? Enums, short for enumerations, are a way to define a group of related values in Swift. With enums, you can define a finite set of possible values that a variable can take, and Swift ensures that only those predefined values can be assigned to the variable. This type safety helps catch errors at compile-time, making your code more robust.\nDeclaring Enums Let\u0026rsquo;s start with a simple example of an enum representing different types of fruits:\nenum Fruit { case apple case banana case orange case mango } In this example, we\u0026rsquo;ve declared an enum called Fruit with four cases: apple, banana, orange, and mango. Each case represents a distinct value that a variable of type Fruit can hold.\nUsing Enums Now that we have our Fruit enum, let\u0026rsquo;s see how we can use it in our code:\nvar favoriteFruit = Fruit.apple print(\u0026#34;My favorite fruit is \\(favoriteFruit)\u0026#34;) favoriteFruit = .mango print(\u0026#34;I changed my mind, now my favorite fruit is \\(favoriteFruit)\u0026#34;) The output will be:\nMy favorite fruit is apple I changed my mind, now my favorite fruit is mango As you can see, we can create a variable favoriteFruit of type Fruit and assign it a value from the enum cases. Once a variable is assigned an enum value, it can only be changed to another value from the same enum.\nAssociated Values Enums can also have associated values, which allow us to attach additional information to each case. This feature is particularly useful when a case needs to carry some data along with it. Let\u0026rsquo;s take the example of a Measurement enum:\nenum Measurement { case length(Double) case weight(Double) case temperature(Double) } Here, we\u0026rsquo;ve defined three cases: length, weight, and temperature, and each case has an associated Double value representing the measurement in meters, kilograms, and degrees Celsius, respectively.\nEnum with Associated Values Example func describe(measurement: Measurement) -\u0026gt; String { switch measurement { case let .length(value): return \u0026#34;The length is \\(value) meters.\u0026#34; case let .weight(value): return \u0026#34;The weight is \\(value) kilograms.\u0026#34; case let .temperature(value): return \u0026#34;The temperature is \\(value) degrees Celsius.\u0026#34; } } let lengthMeasurement = Measurement.length(5.3) let weightMeasurement = Measurement.weight(68.2) let temperatureMeasurement = Measurement.temperature(25.0) print(describe(measurement: lengthMeasurement)) print(describe(measurement: weightMeasurement)) print(describe(measurement: temperatureMeasurement)) Output:\nThe length is 5.3 meters. The weight is 68.2 kilograms. The temperature is 25.0 degrees Celsius. Raw Values In addition to associated values, enums in Swift can also have raw values. Raw values are pre-defined values that are implicitly assigned to each enum case. Raw values must have the same data type, and each case\u0026rsquo;s raw value must be unique within the enum. Raw values are particularly useful when working with external data formats or APIs that expect specific values.\nHere\u0026rsquo;s an example of an enum representing the days of the week using raw values:\nenum Weekday: String { case sunday = \u0026#34;Sun\u0026#34; case monday = \u0026#34;Mon\u0026#34; case tuesday = \u0026#34;Tue\u0026#34; case wednesday = \u0026#34;Wed\u0026#34; case thursday = \u0026#34;Thu\u0026#34; case friday = \u0026#34;Fri\u0026#34; case saturday = \u0026#34;Sat\u0026#34; } Enum with Raw Values Example let today = Weekday.friday print(\u0026#34;Today is \\(today.rawValue)\u0026#34;) Output:\nToday is Fri Iterating over Enum Cases Sometimes, you may need to iterate over all the cases of an enum, especially when you have a large number of cases or when you\u0026rsquo;re working with generic code. Swift allows you to do this using the CaseIterable protocol.\nenum Direction: CaseIterable { case north case south case east case west } for direction in Direction.allCases { print(direction) } Output:\nnorth south east west Conclusion Enums in Swift are a powerful tool for creating well-structured, type-safe code. By using enums, you can represent a fixed set of related values, attach additional data to each case, and handle different scenarios more elegantly. Whether you\u0026rsquo;re working with UI elements, API responses, or any other use case, enums will undoubtedly enhance your code\u0026rsquo;s clarity and maintainability.\nSo, the next time you find yourself dealing with a set of related values, consider reaching for enums to make your Swift code more expressive and robust! Happy coding! 🚀\n","tags":["Swift"],"title":"Enums in Swift"},{"categories":["Blog"],"date":"April 12, 2023","permalink":"https://mahigarg.github.io/blogs/inout-in-swift/","section":"blogs","summary":"Swift, being a modern and versatile programming language, offers various features to enhance code functionality and readability. One such powerful feature is the inout parameter, which allows two-way communication between a function and its caller. In this blog post, we\u0026rsquo;ll dive into the world of inout parameters in Swift, understand how they work, and explore practical examples of their usage.\nThe Basics of inout Before we delve into examples, let\u0026rsquo;s understand the basics of inout parameters. In Swift, function parameters are typically passed by value, which means the function receives a copy of the original data. However, when we use inout, we can pass parameters by reference, allowing the function to modify the original value directly.\nExample: Swapping Two Integers: Let\u0026rsquo;s start with a classic example of swapping two integer values using the inout parameter:\nfunc swapIntegers(_ a: inout Int, _ b: inout Int) { let temp = a a = b b = temp } var x = 5 var y = 10 print(\u0026#34;Before swapping: x = \\(x), y = \\(y)\u0026#34;) swapIntegers(\u0026amp;x, \u0026amp;y) print(\u0026#34;After swapping: x = \\(x), y = \\(y)\u0026#34;) In this example, we define a function swapIntegers(_:_:), which takes two inout parameters a and b. We swap the values of a and b using a temporary variable temp. When calling this function, we use the \u0026amp; symbol before the variables\u0026rsquo; names to pass them as inout arguments.\nModifying Array Elements Using inout, we can also modify elements within an array directly. Consider an example where we want to double each element in an array of integers:\nfunc doubleElements(in array: inout [Int]) { for i in 0..\u0026lt;array.count { array[i] *= 2 } } var numbers = [1, 2, 3, 4, 5] print(\u0026#34;Before doubling: \\(numbers)\u0026#34;) doubleElements(in: \u0026amp;numbers) print(\u0026#34;After doubling: \\(numbers)\u0026#34;) In this example, we define the function doubleElements(in:), which takes an inout parameter array. Within the function, we use a loop to double each element in the array, directly modifying its original content.\nPerforming String Reversal Let\u0026rsquo;s explore how to use inout to reverse a given string:\nfunc reverseString(_ text: inout String) { text = String(text.reversed()) } var message = \u0026#34;Hello, Swift!\u0026#34; print(\u0026#34;Original message: \\(message)\u0026#34;) reverseString(\u0026amp;message) print(\u0026#34;Reversed message: \\(message)\u0026#34;) In this example, we have a function reverseString(_:), which takes an inout parameter text. Inside the function, we use the reversed() method of String to reverse the characters and then convert it back to a String. As a result, the original message variable is updated with the reversed content.\ninout and Optional Values We can also use inout with optional values. Consider an example where we want to modify an optional integer value:\nfunc modifyOptionalValue(_ value: inout Int?) { value = value ?? 0 } var optionalNumber: Int? = 42 print(\u0026#34;Optional number: \\(optionalNumber)\u0026#34;) modifyOptionalValue(\u0026amp;optionalNumber) print(\u0026#34;Modified optional number: \\(optionalNumber)\u0026#34;) In this example, the function modifyOptionalValue(_:) takes an inout parameter value of type Int?. Inside the function, we use the nil-coalescing operator ?? to provide a default value of 0 if the optional value is nil.\nConclusion The inout parameter in Swift is a powerful tool that enables two-way communication between functions and their callers. By using inout, you can directly modify the original values of variables, arrays, and even optional values. This feature enhances code readability and enables you to perform complex operations without creating unnecessary copies of data.\nHowever, it\u0026rsquo;s essential to use inout judiciously, as it can lead to unexpected side effects if not used carefully. When using inout, consider its impact on your code\u0026rsquo;s readability, maintainability, and potential unintended consequences.\nIn conclusion, the inout parameter is a valuable addition to Swift\u0026rsquo;s feature set, and understanding its usage can make your code more expressive and efficient. As you continue to explore Swift\u0026rsquo;s capabilities, remember to leverage inout when it suits your needs and enhances the overall functionality of your applications. Happy coding! 🚀\n","tags":["Swift"],"title":"Inout in Swift"},{"categories":["Blog"],"date":"April 6, 2023","permalink":"https://mahigarg.github.io/blogs/structs-in-swift/","section":"blogs","summary":"When it comes to designing data structures in Swift, one of the fundamental building blocks you\u0026rsquo;ll encounter is the struct. A struct, short for structure, is a versatile and lightweight data type that allows you to encapsulate related properties and behaviors together. In this blog, we\u0026rsquo;ll delve into the world of structs in Swift, explore their features, benefits, and demonstrate how they can be used to create robust and maintainable code with practical examples.\nWhat are Structs? In Swift, a struct is a value type that enables you to define a blueprint for creating custom data types. It can include properties to store values and methods to perform actions related to those values. Unlike classes, structs are value types, meaning they are copied when passed around in code, rather than referenced. This behavior can have significant implications for your program\u0026rsquo;s memory management and can be very advantageous in certain scenarios.\nDeclaring Structs Let\u0026rsquo;s start by creating a simple struct to represent a 2D point:\nstruct Point { var x: Double var y: Double } In this example, we\u0026rsquo;ve defined a struct called Point with two properties: x and y, both of type Double. Now, we can create instances of this struct to represent specific points:\nvar origin = Point(x: 0.0, y: 0.0) var pointA = Point(x: 3.5, y: 2.0) Accessing Struct Properties You can access the properties of a struct using dot notation:\nprint(\u0026#34;The x-coordinate of point A is \\(pointA.x)\u0026#34;) print(\u0026#34;The y-coordinate of point A is \\(pointA.y)\u0026#34;) Struct Methods Structs can also have methods, just like classes. Let\u0026rsquo;s add a method to our Point struct to calculate the distance between two points:\nstruct Point { var x: Double var y: Double func distance(to otherPoint: Point) -\u0026gt; Double { let xDistance = self.x - otherPoint.x let yDistance = self.y - otherPoint.y return (xDistance * xDistance + yDistance * yDistance).squareRoot() } } Using Struct Methods let pointB = Point(x: 5.0, y: 4.0) let distance = pointA.distance(to: pointB) print(\u0026#34;The distance between point A and point B is \\(distance)\u0026#34;) Mutating Methods If you want a method to modify the struct\u0026rsquo;s properties, you\u0026rsquo;ll need to mark the method as mutating. Let\u0026rsquo;s add a method to our Point struct that moves the point by a given offset:\nstruct Point { var x: Double var y: Double mutating func moveBy(x deltaX: Double, y deltaY: Double) { x += deltaX y += deltaY } } Using Mutating Methods var pointC = Point(x: 1.0, y: 1.0) print(\u0026#34;Point C before moving: (\\(pointC.x), \\(pointC.y))\u0026#34;) pointC.moveBy(x: 2.5, y: 3.5) print(\u0026#34;Point C after moving: (\\(pointC.x), \\(pointC.y))\u0026#34;) Structs and Immutability Unlike classes, which are reference types, structs are value types and have inherent immutability. This means that by default, you cannot modify the properties of a struct instance declared as a constant (using let). To make a struct mutable, you need to use the mutating keyword with methods that modify its properties, as shown in the previous example.\nPractical Use Case: Currency Conversion Let\u0026rsquo;s consider a practical use case for a struct. We\u0026rsquo;ll create a CurrencyConverter struct that holds the exchange rates for different currencies and provides a method to convert amounts between them:\nstruct CurrencyConverter { var exchangeRates: [String: Double] // e.g., [\u0026#34;USD\u0026#34;: 1.0, \u0026#34;EUR\u0026#34;: 0.85, \u0026#34;JPY\u0026#34;: 109.5] func convert(amount: Double, from sourceCurrency: String, to targetCurrency: String) -\u0026gt; Double? { guard let sourceRate = exchangeRates[sourceCurrency], let targetRate = exchangeRates[targetCurrency] else { return nil } return amount * (targetRate / sourceRate) } } Using CurrencyConverter let converter = CurrencyConverter(exchangeRates: [\u0026#34;USD\u0026#34;: 1.0, \u0026#34;EUR\u0026#34;: 0.85, \u0026#34;JPY\u0026#34;: 109.5]) let amountInUSD = 100.0 if let amountInEUR = converter.convert(amount: amountInUSD, from: \u0026#34;USD\u0026#34;, to: \u0026#34;EUR\u0026#34;) { print(\u0026#34;\\(amountInUSD) USD is equal to \\(amountInEUR) EUR.\u0026#34;) } else { print(\u0026#34;Currency conversion failed.\u0026#34;) } Conclusion Structs are a powerful tool in Swift for building lightweight, flexible, and maintainable data types. They allow you to encapsulate related data and behavior, promote immutability by default, and can be particularly useful when working with value semantics or scenarios where copy-on-write behavior is desirable. By understanding the nuances of structs and incorporating them into your Swift code, you can make your applications more efficient, organized, and robust.\nIn this blog, we\u0026rsquo;ve covered the basics of structs and demonstrated how to create, use, and benefit from them in your Swift projects. Whether you\u0026rsquo;re working on iOS apps, macOS applications, or server-side projects, structs will undoubtedly play a significant role in improving your code quality and overall development experience.\nSo, the next time you find yourself in need of a lightweight, value-based data structure, think of structs as your go-to choice for building clean and elegant solutions! Happy coding! 🚀\n","tags":["Swift"],"title":"Structs in Swift"},{"categories":["Blog"],"date":"April 2, 2023","permalink":"https://mahigarg.github.io/blogs/tuple-in-swift/","section":"blogs","summary":"In Swift, tuples are lightweight data structures that provide a simple and elegant way to group multiple values together. They offer great versatility and are widely used in various scenarios to pass around related pieces of data effortlessly. In this blog, we\u0026rsquo;ll explore the power of tuples in Swift, understand their syntax and usage, and dive into real-world examples to showcase their flexibility and usefulness.\nCreating and Accessing Tuples Let\u0026rsquo;s start with the basics of creating and accessing tuples. A tuple is defined by enclosing multiple values within parentheses. The values can be of different types.\nlet personInfo = (\u0026#34;Mahi Garg\u0026#34;, 30, \u0026#34;mahi7garg@gmail.com\u0026#34;) To access individual elements of a tuple, you can use dot notation followed by the element\u0026rsquo;s index.\nlet name = personInfo.0 let age = personInfo.1 let email = personInfo.2 print(\u0026#34;Name: \\(name), Age: \\(age), Email: \\(email)\u0026#34;) Named Tuples Named tuples add clarity and self-documentation to your code by assigning labels to each element. You can create a named tuple using the following syntax:\nlet personInfo = (name: \u0026#34;Garg\u0026#34;, age: 30, email: \u0026#34;mahi7garg@gmail.com\u0026#34;) Now, you can access elements using their assigned names:\nlet name = personInfo.name let age = personInfo.age let email = personInfo.email print(\u0026#34;Name: \\(name), Age: \\(age), Email: \\(email)\u0026#34;) Returning Multiple Values from Functions Tuples are especially useful for returning multiple values from a function in a single return statement. Let\u0026rsquo;s see an example of a function that calculates the minimum and maximum elements of an array.\nfunc findMinMax(in array: [Int]) -\u0026gt; (min: Int, max: Int) { var min = Int.max var max = Int.min for num in array { if num \u0026lt; min { min = num } if num \u0026gt; max { max = num } } return (min, max) } let numbers = [10, 3, 7, 25, 1, 15] let result = findMinMax(in: numbers) print(\u0026#34;Minimum: \\(result.min), Maximum: \\(result.max)\u0026#34;) Tuples with Pattern Matching Swift\u0026rsquo;s pattern matching capabilities can be seamlessly combined with tuples to create more expressive code. Consider a simple function that checks if a point lies within a given rectangle.\nfunc isPointInside(point: (x: Int, y: Int), rect: (x: Int, y: Int, width: Int, height: Int)) -\u0026gt; Bool { return (rect.x...rect.x + rect.width).contains(point.x) \u0026amp;\u0026amp; (rect.y...rect.y + rect.height).contains(point.y) } let point = (x: 15, y: 10) let rectangle = (x: 10, y: 5, width: 20, height: 15) if isPointInside(point: point, rect: rectangle) { print(\u0026#34;The point lies inside the rectangle.\u0026#34;) } else { print(\u0026#34;The point is outside the rectangle.\u0026#34;) } Conclusion Tuples in Swift are powerful and lightweight data structures that enable developers to group multiple values together effortlessly. Whether you need to bundle related pieces of data, return multiple values from functions, or leverage pattern matching, tuples offer an elegant and expressive solution.\nFrom basic creation and accessing to the more advanced named tuples and pattern matching, Swift\u0026rsquo;s tuples provide great flexibility and readability in your code. Embrace the simplicity and versatility of tuples in your Swift projects, and experience how they simplify your data handling and enhance your code organization. Happy coding! 🚀\n","tags":["Swift"],"title":"Tuple in Swift"},{"categories":["Blog"],"date":"March 26, 2023","permalink":"https://mahigarg.github.io/blogs/classes-in-swift/","section":"blogs","summary":"In the world of Swift, classes form the cornerstone of object-oriented programming (OOP). They provide a powerful mechanism to create blueprints for objects, allowing you to encapsulate data and behaviors together in a structured manner. In this blog, we\u0026rsquo;ll dive into the world of classes in Swift, explore their features, benefits, and demonstrate how they can be used to build sophisticated and reusable code with practical examples.\nWhat are Classes? In Swift, a class is a reference type that defines a blueprint for creating objects. Unlike structs, which are value types, classes are passed around by reference, meaning multiple variables can point to the same underlying instance. Classes support inheritance, enabling you to create hierarchies of related objects, and they play a pivotal role in achieving abstraction and polymorphism, two essential principles of OOP.\nDeclaring Classes Let\u0026rsquo;s start by creating a simple class to represent a Person:\nclass Person { var name: String var age: Int init(name: String, age: Int) { self.name = name self.age = age } func sayHello() { print(\u0026#34;Hello, my name is \\(name) and I am \\(age) years old.\u0026#34;) } } In this example, we\u0026rsquo;ve defined a class called Person with two properties: name and age, along with an initializer to set their initial values. The class also contains a method sayHello() to introduce the person.\nCreating Instances of a Class Now that we have our Person class, let\u0026rsquo;s create instances of it:\nlet john = Person(name: \u0026#34;John\u0026#34;, age: 30) let jane = Person(name: \u0026#34;Jane\u0026#34;, age: 25) Accessing Properties and Calling Methods We can access the properties and call methods of the instances using dot notation:\nprint(john.name) // Output: John print(jane.age) // Output: 25 john.sayHello() // Output: Hello, my name is John and I am 30 years old. jane.sayHello() // Output: Hello, my name is Jane and I am 25 years old. Class Inheritance One of the key features of classes is inheritance, which allows you to create a new class based on an existing one, inheriting its properties and methods. Let\u0026rsquo;s create a subclass Student that inherits from the Person class and adds an additional property:\nclass Student: Person { var school: String init(name: String, age: Int, school: String) { self.school = school super.init(name: name, age: age) } override func sayHello() { print(\u0026#34;Hello, my name is \\(name), I am \\(age) years old, and I study at \\(school).\u0026#34;) } } Creating Instances of a Subclass let alice = Student(name: \u0026#34;Alice\u0026#34;, age: 22, school: \u0026#34;ABC University\u0026#34;) alice.sayHello() // Output: Hello, my name is Alice, I am 22 years old, and I study at ABC University. Access Control Swift provides access control to restrict the visibility of properties, methods, and other components of a class. There are three access levels: public, internal, and private. The default access level is internal, which means the components are accessible within the same module. Let\u0026rsquo;s add access control to our Person class:\nclass Person { private var name: String internal var age: Int init(name: String, age: Int) { self.name = name self.age = age } internal func sayHello() { print(\u0026#34;Hello, my name is \\(name) and I am \\(age) years old.\u0026#34;) } } Conclusion Classes are a powerful tool in Swift for building complex, hierarchical, and reusable code structures. They allow you to create blueprints for objects, promote code organization through inheritance and encapsulation, and enable the use of essential OOP principles such as abstraction and polymorphism.\nIn this blog, we\u0026rsquo;ve covered the basics of classes in Swift and demonstrated how to create, use, and benefit from them in your Swift projects. Whether you\u0026rsquo;re working on iOS apps, macOS applications, or any other Swift-based project, classes will undoubtedly play a significant role in designing efficient and maintainable solutions.\nBy understanding the nuances of classes and incorporating them into your Swift code, you can create robust, flexible, and scalable applications. So, the next time you find yourself building a complex data model, creating an inheritance hierarchy, or leveraging OOP principles, consider Swift classes as your go-to choice for building powerful and expressive solutions! Happy coding! 🚀\n","tags":["Swift"],"title":"Classes in Swift"},{"categories":["Blog"],"date":"March 19, 2023","permalink":"https://mahigarg.github.io/blogs/navigationview-in-swiftui/","section":"blogs","summary":"Navigation involves moving between different screens or views within an app. SwiftUI provides a navigation view hierarchy that allows users to navigate between different views seamlessly. The NavigationView is the container view that manages the navigation stack and provides a NavigationBar at the top to facilitate navigation.\nNavigationView NavigationView serves as the navigation container, hosting a hierarchy of views. At the top of the screen, it presents a navigation bar, which typically includes a back button for easy navigation to the previous view. You can also customize the appearance and behavior of the navigation bar to match your app\u0026rsquo;s style.\nWe will understand how to implement NavigationView and it various modifier. For same let us take an example of code and walk through it step by step.\nImplement NavigationView struct NavigationInSwiftUI: View { var body: some View { NavigationView { ScrollView(.vertical) { NavigationLink(\u0026#34;Navigaton Link\u0026#34;, destination: navigationPage) Text(\u0026#34;Home View\u0026#34;) } .navigationTitle(\u0026#34; Navigation Title\u0026#34;) .navigationBarTitleDisplayMode(.automatic) .navigationBarHidden(false) .navigationBarItems(leading: EditButton(), trailing: Image(systemName: \u0026#34;person.fill\u0026#34;)) } } } var navigationPage: some View { ZStack { Color.purple.edgesIgnoringSafeArea(.all) Text(\u0026#34;Hello World\u0026#34;) } .navigationTitle(\u0026#34; Navigated Page\u0026#34;) } Set Up Navigation Wrap your starting view (usually HomeView) with a NavigationView to set up the navigation hierarchy\nstruct NavigationInSwiftUI: View { var body: some View { NavigationView { ScrollView(.vertical) { Text(\u0026#34;Home View\u0026#34;) } } } } Create NavigationLink Within the HomeView, create a NavigationLink to navigate to the DetailView. Here, in NavigationLink(\u0026quot;Navigaton Link\u0026quot;, destination: navigationPage) Navigation Link is title displayed and destination i.e. navigationPage is the view to which user will navigate on taping Navigation Link\nstruct NavigationInSwiftUI: View { var body: some View { NavigationView { ScrollView(.vertical) { NavigationLink(\u0026#34;Navigaton Link\u0026#34;, destination: navigationPage) Text(\u0026#34;Home View\u0026#34;) } } } } var navigationPage: some View { ZStack { Color.purple.edgesIgnoringSafeArea(.all) Text(\u0026#34;Second Page\u0026#34;) } } NavigationBar Navigation View give navigation Bar as one of its characterstic, where title, left right navigation button can be configured.\nstruct NavigationInSwiftUI: View { var body: some View { NavigationView { ScrollView(.vertical) { NavigationLink(\u0026#34;Navigaton Link\u0026#34;, destination: navigationPage) Text(\u0026#34;Home View\u0026#34;) } } .navigationTitle(\u0026#34; Navigation Title\u0026#34;) .navigationBarTitleDisplayMode(.automatic) .navigationBarHidden(false) .navigationBarItems(leading: EditButton(), trailing: Image(systemName: \u0026#34;person.fill\u0026#34;)) } } navigationTitle navigationTitle will give title to view. 3 display modes for the navigation can be used via navigationBarTitleDisplayMode. These 3 modes are .automatic, .inline and .large.\nnavigationBar navigationBarHidden can be used with true as a parameter to hide the navigationBar. This is used when multiple navigation screen is used under same navigation View and navigation bar need to be hidden for some of them.\nAlso, left and right buttons can be used and given as view like Image(systemName: \u0026quot;person.fill\u0026quot;) using navigationBarItems.\nConclusion NavigationView is a powerful tool that simplifies navigation and enhances the user experience. Now we learned how to create a smooth and intuitive navigation flow. With SwiftUI\u0026rsquo;s NavigationView, we can create engaging and user-friendly apps, guiding users through your content effortlessly. So, dive into your SwiftUI projects and start navigating with style using NavigationView!\n","tags":["SwiftUI"],"title":"NavigationView in SwiftUI"},{"categories":["Blog"],"date":"March 14, 2023","permalink":"https://mahigarg.github.io/blogs/dictionary-swift/","section":"blogs","summary":"Dictionaries in Swift provide a key-value pair mechanism for efficient data storage and retrieval. They are implemented using hash tables, allowing fast access and modification of values based on keys. Dictionaries support operations like adding, removing, and iterating over elements. With constant time complexity for most operations, dictionaries are a powerful tool for organizing and managing data in Swift programming.\nLet us explore syntax, usage, and various operations that can be performed on dictionay.\nCreating a Dictionary: In Swift, dictionaries are represented by the Dictionary\u0026lt;Key, Value\u0026gt; type, or simply [Key: Value]. Time complexity for creating an empty dictionary is O(1). Here\u0026rsquo;s how you can create an empty dictionary or initialize it with values:\n// Empty Dictionary var emptyDictionary: [String: Int] = [:] // Initializing a Dictionary var fruits = [\u0026#34;apple\u0026#34;: 3, \u0026#34;banana\u0026#34;: 5, \u0026#34;orange\u0026#34;: 2] Accessing and Modifying Values: You can access values in a dictionary using their corresponding keys. If the key exists, the value will be returned; otherwise, it will return nil. Time complexity for accessing and modifying values in an dictionary is O(1). Here\u0026rsquo;s an example:\nlet numberOfApples = fruits[\u0026#34;apple\u0026#34;] // returns 3 // Modifying values fruits[\u0026#34;banana\u0026#34;] = 10 Adding and Removing Elements: To add elements to a dictionary, you can assign a value to a specific key. If the key already exists, the value will be updated; otherwise, a new key-value pair will be added. Removing elements can be done using the removeValue(forKey:) method. Time complexity of adding and removing element in dictionary is O(1). However, in some cases, the complexity can be O(n) due to the need to resize the underlying hash table. Examples:\nfruits[\u0026#34;kiwi\u0026#34;] = 4 // Adding a new element fruits.removeValue(forKey: \u0026#34;orange\u0026#34;) // Removing an element Iterating over a Dictionary: Swift provides several ways to iterate over the elements in a dictionary. You can use a for-in loop to access each key-value pair, or you can iterate over keys or values separately using the keys and values properties. Iterating over a dictionary has a time complexity of O(n), where n is the number of key-value pairs in the dictionary. This is because iterating requires visiting each element once. Here\u0026rsquo;s an example:\nfor (fruit, quantity) in fruits { print(\u0026#34;There are \\(quantity) \\(fruit)s\u0026#34;) } for fruit in fruits.keys { print(fruit) } for quantity in fruits.values { print(quantity) } Checking for the Existence of Keys and Values: To check if a key or value exists in a dictionary, you can use the contains(where:) method or the keys.contains(:) and values.contains(:) properties. Checking for the existence of keys or values in a dictionary has an average time complexity of O(1). This is due to the efficient lookup mechanism provided by the hash table implementation. Here\u0026rsquo;s an example:\nif fruits.contains(where: { $0.key == \u0026#34;apple\u0026#34; }) { print(\u0026#34;Apple exists\u0026#34;) } if fruits.values.contains(5) { print(\u0026#34;There is a fruit with quantity 5\u0026#34;) } Dictionary Operations and Properties: Swift dictionaries provide various operations and properties to work with. Some notable ones include:\ncount: Returns the number of key-value pairs in the dictionary. isEmpty: Returns a Boolean value indicating whether the dictionary is empty. keys: Returns a collection containing all the keys in the dictionary. values: Returns a collection containing all the values in the dictionary. merge(_:uniquingKeysWith:): Merges the given dictionary with the current dictionary. filter(_:): Returns a new dictionary containing the key-value pairs that satisfy the given predicate. Conclusion: Dictionaries are powerful data structures that allow you to store and retrieve values using a key-value pair mechanism. In Swift, dictionaries are easy to use and provide various operations for manipulating and accessing data efficiently. By understanding the concepts and techniques covered in this blog post, you are now equipped to work with dictionaries effectively in Swift. Happy coding! 🚀\n","tags":["Swift"],"title":"Dictionary: Swift"},{"categories":["Blog"],"date":"March 5, 2023","permalink":"https://mahigarg.github.io/blogs/protocols-in-swift/","section":"blogs","summary":"In Swift, protocols are a powerful tool that empowers developers to create flexible, reusable, and scalable code. They play a pivotal role in achieving abstraction and enabling polymorphism, essential principles of object-oriented programming (OOP). In this blog, we\u0026rsquo;ll dive into the world of protocols in Swift, explore their features, benefits, and demonstrate how they can be used to design robust and adaptable code with practical examples.\nx\nWhat are Protocols? Protocols in Swift are similar to interfaces in other programming languages. They define a blueprint of methods, properties, and other requirements that a class or struct must adopt. A class or struct that conforms to a protocol promises to provide the implementation for all the requirements defined in that protocol.\nDeclaring Protocols Let\u0026rsquo;s start by creating a simple protocol that defines the requirements for an object that can make a sound:\nprotocol SoundMaker { func makeSound() } In this example, we\u0026rsquo;ve declared a protocol called SoundMaker with a single requirement: the makeSound() method.\nAdopting Protocols Now, let\u0026rsquo;s create two classes that adopt the SoundMaker protocol:\nclass Dog: SoundMaker { func makeSound() { print(\u0026#34;Woof woof!\u0026#34;) } } class Cat: SoundMaker { func makeSound() { print(\u0026#34;Meow!\u0026#34;) } } Both the Dog and Cat classes implement the makeSound() method as required by the SoundMaker protocol.\nUsing Protocols Now that we have our classes conforming to the SoundMaker protocol, we can use the protocol type to create a collection of different sound-making objects:\nlet dog = Dog() let cat = Cat() let soundMakers: [SoundMaker] = [dog, cat] for soundMaker in soundMakers { soundMaker.makeSound() } The output will be:\nWoof woof! Meow! Protocol Properties Protocols can also require properties to be implemented. Let\u0026rsquo;s modify our SoundMaker protocol to include a name property:\nprotocol SoundMaker { var name: String { get } func makeSound() } Now, the classes that adopt the SoundMaker protocol must provide an implementation for the name property:\nclass Dog: SoundMaker { let name: String init(name: String) { self.name = name } func makeSound() { print(\u0026#34;Woof woof!\u0026#34;) } } class Cat: SoundMaker { let name: String init(name: String) { self.name = name } func makeSound() { print(\u0026#34;Meow!\u0026#34;) } } Optional Protocol Requirements In Swift, protocols can also have optional requirements. This means that conforming classes or structs may or may not implement those requirements. To define an optional requirement in a protocol, you use the @objc attribute and mark the requirement with the optional keyword:\n@objc protocol OptionalSoundMaker { @objc optional func optionalSound() } Classes or structs that conform to this protocol can choose to implement the optionalSound() method or not. Note that protocols with optional requirements must be marked with @objc.\nConclusion Protocols are a crucial feature in Swift for designing flexible and reusable code. By defining requirements that classes or structs must adopt, protocols enable polymorphism, allowing different types to be treated as instances of the same protocol. This, in turn, fosters code adaptability, scalability, and enhances code organization.\nIn this blog, we\u0026rsquo;ve explored the basics of protocols in Swift and demonstrated how they can be used to create powerful abstractions and foster polymorphic behavior. Whether you\u0026rsquo;re building iOS apps, macOS applications, or any other Swift-based projects, protocols will undoubtedly play a significant role in designing elegant and maintainable solutions.\nBy embracing protocols and incorporating them into your Swift code, you can write code that is not only robust but also adaptable to future changes. So, the next time you find yourself creating a set of requirements for objects to adhere to, consider using Swift protocols to unlock the true potential of your code! Happy coding! 🚀\n","tags":["Swift"],"title":"Protocols in Swift"},{"categories":["Blog"],"date":"February 26, 2023","permalink":"https://mahigarg.github.io/blogs/extensions-in-swift/","section":"blogs","summary":"Extensions in Swift allow developers to add new functionality to existing classes and protocols without modifying their original implementation. For classes, extensions can include new methods, computed properties, and initializers, promoting code modularity. For protocols, extensions can provide default implementations for methods, enhancing code adaptability. By separating concerns through extensions, developers can achieve cleaner, more organized code, increasing code reusability and maintainability in Swift projects.\nExtending Classes in Swift Swift enables developers to extend classes with new methods, computed properties, and initializers, providing a modular way to add functionality. Let\u0026rsquo;s consider a simple example of extending a Person class:\nclass Person { var name: String init(name: String) { self.name = name } } extension Person { func sayHello() { print(\u0026#34;Hello, my name is \\(name)!\u0026#34;) } } // Usage let person = Person(name: \u0026#34;Mahi\u0026#34;) person.sayHello() // Output: \u0026#34;Hello, my name is Mahi!\u0026#34; By using extensions, we separate the core functionality of the Person class from additional features like sayHello(), enhancing code organization and maintainability.\nExtending Protocols in Swift Extending protocols in Swift allows us to provide default implementations for protocol methods. This feature is particularly useful when adding new methods to existing protocols without breaking the code for existing implementations. Let\u0026rsquo;s illustrate this with a protocol extension for an Animal protocol:\nprotocol Animal { var name: String { get } func makeSound() } extension Animal { func makeSound() { print(\u0026#34;Unknown sound\u0026#34;) } } // Conforming to the protocol struct Dog: Animal { var name: String } struct Cat: Animal { var name: String func makeSound() { print(\u0026#34;Meow!\u0026#34;) } } // Usage let dog = Dog(name: \u0026#34;Buddy\u0026#34;) let cat = Cat(name: \u0026#34;Whiskers\u0026#34;) dog.makeSound() // Output: \u0026#34;Unknown sound\u0026#34; (using default implementation) cat.makeSound() // Output: \u0026#34;Meow!\u0026#34; Code Modularity and Reusability with Extensions Extensions significantly enhance code modularity and reusability by enabling developers to add functionalities to classes and protocols across different files and modules. This segregation of responsibilities ensures a clearer and more organized codebase. Consider the following example:\n// File: MathExtensions.swift extension Int { func squared() -\u0026gt; Int { return self * self } } // File: StringExtensions.swift extension String { func capitalizeFirstLetter() -\u0026gt; String { return prefix(1).capitalized + dropFirst() } } In this example, we have two separate extensions, one for Int and the other for String, each residing in its respective file. These extensions can be added to a project without modifying the original implementations of Int and String, providing code reusability and maintainability.\nConclusion Extensions in Swift are a powerful tool for extending classes and protocols without modifying their original code. By adding new methods, properties, and initializers to classes and providing default implementations for protocol methods, extensions promote code modularity and reusability. Leveraging extensions effectively can significantly improve the development process and maintainability of Swift projects, making it an essential feature for Swift developers to embrace.\n","tags":["Swift"],"title":"Extensions in Swift"},{"categories":["Blog"],"date":"February 22, 2023","permalink":"https://mahigarg.github.io/blogs/generics-in-swift/","section":"blogs","summary":"Generics allow us to write functions, structures, and classes that can work with different types while maintaining type safety. Rather than specifying concrete types, we use placeholders (type parameters) that get substituted with actual types when the code is used. This flexibility makes generics a valuable tool for writing versatile and adaptable code.\nGeneric Functions in Swift Let\u0026rsquo;s begin with a basic example of a generic function that swaps two values of any type:\nfunc swapValues\u0026lt;T\u0026gt;(_ a: inout T, _ b: inout T) { let temp = a a = b b = temp } // Usage var num1 = 5 var num2 = 10 swapValues(\u0026amp;num1, \u0026amp;num2) print(\u0026#34;num1: \\(num1), num2: \\(num2)\u0026#34;) // Output: \u0026#34;num1: 10, num2: 5\u0026#34; var str1 = \u0026#34;Hello\u0026#34; var str2 = \u0026#34;World\u0026#34; swapValues(\u0026amp;str1, \u0026amp;str2) print(\u0026#34;str1: \\(str1), str2: \\(str2)\u0026#34;) // Output: \u0026#34;str1: World, str2: Hello\u0026#34; The swapValues function uses a generic type parameter T in angle brackets (\u0026lt;T\u0026gt;) and performs a value swap on two arguments of the same type.\nGeneric Structures and Classes Generics are not limited to functions; we can also create generic structures and classes. Let\u0026rsquo;s see an example of a generic Stack data structure:\nstruct Stack\u0026lt;Element\u0026gt; { private var elements: [Element] = [] mutating func push(_ element: Element) { elements.append(element) } mutating func pop() -\u0026gt; Element? { return elements.popLast() } } // Usage var intStack = Stack\u0026lt;Int\u0026gt;() intStack.push(1) intStack.push(2) intStack.push(3) print(intStack.pop()) // Output: Optional(3) var stringStack = Stack\u0026lt;String\u0026gt;() stringStack.push(\u0026#34;Swift\u0026#34;) stringStack.push(\u0026#34;is\u0026#34;) stringStack.push(\u0026#34;awesome!\u0026#34;) print(stringStack.pop()) // Output: Optional(\u0026#34;awesome!\u0026#34;) In this example, we define a generic Stack structure that can hold elements of any type. We use the type parameter Element to represent the placeholder type.\nConstraints on Generics Swift allows us to impose constraints on generic types to restrict them to specific requirements. For instance, we can add constraints to ensure that the generic type conforms to a protocol or inherits from a particular class.\nfunc printDetails\u0026lt;T: CustomStringConvertible\u0026gt;(_ item: T) { print(item.description) } // Usage let number = 42 printDetails(number) // Output: \u0026#34;42\u0026#34; let names = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;] printDetails(names) // Output: \u0026#34;[\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;]\u0026#34; In this example, the printDetails function takes a generic parameter T, constrained to types conforming to the CustomStringConvertible protocol. This constraint guarantees that we can safely access the description property of the input.\nConclusion Generics in Swift are a powerful and essential tool for creating flexible and reusable code. By using type placeholders, we can write functions, structures, and classes that work with multiple types while maintaining type safety. Embracing generics allows developers to create adaptable, efficient, and maintainable code, making Swift an even more robust and developer-friendly language.\n","tags":["Swift"],"title":"Generics in Swift"},{"categories":["Blog"],"date":"February 20, 2023","permalink":"https://mahigarg.github.io/blogs/variable-types-in-swift/","section":"blogs","summary":"Swift is a powerful and versatile programming language that allows developers to create robust and efficient applications across various platforms. One of the fundamental aspects of Swift is its strong type system, which ensures safety and reliability in code. In this blog, we will dive into the world of variable types in Swift, exploring the various categories and providing examples to enhance your understanding.\n1. Integers Integers are whole numbers with no fractional components. In Swift, there are different types of integers based on their size:\nExamples: a. Int The Int type is the most commonly used integer type in Swift, and its size depends on the platform. On a 64-bit platform, Int is a 64-bit integer, while on a 32-bit platform, it\u0026rsquo;s a 32-bit integer.\nvar age: Int = 25 b. UInt The UInt type represents an unsigned integer, meaning it can only hold non-negative values.\nvar numberOfParticipants: UInt = 100 c. Fixed-size Integers Swift also provides fixed-size integer types like Int8, Int16, Int32, and Int64, which have a specific number of bits they can store.\nvar smallNumber: Int8 = 10 2. Floating-Point Numbers Floating-point numbers represent numbers with fractional components. Swift offers two main types for floating-point numbers:\nExamples: a. Double The Double type is a 64-bit floating-point number and provides a high level of precision.\nvar pi: Double = 3.14159265359 b. Float The Float type is a 32-bit floating-point number with less precision compared to Double.\nvar temperature: Float = 25.5 3. Booleans Booleans represent logical values, indicating either true or false. Swift uses the Bool type for Boolean variables.\nExamples: var isRaining: Bool = true var isLoggedIn: Bool = false 4. Strings Strings represent a sequence of characters and are one of the most commonly used types in any programming language. In Swift, strings are represented using the String type.\nExamples: var greeting: String = \u0026#34;Hello, World!\u0026#34; var username: String = \u0026#34;JohnDoe\u0026#34; 5. Arrays Arrays are collections of values that are stored in a specific order. In Swift, arrays are typed, meaning they can only hold elements of the same type.\nExamples: var numbers: [Int] = [1, 2, 3, 4, 5] var fruits: [String] = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;] 6. Dictionaries Dictionaries are collections of key-value pairs, where each key is unique. The keys and values in a dictionary can have different types.\nExamples: var scores: [String: Int] = [\u0026#34;John\u0026#34;: 85, \u0026#34;Jane\u0026#34;: 92, \u0026#34;Mike\u0026#34;: 78] var ages: [String: Int] = [\u0026#34;Alice\u0026#34;: 30, \u0026#34;Bob\u0026#34;: 25, \u0026#34;Eve\u0026#34;: 27] 7. Sets Sets are unordered collections of unique elements. They ensure that each element appears only once in the collection.\nExamples: var uniqueNumbers: Set\u0026lt;Int\u0026gt; = [1, 2, 3, 4, 5] var uniqueCharacters: Set\u0026lt;Character\u0026gt; = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] 8. Tuples Tuples allow you to group multiple values together as a single compound value. They are useful for returning multiple values from a function.\nExamples: var employee: (name: String, age: Int, department: String) = (\u0026#34;John Doe\u0026#34;, 35, \u0026#34;Engineering\u0026#34;) var coordinates: (Double, Double) = (40.7128, -74.0060) 9. Optionals Optionals are a unique feature in Swift that allows variables to have a value or be nil, indicating the absence of a value.\nExamples: var phoneNumber: Int? = 1234567890 var middleName: String? = nil Conclusion Understanding variable types in Swift is essential for writing reliable and safe code. Swift\u0026rsquo;s strong type system helps catch errors during development and enhances code readability. By using the appropriate variable types, you can build efficient and robust applications that cater to a wide range of use cases.\nKeep practicing and exploring the different variable types in Swift, and you\u0026rsquo;ll become a proficient Swift developer in no time! Happy coding! 🚀\n","tags":["Swift"],"title":"Variable Types in Swift"},{"categories":["Blog"],"date":"February 17, 2023","permalink":"https://mahigarg.github.io/blogs/let-vs-var-mutability-in-swift/","section":"blogs","summary":"Swift is a powerful and modern programming language that allows developers to build robust and efficient applications for various platforms. One of the key features of Swift is its support for both immutable constants and mutable variables through the use of let and var declarations, respectively. In this blog, we will explore the differences between let and var, along with examples to illustrate their usage and significance in Swift programming.\n1. let - Immutable Constants In Swift, the let keyword is used to declare constants. Constants are variables whose values cannot be changed after they are assigned. Once you assign a value to a constant, it remains fixed throughout its lifetime.\nExample: let pi: Double = 3.14159 let name: String = \u0026#34;John Doe\u0026#34; In the above example, we declare two constants: pi, which holds the value of Pi, and name, which stores a person\u0026rsquo;s name. Once assigned, the values of these constants cannot be modified.\n2. var - Mutable Variables On the other hand, the var keyword is used to declare variables that can have their values changed or reassigned after initialization. Variables declared with var are mutable.\nExample: var counter: Int = 0 var temperature: Float = 25.5 In the above example, we declare two variables: counter, which starts with an initial value of 0, and temperature, which holds the current temperature. We can change the values of these variables throughout the program as needed.\n3. Advantages of let and var Advantages of let (Immutable Constants): Safety: Constants ensure that the value assigned to them remains unchanged, reducing the risk of unintended side effects in your code. Clarity: Declaring a value as a constant with let clearly indicates to other developers that the value is not meant to change. Advantages of var (Mutable Variables): Flexibility: Variables declared with var allow you to modify their values, making them suitable for situations where the value needs to be updated during program execution. State management: Variables are useful for keeping track of changing states and dynamic data in your application. 4. Choosing between let and var When choosing between let and var, consider the following guidelines:\nUse let when: You have a value that should not change after its initial assignment. You want to enforce immutability for certain data to ensure data integrity and consistency. Use var when: You need a value that can change or be updated during program execution. You want a variable to hold state or dynamic data. 5. Examples of let and var in Different Scenarios Example 1 - let (Immutable Constant): let numberOfDaysInAWeek: Int = 7 let websiteURL: String = \u0026#34;https://www.example.com\u0026#34; // numberOfDaysInAWeek = 8 // Error: Cannot reassign a value to a constant // websiteURL = \u0026#34;https://www.newurl.com\u0026#34; // Error: Cannot reassign a value to a constant Example 2 - var (Mutable Variable): var score: Int = 0 var playerName: String = \u0026#34;John Doe\u0026#34; score = 100 // Updating the score playerName = \u0026#34;Jane Smith\u0026#34; // Changing the player\u0026#39;s name Conclusion Understanding the difference between let and var in Swift is crucial for writing clean, efficient, and reliable code. By using let, you can create immutable constants that guarantee the value remains fixed throughout its lifetime, enhancing code safety and clarity. On the other hand, var allows you to declare mutable variables, providing the flexibility to modify values as needed during program execution.\nBy following best practices and choosing the appropriate type (let or var) for your variables, you can write code that is easy to understand, maintain, and scale in your Swift projects. Happy coding! 🚀\n","tags":["Swift"],"title":"let vs var: Mutability in Swift"},{"categories":["Blog"],"date":"February 13, 2023","permalink":"https://mahigarg.github.io/blogs/optional-type-in-swift/","section":"blogs","summary":"Swift is a robust and modern programming language that prioritizes safety and reliability. One of the key features that contribute to Swift\u0026rsquo;s safety is its handling of optional types. Optional types allow developers to indicate the possible absence of a value, which helps prevent runtime crashes due to unexpected nil values. In this blog, we will explore the concept of optional types in Swift, along with examples to demonstrate how they can be effectively utilized in your code.\nUnderstanding Optionals In Swift, an optional is a type that can hold either a value or nil, indicating the absence of a value. Optionals are denoted by appending a question mark ? after the type of the value they can contain.\nExample: var phoneNumber: Int? = 1234567890 var middleName: String? = nil In the example above, we declare two optional variables: phoneNumber of type Int? and middleName of type String?. phoneNumber holds a valid integer value, while middleName is explicitly set to nil to indicate the absence of a middle name.\nHandling Optionals Safely Optional Binding Optional binding is a safe way to unwrap optional values and use them if they are not nil. It is achieved through the if let or guard let constructs.\nExample using if let: func printMiddleName(_ middleName: String?) { if let name = middleName { print(\u0026#34;Middle name: \\(name)\u0026#34;) } else { print(\u0026#34;No middle name.\u0026#34;) } } let fullName: String? = \u0026#34;John Smith\u0026#34; let nameComponents = fullName?.components(separatedBy: \u0026#34; \u0026#34;) if let middleName = nameComponents?[1] { printMiddleName(middleName) } else { print(\u0026#34;No middle name found.\u0026#34;) } In the above example, we use optional binding with if let to safely unwrap the middle name and print it if it exists. If the middle name is nil, we print a message indicating its absence.\nNil Coalescing Operator The nil coalescing operator (??) provides a concise way to handle optionals and provide a default value if the optional is nil.\nExample: let username: String? = nil let defaultUsername: String = \u0026#34;Guest\u0026#34; let greeting = \u0026#34;Hello, \\(username ?? defaultUsername)!\u0026#34; print(greeting) In the example above, we use the nil coalescing operator to provide a default username Guest in case the username is nil. This ensures that the greeting string is always well-formed.\nOptional Chaining Optional chaining is a powerful feature that allows you to call properties, methods, and subscripts on an optional that might be nil.\nExample:\nstruct Address { var street: String var city: String var zipCode: String } struct Person { var name: String var address: Address? } let john = Person(name: \u0026#34;John Doe\u0026#34;, address: Address(street: \u0026#34;123 Main St\u0026#34;, city: \u0026#34;New York\u0026#34;, zipCode: \u0026#34;10001\u0026#34;)) let johnsCity = john.address?.city ?? \u0026#34;Unknown City\u0026#34; print(\u0026#34;John lives in \\(johnsCity).\u0026#34;) In the example above, we use optional chaining to access the city property of the optional address. If the address is nil, the result of the optional chaining expression is also nil, and the nil coalescing operator provides a default value \u0026ldquo;Unknown City\u0026rdquo;.\nConclusion Understanding optional types in Swift is crucial for writing safe and robust code. By embracing optionals, you can effectively handle scenarios where values might be missing, avoiding runtime crashes and improving the overall stability of your applications.\nWith optional binding, nil coalescing, and optional chaining, Swift provides a comprehensive set of tools to handle optionals safely and efficiently. Mastering these concepts will empower you to write code that gracefully handles the absence of values and ensures a smooth user experience in your Swift projects. Happy coding! 🚀\n","tags":["Swift"],"title":"Optional Type in Swift"},{"categories":["Blog"],"date":"January 31, 2023","permalink":"https://mahigarg.github.io/blogs/do-while-repeat-while-loop-in-swift/","section":"blogs","summary":"Swift is a powerful and expressive programming language that offers a variety of loop structures to handle repetitive tasks efficiently. Among these, the do-while loop stands out as a loop that ensures the code inside the loop executes at least once, regardless of the loop\u0026rsquo;s condition. In this blog, we will explore the do-while loop in Swift, its syntax, and examples to showcase its usefulness in different scenarios.\nIntroducing the do-while Loop The do-while loop, also known as the repeat-while loop, is a control flow statement that iterates over a block of code while a specified condition remains true. The unique feature of the do-while loop is that it guarantees the code inside the loop is executed at least once, even if the condition evaluates to false from the beginning.\nSyntax of the do-while Loop The basic syntax of the do-while loop in Swift is as follows:\ndo { // Code to be executed at least once } while condition The condition is a Boolean expression that determines whether the loop should continue iterating or terminate. The block of code inside the do section is executed first, and then the condition is checked. If the condition evaluates to true, the loop repeats; otherwise, the loop terminates.\nExamples of do-while Loop Example 1 - Rolling a Dice: import Foundation var diceValue: Int repeat { diceValue = Int.random(in: 1...6) print(\u0026#34;You rolled a \\(diceValue)\u0026#34;) } while diceValue != 6 In this example, the do-while loop simulates rolling a dice. The loop continues to roll the dice and print the result until the dice rolls a value of 6. Since the condition is checked after the loop body, the loop always rolls the dice at least once, guaranteeing that the player gets a result.\nExample 2 - Reading User Input: var input: String repeat { print(\u0026#34;Please enter a positive number:\u0026#34;) input = readLine() ?? \u0026#34;\u0026#34; } while Double(input) == nil || Double(input)! \u0026lt;= 0 let number = Double(input)! print(\u0026#34;The square root of \\(number) is \\(sqrt(number))\u0026#34;) In this example, the do-while loop prompts the user to enter a positive number repeatedly until a valid positive number is provided. The loop checks whether the input can be converted to a valid positive number (not nil and greater than 0) before proceeding with the computation and printing the square root.\nLoop Control and Infinite do-while Loops As with any loop structure, you must exercise caution to avoid creating infinite loops that never terminate. An infinite do-while loop can be created by using a condition that always evaluates to true. For example:\n// Infinite Loop repeat { // Code that keeps executing indefinitely } while true To prevent infinite loops, ensure that the loop condition eventually evaluates to false based on the progression of your loop.\nConclusion The do-while loop in Swift is a powerful and flexible tool that allows you to handle repetitive tasks, ensuring that the loop body executes at least once, regardless of the loop\u0026rsquo;s condition. With the examples provided in this blog, you can now apply the do-while loop effectively in various scenarios, such as input validation, randomization, and more.\nAlways use loop control statements like break and continue judiciously to manage the flow of your loops, and avoid creating infinite loops that may cause your program to hang or crash. Embrace the power of the do-while loop in Swift and elevate your programming skills to new heights. Happy coding! 🚀\n","tags":["Swift"],"title":"Do While (Repeat While) Loop in Swift"},{"categories":["Blog"],"date":"January 26, 2023","permalink":"https://mahigarg.github.io/blogs/while-loop-in-swift/","section":"blogs","summary":"In any programming language, loops are essential for performing repetitive tasks efficiently. Swift offers a variety of loop structures, and one of the most versatile ones is the while loop. In this blog, we will explore the while loop in Swift, its syntax, and various examples to demonstrate how it can be utilized to achieve repetitive operations effectively.\nUnderstanding the while Loop The while loop is a control flow statement that allows you to execute a block of code repeatedly as long as a specified condition remains true. The loop continues to execute until the condition evaluates to false.\nSyntax of the while Loop The basic syntax of the while loop in Swift is as follows:\nwhile condition { // Code to be executed while the condition is true } The condition is a Boolean expression that determines whether the loop\u0026rsquo;s body should be executed. If the condition evaluates to true, the loop\u0026rsquo;s body is executed, and the process repeats until the condition becomes false.\nExamples of while Loop Example 1 - Printing Numbers: var number = 1 while number \u0026lt;= 5 { print(number) number += 1 } In the above example, the while loop prints the numbers from 1 to 5. The loop starts with number set to 1, and in each iteration, it prints the value of number and increments it by 1. The loop continues executing until number becomes 6, which is when the while condition becomes false, and the loop terminates.\nExample 2 - Fibonacci Series: func fibonacciSeries(_ n: Int) { var a = 0, b = 1, c = 0 while c \u0026lt; n { print(a) c = a + b a = b b = c } } fibonacciSeries(20) In this example, the while loop generates the Fibonacci series up to the value of n. The loop starts with a and b initialized to 0 and 1, respectively. In each iteration, the loop calculates the next Fibonacci number by summing up a and b, updates a and b, and prints the current Fibonacci number. The loop continues until c (the next Fibonacci number) becomes greater than or equal to n.\nInfinite Loops and Loop Control Statements It is essential to be cautious while using while loops to avoid creating infinite loops. An infinite loop is a loop that never terminates because its condition always evaluates to true. For example:\n// Infinite Loop - DO NOT USE while true { // Code that keeps executing indefinitely } To break out of a loop prematurely, you can use the break statement. To skip the current iteration and continue with the next one, you can use the continue statement.\nConclusion The while loop in Swift is a powerful construct that allows you to perform repetitive tasks efficiently. By defining a condition that evaluates to true while the loop should continue, you can ensure that the loop executes the necessary code until the condition becomes false.\nWith the examples provided in this blog, you can now apply the while loop in Swift to various scenarios and achieve efficient repetition in your programs. Always exercise caution with infinite loops and utilize loop control statements (break and continue) when needed to control the flow of your loops effectively. Happy coding! 🚀\n","tags":["Swift"],"title":"While Loop in Swift"},{"categories":["Blog"],"date":"January 15, 2023","permalink":"https://mahigarg.github.io/blogs/state-swiftui/","section":"blogs","summary":"In SwiftUI, a powerful framework for building user interfaces, managing and updating the state of our views is essential for creating dynamic and interactive user experiences. One key tool SwiftUI provides for this purpose is the @State property wrapper.\nNow let us understand what is @State, how it works, what we can achieve through this, and much more.\nWhat is @State? The @State property wrapper is a fundamental component of SwiftUI that allows us to declare mutable state properties within a view. When the value of @State property changes, SwiftUI automatically re-renders the view, ensuring that the UI stays synchronized with the underlying state.\nLet us understand this with an example.\nConsider you want to change the background color of your view with a few button clicks. please have a look at the below code where we will understand its declaration and usage part as well.\nstruct stateBootCamp: View { @State var backgroundColor = Color.red var body: some View { ZStack { backgroundColor VStack(spacing: 20) { Text(\u0026#34;Studing @State\u0026#34;) .font(.title) Button(\u0026#34;BUTTON Green\u0026#34;) { backgroundColor = .green } Button(\u0026#34;BUTTON Pink\u0026#34;) { backgroundColor = .pink } } .foregroundColor(.white) } } } To declare, prefix @State to property declaration. Above we made backgroundColor a state property.\nNow let us understand it\u0026rsquo;s working.\nThe first view is your Initial View in zero state. When you tap on BUTTON Green, the background color changes to green as we are changing the state variable color to Green as the action of Button. Similarly, on Tap of BUTTON Pink, the background color changes to Pink. With this, we understood how @State is used.\nUsage scenario of @State @State is best suited for managing a state within a single view or a small portion of the view hierarchy. It works well for a local, transient state that doesn\u0026rsquo;t need to be shared across multiple views or persisted across sessions.\nLimitation of @State @State not suitable for managing states across multiple views or when sharing states between different parts of an application. In such cases, @ObservedObject or @EnvironmentObject maybe more appropriate choices. By leveraging @State, SwiftUI empowers developers to build modern, responsive applications that are efficient, maintainable, and delightful to use.\n","tags":["SwiftUI"],"title":"@State: SwiftUI"},{"categories":["Blog"],"date":"August 22, 2022","permalink":"https://mahigarg.github.io/blogs/for-loop-with-where-clause-swift/","section":"blogs","summary":"For loop is an inevitable part of any programming language. It iterates over every element of the collection type data including array, set, and dictionary, and does the operation as per the code.\nLet us see an example of the same. Consider an array of integers and a for loop accessing its even integers.\n//array example let numbers = [23,62,6,12,87,55,45,22] //for loop for number in numbers { print(number) } Above swift code will print all integers in the array. But sometimes we need only elements on certain conditions like even number, or positive number. This can be achieved by giving a where clause with the for loop body.\nLet us see the code for filtering even numbers.\n//for loop with where for number in numbers where number % 2 == 0 { print(number) } // print 62 6 12 22 Here data is filtered according to where clause i.e., only even numbers will be printed. Similarly, we can filter data on more than one condition using (||) or and (\u0026amp;\u0026amp;) depending on the use case.\nLet us look at this with an example.\n//for loop with where for number in numbers where number % 2 == 0 || number \u0026gt; 50 { print(number) } // 62 6 12 87 55 22 Here data is filtered according to where clause i.e., even numbers or numbers greater than 50 will be printed.\nNow let us consider case printing numbers that are even and greater than 50.\n//for loop with where for number in numbers where number % 2 == 0 \u0026amp;\u0026amp; number \u0026gt; 50 { print(number) } // prints even numbers and number greater than 50 // 62 Here data is filtered according to where clause i.e. even numbers and numbers greater than 50 will be printed.\n","tags":["Swift"],"title":"For loop with where clause: Swift"},{"categories":["Blog"],"date":"August 16, 2022","permalink":"https://mahigarg.github.io/blogs/round-up-to-n-decimal-digit-swift/","section":"blogs","summary":"We sometimes in our calculation get results with more than 4 decimal digits or even more. But as a developer, we can’t use the same to display to users.\nImagine we have a dashboard application that displays monthly tax on an employee\u0026rsquo;s salary. And it is coming as 630.6152. This doesn’t look good at all to say the same. It will be better to show it like 630.62 or 630.61 i.e., rounding it to n Decimal Digit.\nLet us take a look at how this can be done.\nIf we say round up to n Decimal Digits where n equals 2. Then we need to follow the below steps\nMultiply it by 100 (10^n) Use round, floor, or ceil to remove the extra digits Divide by 100 (10^n) Round to n digits using the round function //after calculation tax = 630.6152 //multiply with 100 var result = tax * 100 //63061.52 //Using round to remove extra digit roundresult = round(result) //63062 //divide by 100 result = result/ 100 print (result) //630.62 print(evenNumbers) Here tax 630.6152 is rounded to 630.62 as the third decimal digit is 5.\nLet us consider example 437.1932. Here 3 is the third decimal digit.\n//after calculation tax = 437.1932 //multiply with 100 var result = tax * 100 //43719.32 //Using round to remove extra digit roundresult = round(result) //43719 //divide by 100 result = result/ 100 print (result) //437.19 On comparing the result of both the example, we can see the result depends on the decimal digits we have. If the third digit is between 1 to 4, then it will keep the existing previous results (437.1932 -\u0026gt; 437.19) but in the case of digits between 5–9, it increases the last digit (630.6152 -\u0026gt; 630.61).\nNow let us see how our output will be impacted if we use the floor or ceil function instead of round.\nRound to n digits using the floor function Considering the same example here. Tax after calculation equals 630.6152.\n//after calculation tax = 630.6152 //multiply with 100 var result = tax * 100 //63061.52 //Using floor to remove extra digit floorResult = floor(result) //63061 //divide by 100 floorResult = floorResult / 100 print (floorResult) //630.61 Here, we saw floor will step down the result irrespective of the digit we have at the third position, be it 1 or 9 it will always take you to the nearest smallest number.\nRound to n digits using the ceil function Here, let us alter our example to 630.6122 and see how our results vary.\n//after calculation tax = 630.6122 //multiply with 100 var result = tax * 100 //63061.22 //Using ceil to remove extra digit ceilResult = ceil(result) //63062 //divide by 100 ceilResult = ceilResult / 100 print (ceilResult) //630.62 Here, we saw ceil will step up the result irrespective of the digit we have at the third position, be it anything between 1 to 9 it will always take you to the nearest largest number.\n","tags":["Swift"],"title":"Round up to n Decimal Digit: Swift"},{"categories":["Blog"],"date":"July 20, 2022","permalink":"https://mahigarg.github.io/blogs/set-swift/","section":"blogs","summary":"A set is an unordered collection of unique elements, meaning it does not allow duplicates. Swift\u0026rsquo;s Set data type ensures that each element occurs only once in the collection. You can think of sets as a mathematical set, where the order of elements does not matter, and there are no duplicate elements. Swift\u0026rsquo;s Set data type uses hash tables internally to store elements, which allows for fast access and modification. This is the reason time complexity for set operation is much better than array.\nLet us explore syntax, usage, time complexity and various operations that can be performed on sets.\nCreating a Set: In Swift, In Swift, you can create a set using the Set keyword, specifying the type of elements the set will hold. Here\u0026rsquo;s an example of creating a set of integers:\nvar integerSet: Set\u0026lt;Int\u0026gt; = [1, 2, 3, 4, 5] Alternatively, you can use type inference to let Swift deduce the type of the set:\nvar anotherSet = Set\u0026lt;String\u0026gt;() anotherSet.insert(\u0026#34;apple\u0026#34;) anotherSet.insert(\u0026#34;banana\u0026#34;) anotherSet.insert(\u0026#34;orange\u0026#34;) Insertion and Deletion To add elements to a set, you can use the insert(_:) method. Insertion and deletion in sets have an average-case time complexity of O(1). Examples:\nvar mySet = Set\u0026lt;Character\u0026gt;() mySet.insert(\u0026#34;a\u0026#34;) mySet.insert(\u0026#34;b\u0026#34;) Membership Test To check if an element exists in a set, you can use the contains(_:) method: Examples:\nif mySet.contains(\u0026#34;a\u0026#34;) { print(\u0026#34;The set contains \u0026#39;a\u0026#39;.\u0026#34;) } else { print(\u0026#34;The set does not contain \u0026#39;a\u0026#39;.\u0026#34;) } Set Operations (Union, Intersection, Difference, Subset) Sets also support various set operations such as union, intersection, difference, and subset checks. Union, intersection, and difference operations have an average-case time complexity of O(m), where m is the number of elements in the smaller set. Swift uses an efficient algorithm to compute these operations, leveraging the benefits of hash tables. The isSubset(of:) method also has an average-case time complexity of O(m), where m is the number of elements in the subset being checked. Here\u0026rsquo;s an example:\nlet set1: Set\u0026lt;Int\u0026gt; = [1, 2, 3, 4] let set2: Set\u0026lt;Int\u0026gt; = [3, 4, 5, 6] let unionSet = set1.union(set2) // {1, 2, 3, 4, 5, 6} let intersectionSet = set1.intersection(set2) // {3, 4} let differenceSet = set1.subtracting(set2) // {1, 2} let isSubset = set1.isSubset(of: set2) // false Conclusion: In conclusion, sets are a powerful data structure for managing collections of unique elements. Swift\u0026rsquo;s Set data type provides efficient insertion, deletion, and membership test operations with an average-case time complexity of O(1). Additionally, set operations like union, intersection, and difference, as well as subset checks, have an average-case time complexity of O(m), where m is the number of elements in the smaller set involved in the operation. Happy coding! 🚀\n","tags":["Swift"],"title":"Set: Swift"},{"categories":["Blog"],"date":"June 19, 2022","permalink":"https://mahigarg.github.io/blogs/map-operator-swift/","section":"blogs","summary":"The collection is something which is used by almost everyone. It makes our life easy. Array, Set, and Dictionary are the best examples of them.\nTo iterate, filter, or modify the existing collection object, Swift provides us with a few in builds transform operators. Map operator is one of them. Let’s try to understand the Map operator in detail.\nWhat is Map operator? Map operator is used to creating a new collection object by iterating over the existing collection object and applying some transformation to it.\nThe transformation that needs to be applied, is passed as a higher-order function named transform to the map function.\nSince the map operator is present in Iterator, it can be used with all three collections ie Array, Set, and Dictionary.\n/// Returns an array containing the results of mapping the given closure over the sequence\u0026#39;s elements. /// - Parameter transform: A mapping closure. `transform` accepts an /// element of this sequence as its parameter and returns a transformed value of the same or of a different type. /// - Returns: An array containing the transformed elements of this sequence. @inlinable public func map\u0026lt;T\u0026gt;(_ transform: (Element) throws -\u0026gt; T) rethrows -\u0026gt; [T] Keep in mind, that this map function never holds the exceptions but it throws them to the caller. If there are any chances of any kind of exception at runtime, we need to wrap this inside a try-catch block.\nMap with Array map operator can be used over an Array to apply the transformation on its elements and return the new Array. It can be used with a named parameter or using $0.\nlet array = [1, 2, 3, 4, 5, 6] let mappedArray = array.map { item in //this will convert all the elements to its square item * item } //or let mappedArray = array.map { //this will convert all the elements to its square $0 * $0 } print(mappedArray) It can also be used with enumerated for positional-based access.\nlet array = [1, 2, 3, 4, 5, 6] let mappedArray = array.enumerated().map { index, item in //this will convert all the elements to its square item * item } //or let mappedArray = arrayenumerated.map { //this will convert all the elements to its square $1 * $1 } print(mappedArray) Map with Set Similar to Array, the map operator can be used along with a Set to iterate over its elements, apply some transformation on its elements and return the new Set. It can be used with a named parameter or using $0.\nlet set : Set = [1, 2, 3, 4, 5, 6] let filteredSet = set.map { item in item * item } //or let filteredSet = set.map { $0 * $0 } print(filteredSet) There is no point in using an enumerated map with the Set as it never guarantees the sequence in a Set.\nMap with Dictionary Similar to Array and Set, the map operator can be used over a Dictionary to iterate over the Dictionary, apply some transformation to its elements and return the new Dictionary. It can be used with a named parameter or using $0.\nlet map = [1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;] let filteredMap = map.map { item in (item.key, item.value.uppercased()) } //or let filteredMap = map.map { ($0.key, $0.value.uppercased()) } print(filteredMap) There is no point in using an enumerated map with the Dictionary as it never guarantees the sequence in a Dictionary.\n","tags":["Swift"],"title":"Map Operator: Swift"},{"categories":["Blog"],"date":"June 11, 2022","permalink":"https://mahigarg.github.io/blogs/0-1-n-in-swift/","section":"blogs","summary":"In order to use any parameter in a closure or a higher-order function, we need to name the parameter inside the closure or higher-order function.\nThe syntax looks like the below.\nlet array = [1, 2, 3, 4, 5, 6] let evenNumbers = array.filter { item in item % 2 == 0 } print(evenNumbers) This filter function takes a single argument which is another function that is of (Int) -\u0026gt; Bool type. The inner function takes every element of the array one by one and checks if that is an even number or not. It returns true if the condition is true else it returns false.\nThe parameter passed inside the function can be replaced with $0.\n$0 represents the first parameter of closure or higher-order function.\nIt can be used with both closers or higher-order functions.\nThe same syntax will look like below.\nlet array = [1, 2, 3, 4, 5, 6] let evenNumbers = array.filter { $0 % 2 == 0 } print(evenNumbers) In case the number of parameters are more than one,\n$0, $1 up to $n can be used.\nFor example, look at the below case where there are two parameters passed to the higher-order function namely index and item.\nlet array = [1, 2, 3, 4, 5, 6] let filterArray = array.enumerated().filter {index, item in //I am doing some rocket science here print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) return index != 2 \u0026amp;\u0026amp; item % 2 == 0 } print(filterArray) We can use $0 for index and $1 for item in the same example.\nlet array = [1, 2, 3, 4, 5, 6] let filterArray = array.enumerated().filter { //I am doing some rocket science here print(\u0026#34;Item at \\($0) is \\($1)\u0026#34;) return $0 != 2 \u0026amp;\u0026amp; $1 % 2 == 0 } print(filterArray) These numbers can go up to any number of parameters passed to the inner function.\nI’ll personally suggest using named parameters if the parameters are more than three as it\u0026rsquo;s difficult to remember which $ variable is what. Up to three is really helpful.\n","tags":["Swift"],"title":"$0, $1 … $n in Swift"},{"categories":["Blog"],"date":"June 4, 2022","permalink":"https://mahigarg.github.io/blogs/named-and-unnamed-parameters-swift/","section":"blogs","summary":"Functions are something that every developer uses daily. A function can of with or without parameters. Swift has multiple ways of passing the parameters to a function. we can alias the parameter name or we can even skip the parameter name while calling the function.\nThe parameter inside the function will still be used by its own name only but while calling the function, the name of the parameter can be replaced or even removed based on the function signature.\nLet\u0026rsquo;s look at them one by one.\nBelow is a normal function with a single parameter and calling it using the parameter name\nfunc doSomething(number : Int){ //I\u0026#39;ll do some rocket science here, //and at the end, will just print the param print (number) } doSomething(number: 100) In order to call the above function, we need to write the parameter name. In the above case the parameter name was number .\nSometimes it\u0026rsquo;s tedious to write the parameter name again and again or sometimes the function name itself is enough to make understand what that function is responsible for.\nIn those cases, in order to skip the parameter name every time we call that function, it can be preceded with an underscore _ which will make the parameter name unnamed.\nfunc doSomethingWithNumber(_ number : Int){ //I\u0026#39;ll do some rocket science here, //and at the end, will just print the param print (number) } doSomethingWithNumber(100) Here in the above example, we added an underscore _ in front of the parameter name which made the parameter unnamed. In order to call this function now, we don’t have to add the parameter name ie number in our case.\nKeep in mind that we can’t even use the parameter name now. Underscore _ doesn’t make it optional but it actually made it unnamed.\nWe can even provide an alias to the parameter after which the parameter will be used with the new alias name instead of the original parameter name.\nfunc doSomething(with number : Int){ //I\u0026#39;ll do some rocket science here, //and at the end, will just print the param print (number) } doSomething(with: 100) In the above example, we added with as an alias name for the parameter. Now in order to call this function, we need to use with as the parameter name instead of number.\nKeep in mind that this is not optional to use as a parameter name but it is mandatory.\nAlso, in all the cases, the parameter inside that function will still be used as its own name only. There is no change in that.\n","tags":["Swift"],"title":"Named and Unnamed Parameters: Swift"},{"categories":["Blog"],"date":"May 29, 2022","permalink":"https://mahigarg.github.io/blogs/filter-operator-swift/","section":"blogs","summary":"The collection is something which is used by almost everyone. It makes our life easy. Array, Set, and Dictionary are the best examples of them.\nTo iterate, filter, or modify the existing collection object, Swift provides us with a few in builds transform operators. Filter operator is one of them. Let\u0026rsquo;s try to understand the filter operator in detail.\nWhat is filter operator? The filter operator is used to create a new collection object by iterating over the existing collection object and filtering the elements based on the predicates to it.\nThe predicate that needs to be checked for, is passed as a higher-order function named isIncluded to the filter function.\nSince the filter operator is present in Iterator, it can be used with all three collections ie Array, Set, and Dictionary.\n/// Returns an array containing, in order, the elements of the sequence that satisfy the given predicate. /// - Parameter isIncluded: A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array. /// - Returns: An array of the elements that `isIncluded` allowed. /// - Complexity: O(*n*), where *n* is the length of the sequence. @inlinable public func filter(_ isIncluded: (Iterator.Element) throws -\u0026gt; Bool) rethrows -\u0026gt; [Iterator.Element] Keep in mind, that this filter function never holds the exceptions but it throws them to the caller. If there are any chances of any kind of exception at runtime, we need to wrap this inside a try-catch block.\nFilter with Array filter operator can be used over an Array to check the predicate on its elements and return the filtered Array. It can be used with a named parameter or using $0.\nlet array = [1, 2, 3, 4, 5, 6] let filteredArray = array.filter { item in item % 2 == 0 } //or let filteredArray = array.filter { $0 % 2 == 0 } print(filteredArray) It can also be used with enumerated for positional-based access.\nlet array = [1, 2, 3, 4, 5, 6] let filteredArray = array.enumerated().filter {index, item in //I am doing some rocket science here print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) return index != 2 \u0026amp;\u0026amp; item % 2 == 0 } //or let filteredArray = array.enumerated().filter { //I am doing some rocket science here print(\u0026#34;Item at \\($0) is \\($1)\u0026#34;) return $0 != 2 \u0026amp;\u0026amp; $1 % 2 == 0 } print(filteredArray) Filter with Set Similar to Array, the filter operator can be used over a Set to check the predicate on its elements and return the filtered Set. It can be used with a named parameter or using $0.\nlet set = [1, 2, 3, 4, 5, 6] let filteredSet = set.filter { item in item % 2 == 0 } //or let filteredSet = set.filter { $0 % 2 == 0 } print(filteredSet) There is no point in using an enumerated filter with the Set as it never guarantees the sequence in a Set.\nFilter with Dictionary Similar to Array and Set, the filter operator can be used over a Dictionary to check the predicate on its elements and return the filtered Dictionary. It can be used with a named parameter or using $0.\nlet map = [1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;] let filteredMap = map.filter { item in item.key % 2 == 0 } //or let filteredMap = map.filter { $0.key % 2 == 0 } print(filteredMap) There is no point in using an enumerated filter with the Dictionary as it never guarantees the sequence in a Dictionary.\n","tags":["Swift"],"title":"Filter Operator: Swift"},{"categories":["Blog"],"date":"May 28, 2022","permalink":"https://mahigarg.github.io/blogs/enumerated-in-swift/","section":"blogs","summary":"Enumerated is used to iterate over a collection along with the position access. It returns a sequence of Pairs where the first element in the Pair is the index and the second element is the element itself of the collection.\nEnumerated is useful when we want to access the position along with making any iteration, filtration or even mapping of the objects of a collection.\nLets look at its definition first.\n/* Returns a sequence of pairs (*n*, *x*), where *n* represents a consecutive integer starting at zero and *x* represents an element of the sequence. */ @inlinable public func enumerated() -\u0026gt; EnumeratedSequence\u0026lt;Array\u0026lt;Element\u0026gt;\u0026gt; Enumerated best use case is with an array.\nlet array = [1, 2, 3, 4, 5] for (index, item) in array.enumerated() { print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) } It can also be used with set and map but the order of insertion is not guaranteed in both set and map.\nlet set = [1, 2, 3, 4, 5] for (index, item) in set.enumerated() { print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) } let map = [1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;] for (index, item) in map.enumerated() { print(\u0026#34;Item at \\(index) is key: \\(item.key) value: \\(item.value)\u0026#34;) } Enumerated can also be used to iterate over a string with the sequence of Pairs of the index and the respective character at that index.\nfor (index, item) in \u0026#34;Swift\u0026#34;.enumerated() { print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) } //this will print Item at 0 is S Item at 1 is w Item at 2 is i Item at 3 is f Item at 4 is t There is no need to convert the string to a char array first and then iterate over it. The Enumerated function will take care of it.\n","tags":["Swift"],"title":"Enumerated in Swift"},{"categories":["Blog"],"date":"May 23, 2022","permalink":"https://mahigarg.github.io/blogs/labeled-statement-swift/","section":"blogs","summary":"Swift has a few inbuilt features which make our life super easy. Labeled statements are one of them. It allows us to name a statement and later within the scope, that particular statement can be referenced using the label provided.\nLet me explain this using an example. Assume we have a nested loop inside another loop. We want to break the inner as well as out loop on some condition.\nfor i in 0...5 { for j in 0...5 { print (i + j) //break from outer loop if i + j == 5 } } Break statement can help here but break statement only works for immediate loop.\nfor i in 0...5 { for j in 0...5 { print (i + j) //break from outer loop if i + j == 5 if (i + j == 5) { break } } } It will just break the inner loop but not the outer loop.\nThere is one way where we can use a boolean flag and set it to true when we found the first condition true and every time we check inside the outer loop for that flag.\nThere is another way where we can move this to a function and return from the function when the first time condition met.\nBut there is a simpler way in swift which can help us here. we can name the loops as per the requirement and can break them using the name of the loop as below.\nouterLoop: for i in 0...5 { innerLoop: for j in 0...5 { print (i + j) //break from outer loop if i + j == 5 if (i + j == 5) { break outerLoop } } } We can skip the label if we are not going to use it inside.\nThese label statement can be used with if statement, for-loop, while-loop, repeat and switch statement which makes our life super easy.\n","tags":["Swift"],"title":"Labeled Statement : Swift"}]