[{"categories":["Gist"],"date":"July 18, 2023","permalink":"https://mahigarg.github.io/gists/bubble-sort-swift/","section":"gists","summary":"Bubble sort is a simple and straightforward sorting algorithm commonly used in computer science. In Swift language, Bubble sort works by repeatedly swapping adjacent elements if they are in the wrong order until the entire list is sorted. It has a time complexity of O(n^2), making it inefficient for large data sets. The algorithm iterates through the list multiple times, comparing and swapping elements. However, it is easy to understand and implement, making it suitable for small or nearly sorted arrays where simplicity is prioritized over efficiency. For larger data sets, more efficient sorting algorithms like QuickSort or MergeSort are preferred.\n","tags":["Programming-Basics"],"title":"Bubble Sort : Swift"},{"categories":["Blog"],"date":"July 18, 2023","permalink":"https://mahigarg.github.io/blogs/dictionary-swift/","section":"blogs","summary":"Dictionaries in Swift provide a key-value pair mechanism for efficient data storage and retrieval. They are implemented using hash tables, allowing fast access and modification of values based on keys. Dictionaries support operations like adding, removing, and iterating over elements. With constant time complexity for most operations, dictionaries are a powerful tool for organizing and managing data in Swift programming.\nLet us explore syntax, usage, and various operations that can be performed on dictionay.\nCreating a Dictionary: In Swift, dictionaries are represented by the Dictionary\u0026lt;Key, Value\u0026gt; type, or simply [Key: Value]. Time complexity for creating an empty dictionary is O(1). Here\u0026rsquo;s how you can create an empty dictionary or initialize it with values:\n// Empty Dictionary var emptyDictionary: [String: Int] = [:] // Initializing a Dictionary var fruits = [\u0026#34;apple\u0026#34;: 3, \u0026#34;banana\u0026#34;: 5, \u0026#34;orange\u0026#34;: 2] Accessing and Modifying Values: You can access values in a dictionary using their corresponding keys. If the key exists, the value will be returned; otherwise, it will return nil. Time complexity for accessing and modifying values in an dictionary is O(1). Here\u0026rsquo;s an example:\nlet numberOfApples = fruits[\u0026#34;apple\u0026#34;] // returns 3 // Modifying values fruits[\u0026#34;banana\u0026#34;] = 10 Adding and Removing Elements: To add elements to a dictionary, you can assign a value to a specific key. If the key already exists, the value will be updated; otherwise, a new key-value pair will be added. Removing elements can be done using the removeValue(forKey:) method. Time complexity of adding and removing element in dictionary is O(1). However, in some cases, the complexity can be O(n) due to the need to resize the underlying hash table. Examples:\nfruits[\u0026#34;kiwi\u0026#34;] = 4 // Adding a new element fruits.removeValue(forKey: \u0026#34;orange\u0026#34;) // Removing an element Iterating over a Dictionary: Swift provides several ways to iterate over the elements in a dictionary. You can use a for-in loop to access each key-value pair, or you can iterate over keys or values separately using the keys and values properties. Iterating over a dictionary has a time complexity of O(n), where n is the number of key-value pairs in the dictionary. This is because iterating requires visiting each element once. Here\u0026rsquo;s an example:\nfor (fruit, quantity) in fruits { print(\u0026#34;There are \\(quantity) \\(fruit)s\u0026#34;) } for fruit in fruits.keys { print(fruit) } for quantity in fruits.values { print(quantity) } Checking for the Existence of Keys and Values: To check if a key or value exists in a dictionary, you can use the contains(where:) method or the keys.contains(:) and values.contains(:) properties. Checking for the existence of keys or values in a dictionary has an average time complexity of O(1). This is due to the efficient lookup mechanism provided by the hash table implementation. Here\u0026rsquo;s an example:\nif fruits.contains(where: { $0.key == \u0026#34;apple\u0026#34; }) { print(\u0026#34;Apple exists\u0026#34;) } if fruits.values.contains(5) { print(\u0026#34;There is a fruit with quantity 5\u0026#34;) } Dictionary Operations and Properties: Swift dictionaries provide various operations and properties to work with. Some notable ones include:\ncount: Returns the number of key-value pairs in the dictionary. isEmpty: Returns a Boolean value indicating whether the dictionary is empty. keys: Returns a collection containing all the keys in the dictionary. values: Returns a collection containing all the values in the dictionary. merge(_:uniquingKeysWith:): Merges the given dictionary with the current dictionary. filter(_:): Returns a new dictionary containing the key-value pairs that satisfy the given predicate. Conclusion: Dictionaries are powerful data structures that allow you to store and retrieve values using a key-value pair mechanism. In Swift, dictionaries are easy to use and provide various operations for manipulating and accessing data efficiently. By understanding the concepts and techniques covered in this blog post, you are now equipped to work with dictionaries effectively in Swift. Happy coding!\n","tags":["Swift"],"title":"Dictionary: Swift"},{"categories":["Gist"],"date":"July 15, 2023","permalink":"https://mahigarg.github.io/gists/carousel-view-swiftui/","section":"gists","summary":"A carousel view is a user interface component commonly used in mobile and web applications to display a collection of items in a horizontally scrolling manner. It allows users to swipe or navigate through a set of images, cards, or other content. The carousel view typically presents a subset of items at a time, with the ability to cycle through the remaining items. It is an engaging and intuitive way to showcase multiple pieces of content within a limited space, providing an interactive and visually appealing user experience.\n","tags":["SwiftUI"],"title":"Carousel View : SwiftUI"},{"categories":["Gist"],"date":"July 13, 2023","permalink":"https://mahigarg.github.io/gists/linked-list-methods-swift/","section":"gists","summary":"A linked list is a data structure in Swift that consists of nodes linked together via pointers or references. Each node contains data and a reference to the next node. Unlike an array, a linked list does not require contiguous memory allocation. Insertions and deletions can be performed efficiently in a linked list by updating the pointers, but accessing elements requires traversing the list linearly. Linked lists are useful when frequent insertions or deletions are expected, and their time complexity for most operations is O(1) or O(n) depending on the operation.\n","tags":["Programming-Basics"],"title":"Linked List : Swift"},{"categories":["Gist"],"date":"July 11, 2023","permalink":"https://mahigarg.github.io/gists/remove-duplicate-array-swift/","section":"gists","summary":"To remove duplicates from an array in Swift using a dictionary, we can create an empty dictionary and iterate through the array. For each element, we use it as a key in the dictionary and assign a dummy value. The dictionary automatically removes duplicate keys, so we end up with only unique elements. The time complexity of this approach is O(n), where n is the number of elements in the array, making it an efficient solution for removing duplicates..\n","tags":["Programming-Basics"],"title":"Remove duplicates from array: Swift"},{"categories":["Gist"],"date":"July 8, 2023","permalink":"https://mahigarg.github.io/gists/binary-serach-swift/","section":"gists","summary":"Binary search is an efficient search algorithm used to locate a specific element in a sorted array or list. It works by repeatedly dividing the search space in half until the target element is found. In Swift, binary search is typically implemented recursively or iteratively. The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it highly efficient for large data sets as it eliminates half of the remaining search space at each step, significantly reducing the search time.\n","tags":["Programming-Basics"],"title":"Binary Serach : Swift"},{"categories":["Gist"],"date":"July 2, 2023","permalink":"https://mahigarg.github.io/gists/insertion-sort-swift/","section":"gists","summary":"Insertion sort is a simple sorting algorithm in Swift that builds the final sorted array one element at a time. It iterates through the array, comparing each element with the sorted portion and placing it in the correct position. This process continues until all elements are sorted. Insertion sort has a time complexity of O(n^2) in the worst case, but it performs well on small data sets or partially sorted arrays. It also has an advantage in that it can efficiently sort elements in real-time as they are received or generated.\n","tags":["Programming-Basics"],"title":"Insertion Sort : Swift"},{"categories":["Gist"],"date":"June 28, 2023","permalink":"https://mahigarg.github.io/gists/selection-sort-swift/","section":"gists","summary":"Selection sort is a sorting algorithm in Swift that works by repeatedly finding the minimum element from the unsorted portion of an array and swapping it with the element in the correct position. This process is iterated until the entire array is sorted. While simple to understand and implement, selection sort has a time complexity of O(n^2), making it inefficient for large data sets. However, it has the advantage of having a minimal number of swaps, which can be beneficial in certain memory-constrained scenarios.\n","tags":["Programming-Basics"],"title":"Selection Sort : Swift"},{"categories":["Gist"],"date":"June 23, 2023","permalink":"https://mahigarg.github.io/gists/dutch-national-flag-swift/","section":"gists","summary":"The Dutch National Flag algorithm is a sorting algorithm that partitions an array into three sections: elements less than a given pivot, elements equal to the pivot, and elements greater than the pivot. In Swift, we can implement this algorithm by maintaining three pointers and swapping elements accordingly. The time complexity of the Dutch National Flag algorithm is O(n), where n is the number of elements in the array. It is an efficient algorithm for sorting arrays with a limited range of values, like sorting colors or other categorical data.\n","tags":["Programming-Basics"],"title":"Dutch National Flag : Sort Int Array of 0,1 and 2 : Swift"},{"categories":["Blog"],"date":"April 25, 2023","permalink":"https://mahigarg.github.io/blogs/closures-swift/","section":"blogs","summary":"Closures are a powerful feature of the Swift programming language that allows you to write code that can be passed around and executed at a later time. They are self-contained blocks of functionality.\nClosures are commonly used in Swift to perform tasks like sorting and filtering collections and for handling asynchronous tasks.\nSyntax:\nA closure is defined using curly braces { } and can take in one or more arguments, and returns a value. Here’s a basic syntax of a closure:\n{ (params) -\u0026gt; return type in // Statement } params — any value passed to the closure returnType — specifies the type of value returned by the closure in (optional) — used to separate parameters/returnType from the closure body Statement — code to be executed. Closures need not have the first 3 always. Find the below examples supporting the statement.\nvar sayHi = { print(\u0026#34;Hey!\u0026#34;) } // call the closure sayHi() // output is Hey! This example of closure prints a string. It doesn’t require any parameters. It doesn’t return anything. It just has a single line of code to execute.\nNow let us see other examples of closure where we have either a parameter or a return type.\nlet sayHi = { (name: String) in print(\u0026#34;Hey!, \\(name).\u0026#34;) } // closure call sayHi(\u0026#34;Mahi\u0026#34;) // output is Hey!, Mahi let taskCompleted = { ()-\u0026gt; String in return \u0026#34;Bravo You Are Done!\u0026#34; } // closure call print(taskCompleted()) // output is Bravo You Are Done! Hope you have understood what is closure. How to write closure in Swift. Now let us move to the usage of closure in Swift.\nNow let us consider a block of code that needs to be executed after the method has completed its task. Let us have a look below for example.\nfunc add(first: Int, second: Int, completion: (Int) -\u0026gt; String) { let sum = first + second print(completion(sum)) } add(first: 4, second: 56) { result in return \u0026#34;result is \\(result)\u0026#34; } // output is result is 60 add(first: 4, second: 56) { result in return \u0026#34;sum is \\(result)\u0026#34; } // output is sum is 60 Here method add takes 2 integers and 1 closure as arguments. It performs the sum of 2 numbers. After the addition is done it calls the closure to print the result according to the code written in the closure.\nHere, the first method call defines the closure to return the string “result is 60” while the second return the string “sum is 60”. So we can conclude that closure also gives the power to the method to execute a different set of code depending on where it is called.\n","tags":["Swift"],"title":"Closures: Swift"},{"categories":["Blog"],"date":"August 22, 2022","permalink":"https://mahigarg.github.io/blogs/for-loop-with-where-clause-swift/","section":"blogs","summary":"For loop is an inevitable part of any programming language. It iterates over every element of the collection type data including array, set, and dictionary, and does the operation as per the code.\nLet us see an example of the same. Consider an array of integers and a for loop accessing its even integers.\n//array example let numbers = [23,62,6,12,87,55,45,22] //for loop for number in numbers { print(number) } Above swift code will print all integers in the array. But sometimes we need only elements on certain conditions like even number, or positive number. This can be achieved by giving a where clause with the for loop body.\nLet us see the code for filtering even numbers.\n//for loop with where for number in numbers where number % 2 == 0 { print(number) } // print 62 6 12 22 Here data is filtered according to where clause i.e., only even numbers will be printed. Similarly, we can filter data on more than one condition using (||) or and (\u0026amp;\u0026amp;) depending on the use case.\nLet us look at this with an example.\n//for loop with where for number in numbers where number % 2 == 0 || number \u0026gt; 50 { print(number) } // 62 6 12 87 55 22 Here data is filtered according to where clause i.e., even numbers or numbers greater than 50 will be printed.\nNow let us consider case printing numbers that are even and greater than 50.\n//for loop with where for number in numbers where number % 2 == 0 \u0026amp;\u0026amp; number \u0026gt; 50 { print(number) } // prints even numbers and number greater than 50 // 62 Here data is filtered according to where clause i.e. even numbers and numbers greater than 50 will be printed.\n","tags":["Swift"],"title":"For loop with where clause: Swift"},{"categories":["Blog"],"date":"August 16, 2022","permalink":"https://mahigarg.github.io/blogs/round-up-to-n-decimal-digit-swift/","section":"blogs","summary":"We sometimes in our calculation get results with more than 4 decimal digits or even more. But as a developer, we can’t use the same to display to users.\nImagine we have a dashboard application that displays monthly tax on an employee\u0026rsquo;s salary. And it is coming as 630.6152. This doesn’t look good at all to say the same. It will be better to show it like 630.62 or 630.61 i.e., rounding it to n Decimal Digit.\nLet us take a look at how this can be done.\nIf we say round up to n Decimal Digits where n equals 2. Then we need to follow the below steps\nMultiply it by 100 (10^n) Use round, floor, or ceil to remove the extra digits Divide by 100 (10^n) Round to n digits using the round function //after calculation tax = 630.6152 //multiply with 100 var result = tax * 100 //63061.52 //Using round to remove extra digit roundresult = round(result) //63062 //divide by 100 result = result/ 100 print (result) //630.62 print(evenNumbers) Here tax 630.6152 is rounded to 630.62 as the third decimal digit is 5.\nLet us consider example 437.1932. Here 3 is the third decimal digit.\n//after calculation tax = 437.1932 //multiply with 100 var result = tax * 100 //43719.32 //Using round to remove extra digit roundresult = round(result) //43719 //divide by 100 result = result/ 100 print (result) //437.19 On comparing the result of both the example, we can see the result depends on the decimal digits we have. If the third digit is between 1 to 4, then it will keep the existing previous results (437.1932 -\u0026gt; 437.19) but in the case of digits between 5–9, it increases the last digit (630.6152 -\u0026gt; 630.61).\nNow let us see how our output will be impacted if we use the floor or ceil function instead of round.\nRound to n digits using the floor function Considering the same example here. Tax after calculation equals 630.6152.\n//after calculation tax = 630.6152 //multiply with 100 var result = tax * 100 //63061.52 //Using floor to remove extra digit floorResult = floor(result) //63061 //divide by 100 floorResult = floorResult / 100 print (floorResult) //630.61 Here, we saw floor will step down the result irrespective of the digit we have at the third position, be it 1 or 9 it will always take you to the nearest smallest number.\nRound to n digits using the ceil function Here, let us alter our example to 630.6122 and see how our results vary.\n//after calculation tax = 630.6122 //multiply with 100 var result = tax * 100 //63061.22 //Using ceil to remove extra digit ceilResult = ceil(result) //63062 //divide by 100 ceilResult = ceilResult / 100 print (ceilResult) //630.62 Here, we saw ceil will step up the result irrespective of the digit we have at the third position, be it anything between 1 to 9 it will always take you to the nearest largest number.\n","tags":["Swift"],"title":"Round up to n Decimal Digit: Swift"},{"categories":["Blog"],"date":"May 31, 2022","permalink":"https://mahigarg.github.io/blogs/setup-firebase-remoteconfig/","section":"blogs","summary":"In continuation with the previous article stating the benefits and working of Firebase RemoteConfig, this article will help you to set up Firebase step by step. Additionally, it will tell you how to configure the remoteConfig Parameter and fetch and Apply the configuration to your app.\nStep 1: Setting Up Firebase RemoteConfig: 1.1 Create a Firebase Project: Start by creating a Firebase project through the Firebase console. Follow the provided instructions to set up your project, including adding the necessary dependencies to your app.\n1.2 Enable RemoteConfig: In the Firebase console, navigate to the RemoteConfig section and enable it for your project. This will allow you to define and manage remote configurations for your app.\nStep 2: Configuring Remote Parameters: 2.1 Define Parameters: Within the RemoteConfig section of the Firebase console, define the parameters you want to configure remotely. These parameters can include strings, booleans, numbers, or JSON objects. Set default values for each parameter to ensure that your app has fallback values in case the remote configurations are not yet fetched.\n2.2 Add Conditions (Optional): To target specific user segments or conditions, you can add conditions to your parameters. For example, you can define a condition based on the user’s country, app version, or any other custom criteria. This allows you to tailor the configurations for different user segments.\nStep 3: Fetching and Applying Configurations: 3.1 Initialize RemoteConfig: In your app’s code, initialize the RemoteConfig instance by obtaining a reference to it from the Firebase SDK. This allows you to interact with the RemoteConfig service.\n3.2 Fetch Configurations: To fetch the remote configurations, call the fetch() method on the RemoteConfig instance. You can specify a cache expiration duration to control how frequently the configurations should be refreshed. Firebase provides options for using a minimum fetch interval or manual fetch.\n3.3 Apply Configurations: After fetching the configurations, call the activate() method to apply the fetched configurations to your app. This ensures that the app\u0026rsquo;s behavior aligns with the remote settings.\nStep 4: Remote Configuration Updates: 4.1 Modify Configurations: To update the configurations remotely, make changes within the Firebase console. You can modify parameter values, add new parameters, or adjust conditions.\n4.2 Publish Configurations: After making the necessary changes, publish the configurations from the Firebase console. Publishing makes the updated configurations available to your app during the next fetch.\nStep 5: Testing and Monitoring: 5.1 Test Configurations: Before deploying the configurations to all users, test them thoroughly to ensure they function as expected. Consider creating a test environment or using Firebase’s remote conditions to target a small group of users for testing purposes.\n5.2 Monitor Performance: Leverage Firebase Analytics to track the impact of configuration changes on user behavior, engagement, and other relevant metrics. This helps you understand the effectiveness of your configurations and make data-driven decisions for optimization.\n","tags":["Firebase"],"title":"Setup Firebase RemoteConfig"},{"categories":["Blog"],"date":"May 30, 2022","permalink":"https://mahigarg.github.io/blogs/map-operator-swift/","section":"blogs","summary":"The collection is something which is used by almost everyone. It makes our life easy. Array, Set, and Dictionary are the best examples of them.\nTo iterate, filter, or modify the existing collection object, Swift provides us with a few in builds transform operators. Map operator is one of them. Let’s try to understand the Map operator in detail.\nWhat is Map operator? Map operator is used to creating a new collection object by iterating over the existing collection object and applying some transformation to it.\nThe transformation that needs to be applied, is passed as a higher-order function named transform to the map function.\nSince the map operator is present in Iterator, it can be used with all three collections ie Array, Set, and Dictionary.\n/// Returns an array containing the results of mapping the given closure over the sequence\u0026#39;s elements. /// - Parameter transform: A mapping closure. `transform` accepts an /// element of this sequence as its parameter and returns a transformed value of the same or of a different type. /// - Returns: An array containing the transformed elements of this sequence. @inlinable public func map\u0026lt;T\u0026gt;(_ transform: (Element) throws -\u0026gt; T) rethrows -\u0026gt; [T] Keep in mind, that this map function never holds the exceptions but it throws them to the caller. If there are any chances of any kind of exception at runtime, we need to wrap this inside a try-catch block.\nMap with Array map operator can be used over an Array to apply the transformation on its elements and return the new Array. It can be used with a named parameter or using $0.\nlet array = [1, 2, 3, 4, 5, 6] let mappedArray = array.map { item in //this will convert all the elements to its square item * item } //or let mappedArray = array.map { //this will convert all the elements to its square $0 * $0 } print(mappedArray) It can also be used with enumerated for positional-based access.\nlet array = [1, 2, 3, 4, 5, 6] let mappedArray = array.enumerated().map { index, item in //this will convert all the elements to its square item * item } //or let mappedArray = arrayenumerated.map { //this will convert all the elements to its square $1 * $1 } print(mappedArray) Map with Set Similar to Array, the map operator can be used along with a Set to iterate over its elements, apply some transformation on its elements and return the new Set. It can be used with a named parameter or using $0.\nlet set : Set = [1, 2, 3, 4, 5, 6] let filteredSet = set.map { item in item * item } //or let filteredSet = set.map { $0 * $0 } print(filteredSet) There is no point in using an enumerated map with the Set as it never guarantees the sequence in a Set.\nMap with Dictionary Similar to Array and Set, the map operator can be used over a Dictionary to iterate over the Dictionary, apply some transformation to its elements and return the new Dictionary. It can be used with a named parameter or using $0.\nlet map = [1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;] let filteredMap = map.map { item in (item.key, item.value.uppercased()) } //or let filteredMap = map.map { ($0.key, $0.value.uppercased()) } print(filteredMap) There is no point in using an enumerated map with the Dictionary as it never guarantees the sequence in a Dictionary.\n","tags":["Swift"],"title":"Map Operator: Swift"},{"categories":["Blog"],"date":"May 29, 2022","permalink":"https://mahigarg.github.io/blogs/0-1-n-in-swift/","section":"blogs","summary":"In order to use any parameter in a closure or a higher-order function, we need to name the parameter inside the closure or higher-order function.\nThe syntax looks like the below.\nlet array = [1, 2, 3, 4, 5, 6] let evenNumbers = array.filter { item in item % 2 == 0 } print(evenNumbers) This filter function takes a single argument which is another function that is of (Int) -\u0026gt; Bool type. The inner function takes every element of the array one by one and checks if that is an even number or not. It returns true if the condition is true else it returns false.\nThe parameter passed inside the function can be replaced with $0.\n$0 represents the first parameter of closure or higher-order function.\nIt can be used with both closers or higher-order functions.\nThe same syntax will look like below.\nlet array = [1, 2, 3, 4, 5, 6] let evenNumbers = array.filter { $0 % 2 == 0 } print(evenNumbers) In case the number of parameters are more than one,\n$0, $1 up to $n can be used.\nFor example, look at the below case where there are two parameters passed to the higher-order function namely index and item.\nlet array = [1, 2, 3, 4, 5, 6] let filterArray = array.enumerated().filter {index, item in //I am doing some rocket science here print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) return index != 2 \u0026amp;\u0026amp; item % 2 == 0 } print(filterArray) We can use $0 for index and $1 for item in the same example.\nlet array = [1, 2, 3, 4, 5, 6] let filterArray = array.enumerated().filter { //I am doing some rocket science here print(\u0026#34;Item at \\($0) is \\($1)\u0026#34;) return $0 != 2 \u0026amp;\u0026amp; $1 % 2 == 0 } print(filterArray) These numbers can go up to any number of parameters passed to the inner function.\nI’ll personally suggest using named parameters if the parameters are more than three as it\u0026rsquo;s difficult to remember which $ variable is what. Up to three is really helpful.\n","tags":["Swift"],"title":"$0, $1 … $n in Swift"},{"categories":["Blog"],"date":"May 29, 2022","permalink":"https://mahigarg.github.io/blogs/filter-operator-swift/","section":"blogs","summary":"The collection is something which is used by almost everyone. It makes our life easy. Array, Set, and Dictionary are the best examples of them.\nTo iterate, filter, or modify the existing collection object, Swift provides us with a few in builds transform operators. Filter operator is one of them. Let\u0026rsquo;s try to understand the filter operator in detail.\nWhat is filter operator? The filter operator is used to create a new collection object by iterating over the existing collection object and filtering the elements based on the predicates to it.\nThe predicate that needs to be checked for, is passed as a higher-order function named isIncluded to the filter function.\nSince the filter operator is present in Iterator, it can be used with all three collections ie Array, Set, and Dictionary.\n/// Returns an array containing, in order, the elements of the sequence that satisfy the given predicate. /// - Parameter isIncluded: A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array. /// - Returns: An array of the elements that `isIncluded` allowed. /// - Complexity: O(*n*), where *n* is the length of the sequence. @inlinable public func filter(_ isIncluded: (Iterator.Element) throws -\u0026gt; Bool) rethrows -\u0026gt; [Iterator.Element] Keep in mind, that this filter function never holds the exceptions but it throws them to the caller. If there are any chances of any kind of exception at runtime, we need to wrap this inside a try-catch block.\nFilter with Array filter operator can be used over an Array to check the predicate on its elements and return the filtered Array. It can be used with a named parameter or using $0.\nlet array = [1, 2, 3, 4, 5, 6] let filteredArray = array.filter { item in item % 2 == 0 } //or let filteredArray = array.filter { $0 % 2 == 0 } print(filteredArray) It can also be used with enumerated for positional-based access.\nlet array = [1, 2, 3, 4, 5, 6] let filteredArray = array.enumerated().filter {index, item in //I am doing some rocket science here print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) return index != 2 \u0026amp;\u0026amp; item % 2 == 0 } //or let filteredArray = array.enumerated().filter { //I am doing some rocket science here print(\u0026#34;Item at \\($0) is \\($1)\u0026#34;) return $0 != 2 \u0026amp;\u0026amp; $1 % 2 == 0 } print(filteredArray) Filter with Set Similar to Array, the filter operator can be used over a Set to check the predicate on its elements and return the filtered Set. It can be used with a named parameter or using $0.\nlet set = [1, 2, 3, 4, 5, 6] let filteredSet = set.filter { item in item % 2 == 0 } //or let filteredSet = set.filter { $0 % 2 == 0 } print(filteredSet) There is no point in using an enumerated filter with the Set as it never guarantees the sequence in a Set.\nFilter with Dictionary Similar to Array and Set, the filter operator can be used over a Dictionary to check the predicate on its elements and return the filtered Dictionary. It can be used with a named parameter or using $0.\nlet map = [1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;] let filteredMap = map.filter { item in item.key % 2 == 0 } //or let filteredMap = map.filter { $0.key % 2 == 0 } print(filteredMap) There is no point in using an enumerated filter with the Dictionary as it never guarantees the sequence in a Dictionary.\n","tags":["Swift"],"title":"Filter Operator: Swift"},{"categories":["Blog"],"date":"May 28, 2022","permalink":"https://mahigarg.github.io/blogs/enumerated-in-swift/","section":"blogs","summary":"Enumerated is used to iterate over a collection along with the position access. It returns a sequence of Pairs where the first element in the Pair is the index and the second element is the element itself of the collection.\nEnumerated is useful when we want to access the position along with making any iteration, filtration or even mapping of the objects of a collection.\nLets look at its definition first.\n/* Returns a sequence of pairs (*n*, *x*), where *n* represents a consecutive integer starting at zero and *x* represents an element of the sequence. */ @inlinable public func enumerated() -\u0026gt; EnumeratedSequence\u0026lt;Array\u0026lt;Element\u0026gt;\u0026gt; Enumerated best use case is with an array.\nlet array = [1, 2, 3, 4, 5] for (index, item) in array.enumerated() { print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) } It can also be used with set and map but the order of insertion is not guaranteed in both set and map.\nlet set = [1, 2, 3, 4, 5] for (index, item) in set.enumerated() { print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) } let map = [1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;] for (index, item) in map.enumerated() { print(\u0026#34;Item at \\(index) is key: \\(item.key) value: \\(item.value)\u0026#34;) } Enumerated can also be used to iterate over a string with the sequence of Pairs of the index and the respective character at that index.\nfor (index, item) in \u0026#34;Swift\u0026#34;.enumerated() { print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) } //this will print Item at 0 is S Item at 1 is w Item at 2 is i Item at 3 is f Item at 4 is t There is no need to convert the string to a char array first and then iterate over it. The Enumerated function will take care of it.\n","tags":["Swift"],"title":"Enumerated in Swift"},{"categories":["Blog"],"date":"May 28, 2022","permalink":"https://mahigarg.github.io/blogs/named-and-unnamed-parameters-swift/","section":"blogs","summary":"Functions are something that every developer uses daily. A function can of with or without parameters. Swift has multiple ways of passing the parameters to a function. we can alias the parameter name or we can even skip the parameter name while calling the function.\nThe parameter inside the function will still be used by its own name only but while calling the function, the name of the parameter can be replaced or even removed based on the function signature.\nLet\u0026rsquo;s look at them one by one.\nBelow is a normal function with a single parameter and calling it using the parameter name\nfunc doSomething(number : Int){ //I\u0026#39;ll do some rocket science here, //and at the end, will just print the param print (number) } doSomething(number: 100) In order to call the above function, we need to write the parameter name. In the above case the parameter name was number .\nSometimes it\u0026rsquo;s tedious to write the parameter name again and again or sometimes the function name itself is enough to make understand what that function is responsible for.\nIn those cases, in order to skip the parameter name every time we call that function, it can be preceded with an underscore _ which will make the parameter name unnamed.\nfunc doSomethingWithNumber(_ number : Int){ //I\u0026#39;ll do some rocket science here, //and at the end, will just print the param print (number) } doSomethingWithNumber(100) Here in the above example, we added an underscore _ in front of the parameter name which made the parameter unnamed. In order to call this function now, we don’t have to add the parameter name ie number in our case.\nKeep in mind that we can’t even use the parameter name now. Underscore _ doesn’t make it optional but it actually made it unnamed.\nWe can even provide an alias to the parameter after which the parameter will be used with the new alias name instead of the original parameter name.\nfunc doSomething(with number : Int){ //I\u0026#39;ll do some rocket science here, //and at the end, will just print the param print (number) } doSomething(with: 100) In the above example, we added with as an alias name for the parameter. Now in order to call this function, we need to use with as the parameter name instead of number.\nKeep in mind that this is not optional to use as a parameter name but it is mandatory.\nAlso, in all the cases, the parameter inside that function will still be used as its own name only. There is no change in that.\n","tags":["Swift"],"title":"Named and Unnamed Parameters: Swift"},{"categories":["Blog"],"date":"May 28, 2022","permalink":"https://mahigarg.github.io/blogs/remoteconfig-in-firebase/","section":"blogs","summary":"In today’s fast-paced world, mobile app developers must adapt quickly to changing user preferences, market demands, and evolving business requirements. To achieve this, developers need a robust mechanism to configure apps remotely without frequent updates. Firebase RemoteConfig is a powerful tool offered by Google Firebase. It enables developers to dynamically update app settings, content, and feature flags from a centralized console, allowing them to deliver a personalized and tailored experience to the users.\nWhat is Firebase RemoteConfig? Firebase RemoteConfig is a cloud-based service that allows developers to change the behavior and appearance of their mobile applications without requiring users to update their apps. It provides a simple and efficient way to manage configurable parameters such as feature flags, strings, numbers, and even remote JSON files. With RemoteConfig, developers can fine-tune their app’s behavior, perform A/B testing, and target specific user segments based on dynamic conditions.\nBenefits of Using RemoteConfig: 2.1 Real-time Configuration Updates: Firebase RemoteConfig enables developers to update app configurations in real time, eliminating the need for app updates. This capability empowers developers to react swiftly to changing requirements, fix bugs, and introduce new features without disrupting the user experience.\n2.2 Personalization and A/B Testing: With RemoteConfig, developers can define configurations for specific user segments or conduct A/B tests to evaluate the impact of various settings on user engagement and conversion rates. This allows for data-driven decision-making and personalized experiences tailored to each user.\n2.3 Gradual Rollouts and Phased Feature Launches: RemoteConfig supports gradual rollouts of new features by allowing developers to target a subset of users with specific configurations. By releasing features incrementally, developers can gather feedback, monitor performance, and ensure a smooth rollout for all users.\n2.4 Simplified Maintenance: By centralizing configuration management in a web-based console, RemoteConfig simplifies the maintenance process. Developers can modify configurations, set default values, and monitor the usage and impact of different settings, all from a single location.\nWorking with RemoteConfig: 3.1 Configuration Setup: Developers define configuration parameters, their default values, and any associated conditions within the Firebase console. These parameters are stored in the Firebase backend and can be easily updated without requiring app updates.\n3.2 Fetching and Applying Configurations: The mobile app fetches the latest configurations from the Firebase backend during runtime. RemoteConfig provides a simple API to fetch and apply configurations within the app, ensuring that the app’s behavior adapts to the latest settings.\n3.3 Conditions and Targeting: RemoteConfig supports conditional configurations based on various criteria such as app version, language, country, user properties, or custom conditions defined by developers. This allows for precise targeting and tailoring of experiences to different user segments.\nBest Practices and Considerations: 4.1 Testing and Validation: Thoroughly test and validate configuration changes before rolling them out to ensure they function as intended and do not negatively impact the app’s stability or performance.\n4.2 Version Control: Maintain a version control system or use Firebase’s history feature to track and revert configuration changes if necessary, ensuring better accountability and easy rollback options.\n4.3 Monitoring and Analytics: Leverage Firebase Analytics to track the impact of configuration changes on user behavior, engagement, and conversion rates. Monitor performance and iterate on configurations to optimize the user experience continually.\nConclusion: Firebase RemoteConfig empowers mobile app developers with a flexible and efficient mechanism to manage remote configurations, allowing them to adapt quickly to changing requirements and deliver personalized experiences to their users. By leveraging RemoteConfig’s real-time updates, targeted structures, and simplified maintenance.\n","tags":["Firebase"],"title":"RemoteConfig in Firebase"},{"categories":["Blog"],"date":"May 23, 2022","permalink":"https://mahigarg.github.io/blogs/labeled-statement-swift/","section":"blogs","summary":"Swift has a few inbuilt features which make our life super easy. Labeled statements are one of them. It allows us to name a statement and later within the scope, that particular statement can be referenced using the label provided.\nLet me explain this using an example. Assume we have a nested loop inside another loop. We want to break the inner as well as out loop on some condition.\nfor i in 0...5 { for j in 0...5 { print (i + j) //break from outer loop if i + j == 5 } } Break statement can help here but break statement only works for immediate loop.\nfor i in 0...5 { for j in 0...5 { print (i + j) //break from outer loop if i + j == 5 if (i + j == 5) { break } } } It will just break the inner loop but not the outer loop.\nThere is one way where we can use a boolean flag and set it to true when we found the first condition true and every time we check inside the outer loop for that flag.\nThere is another way where we can move this to a function and return from the function when the first time condition met.\nBut there is a simpler way in swift which can help us here. we can name the loops as per the requirement and can break them using the name of the loop as below.\nouterLoop: for i in 0...5 { innerLoop: for j in 0...5 { print (i + j) //break from outer loop if i + j == 5 if (i + j == 5) { break outerLoop } } } We can skip the label if we are not going to use it inside.\nThese label statement can be used with if statement, for-loop, while-loop, repeat and switch statement which makes our life super easy.\n","tags":["Swift"],"title":"Labeled Statement : Swift"}]