[{"categories":["Blog"],"date":"July 21, 2023","permalink":"https://mahigarg.github.io/blogs/guard-let-in-swift/","section":"blogs","summary":"guard let : Art of Early Returns with Optionals Introduction: In the realm of Swift programming, handling optionals with precision is of paramount importance to ensure code safety and maintainability. One of the most elegant constructs for handling optionals is the guard let statement. In this blog, we will delve into the world of guard let and explore how it enables developers to gracefully exit functions early when dealing with optional values. By the end of this blog, you will understand why guard let is a powerful tool in your Swift programming arsenal.\nUnderstanding Optionals in Swift: Before we jump into the wonders of guard let, let\u0026rsquo;s take a moment to understand optionals in Swift. An optional is a type that can either store a value or be nil. The presence of the question mark \u0026lsquo;?\u0026rsquo; after a type indicates that it is an optional type. For instance, String? denotes an optional String.\nThe Purpose of guard let: guard let is a control flow statement that ensures a value exists within an optional and, if so, binds it to a non-optional variable for use within the current scope. If the value is nil, the guard statement mandates an early exit from the current function, guard clause, or loop. It helps to keep the main body of code clean and readable by eliminating deeply nested if statements.\nSyntax of guard let: The syntax of guard let is as follows:\nfunc someFunction() { guard let nonOptionalVar = optionalVar else { // Code to be executed if optionalVar is nil // Return, throw, or continue with the rest of the function\u0026#39;s code } // Code to be executed if optionalVar is not nil // nonOptionalVar is safely unwrapped and ready for use within this scope } Example of guard let: Let\u0026rsquo;s illustrate the power of guard let with an example. Suppose we have a function that accepts an optional Int and performs some operation on it:\nfunc performOperation(value: Int?) { // Ensure value is not nil using guard let guard let unwrappedValue = value else { print(\u0026#34;Value is nil. Operation cannot be performed.\u0026#34;) return } // Continue with the operation using unwrappedValue let result = unwrappedValue * 2 print(\u0026#34;The result is: \\(result)\u0026#34;) } In this example, the guard let statement ensures that the value is not nil. If it is nil, the function prints an error message and exits early using the return statement. Otherwise, it continues with the operation, multiplying the unwrappedValue by 2.\nAdvantages of using guard let: Readability: guard let enhances code readability by making the code more concise and reducing nested if statements. Early Exits: It encourages the practice of early exits from a function or block if necessary conditions are not met, leading to more structured and organized code. Safer Code: By forcing developers to handle the nil case upfront, guard let reduces the likelihood of runtime crashes due to unwrapping nil optionals. Improved Maintainability: The use of guard let allows you to handle edge cases efficiently, leading to more maintainable and future-proof code. Conclusion: In conclusion, guard let is a powerful tool that empowers Swift developers to handle optionals gracefully. By ensuring that optionals contain valid values and providing an elegant early exit strategy, guard let promotes code safety, readability, and maintainability. When dealing with optional values in Swift, remember to embrace the art of guard let to write clean, robust, and efficient code. Happy coding!\n","tags":["Swift"],"title":"guard let in Swift"},{"categories":["Blog"],"date":"July 21, 2023","permalink":"https://mahigarg.github.io/blogs/if-let-in-swift/","section":"blogs","summary":"if let - A Concise Way to Handle Optionals Introduction: Swift is known for its safety and strong typing, and one of its most powerful features is its handling of optionals. Optionals allow developers to express the possibility of a value being absent, preventing runtime crashes due to nil values. One of the key constructs used in Swift to work with optionals is the if let statement. In this blog, we will explore how if let can make your code cleaner and safer by safely unwrapping optionals in a concise manner.\nUnderstanding Optionals in Swift: Before diving into the if let statement, let\u0026rsquo;s quickly review optionals in Swift. An optional is a type that can either hold a value or be nil. It is represented by appending a question mark \u0026lsquo;?\u0026rsquo; after the type. For example, String? represents an optional String.\nHandling Optionals using if let:\nThe if let statement in Swift allows you to conditionally bind the optional to a non-optional temporary variable within the scope of the if block. It enables you to safely check for nil and simultaneously unwrap the optional\u0026rsquo;s value if it exists, avoiding the need for explicit unwrapping using if-else statements or forced unwrapping with the \u0026lsquo;!\u0026rsquo; operator.\nSyntax of if let: if let nonOptionalVar = optionalVar { // Code to be executed if optionalVar is not nil // nonOptionalVar is safely unwrapped and ready for use within this scope } else { // Code to be executed if optionalVar is nil } Example of if let: Let\u0026rsquo;s consider a simple example where we have an optional variable userName of type String?:\nlet userName: String? = \u0026#34;Mahi\u0026#34; if let name = userName { print(\u0026#34;Welcome, \\(name)\u0026#34;) } else { print(\u0026#34;No user name provided.\u0026#34;) } In this example, if userName contains a value (Mahi in this case), the if let statement binds the unwrapped value to the constant name, and the code inside the if block is executed. If userName is nil, the else block is executed.\nAdvantages of using if let: Safety: The if let statement ensures that you work with a valid, non-nil value. This significantly reduces the risk of runtime crashes caused by unwrapping nil values. Conciseness: if let provides a more concise way to handle optionals compared to traditional if-else or forced unwrapping approaches. Readability: The use of if let makes the code more readable and understandable as it clearly expresses the intent of safely unwrapping an optional. Scope: The unwrapped value is only available within the scope of the if block, ensuring that you won\u0026rsquo;t accidentally use it outside that scope, preventing potential bugs. Conclusion: The if let statement in Swift is a powerful and elegant way to handle optionals. It allows you to safely and concisely unwrap optional values, making your code safer and more readable. By leveraging if let, you can confidently work with optionals, avoiding the pitfalls of forced unwrapping and enhancing the overall robustness of your Swift codebase.\n","tags":["Swift"],"title":"if let in Swift"},{"categories":["Blog"],"date":"July 20, 2023","permalink":"https://mahigarg.github.io/blogs/navigation-swiftui/","section":"blogs","summary":"Navigation involves moving between different screens or views within an app. SwiftUI provides a navigation view hierarchy that allows users to navigate between different views seamlessly. The NavigationView is the container view that manages the navigation stack and provides a NavigationBar at the top to facilitate navigation.\nNavigationView NavigationView serves as the navigation container, hosting a hierarchy of views. At the top of the screen, it presents a navigation bar, which typically includes a back button for easy navigation to the previous view. You can also customize the appearance and behavior of the navigation bar to match your app\u0026rsquo;s style.\nWe will understand how to implement NavigationView and it various modifier. For same let us take an example of code and walk through it step by step.\nImplement NavigationView struct NavigationInSwiftUI: View { var body: some View { NavigationView { ScrollView(.vertical) { NavigationLink(\u0026#34;Navigaton Link\u0026#34;, destination: navigationPage) Text(\u0026#34;Home View\u0026#34;) } .navigationTitle(\u0026#34; Navigation Title\u0026#34;) .navigationBarTitleDisplayMode(.automatic) .navigationBarHidden(false) .navigationBarItems(leading: EditButton(), trailing: Image(systemName: \u0026#34;person.fill\u0026#34;)) } } } var navigationPage: some View { ZStack { Color.purple.edgesIgnoringSafeArea(.all) Text(\u0026#34;Hello World\u0026#34;) } .navigationTitle(\u0026#34; Navigated Page\u0026#34;) } Set Up Navigation Wrap your starting view (usually HomeView) with a NavigationView to set up the navigation hierarchy\nstruct NavigationInSwiftUI: View { var body: some View { NavigationView { ScrollView(.vertical) { Text(\u0026#34;Home View\u0026#34;) } } } } Create NavigationLink Within the HomeView, create a NavigationLink to navigate to the DetailView. Here, in NavigationLink(\u0026quot;Navigaton Link\u0026quot;, destination: navigationPage) Navigation Link is title displayed and destination i.e. navigationPage is the view to which user will navigate on taping Navigation Link\nstruct NavigationInSwiftUI: View { var body: some View { NavigationView { ScrollView(.vertical) { NavigationLink(\u0026#34;Navigaton Link\u0026#34;, destination: navigationPage) Text(\u0026#34;Home View\u0026#34;) } } } } var navigationPage: some View { ZStack { Color.purple.edgesIgnoringSafeArea(.all) Text(\u0026#34;Second Page\u0026#34;) } } NavigationBar Navigation View give navigation Bar as one of its characterstic, where title, left right navigation button can be configured.\nstruct NavigationInSwiftUI: View { var body: some View { NavigationView { ScrollView(.vertical) { NavigationLink(\u0026#34;Navigaton Link\u0026#34;, destination: navigationPage) Text(\u0026#34;Home View\u0026#34;) } } .navigationTitle(\u0026#34; Navigation Title\u0026#34;) .navigationBarTitleDisplayMode(.automatic) .navigationBarHidden(false) .navigationBarItems(leading: EditButton(), trailing: Image(systemName: \u0026#34;person.fill\u0026#34;)) } } navigationTitle navigationTitle will give title to view. 3 display modes for the navigation can be used via navigationBarTitleDisplayMode. These 3 modes are .automatic, .inline and .large.\nnavigationBar navigationBarHidden can be used with true as a parameter to hide the navigationBar. This is used when multiple navigation screen is used under same navigation View and navigation bar need to be hidden for some of them.\nAlso, left and right buttons can be used and given as view like Image(systemName: \u0026quot;person.fill\u0026quot;) using navigationBarItems.\nConclusion NavigationView is a powerful tool that simplifies navigation and enhances the user experience. Now we learned how to create a smooth and intuitive navigation flow. With SwiftUI\u0026rsquo;s NavigationView, we can create engaging and user-friendly apps, guiding users through your content effortlessly. So, dive into your SwiftUI projects and start navigating with style using NavigationView!\n","tags":["SwiftUI"],"title":"NavigationView in SwiftUI"},{"categories":["Gist"],"date":"July 18, 2023","permalink":"https://mahigarg.github.io/gists/bubble-sort-swift/","section":"gists","summary":"Bubble sort is a simple and straightforward sorting algorithm commonly used in computer science. In Swift language, Bubble sort works by repeatedly swapping adjacent elements if they are in the wrong order until the entire list is sorted. It has a time complexity of O(n^2), making it inefficient for large data sets. The algorithm iterates through the list multiple times, comparing and swapping elements. However, it is easy to understand and implement, making it suitable for small or nearly sorted arrays where simplicity is prioritized over efficiency. For larger data sets, more efficient sorting algorithms like QuickSort or MergeSort are preferred.\n","tags":["Programming-Basics"],"title":"Bubble Sort : Swift"},{"categories":["Blog"],"date":"July 18, 2023","permalink":"https://mahigarg.github.io/blogs/dictionary-swift/","section":"blogs","summary":"Dictionaries in Swift provide a key-value pair mechanism for efficient data storage and retrieval. They are implemented using hash tables, allowing fast access and modification of values based on keys. Dictionaries support operations like adding, removing, and iterating over elements. With constant time complexity for most operations, dictionaries are a powerful tool for organizing and managing data in Swift programming.\nLet us explore syntax, usage, and various operations that can be performed on dictionay.\nCreating a Dictionary: In Swift, dictionaries are represented by the Dictionary\u0026lt;Key, Value\u0026gt; type, or simply [Key: Value]. Time complexity for creating an empty dictionary is O(1). Here\u0026rsquo;s how you can create an empty dictionary or initialize it with values:\n// Empty Dictionary var emptyDictionary: [String: Int] = [:] // Initializing a Dictionary var fruits = [\u0026#34;apple\u0026#34;: 3, \u0026#34;banana\u0026#34;: 5, \u0026#34;orange\u0026#34;: 2] Accessing and Modifying Values: You can access values in a dictionary using their corresponding keys. If the key exists, the value will be returned; otherwise, it will return nil. Time complexity for accessing and modifying values in an dictionary is O(1). Here\u0026rsquo;s an example:\nlet numberOfApples = fruits[\u0026#34;apple\u0026#34;] // returns 3 // Modifying values fruits[\u0026#34;banana\u0026#34;] = 10 Adding and Removing Elements: To add elements to a dictionary, you can assign a value to a specific key. If the key already exists, the value will be updated; otherwise, a new key-value pair will be added. Removing elements can be done using the removeValue(forKey:) method. Time complexity of adding and removing element in dictionary is O(1). However, in some cases, the complexity can be O(n) due to the need to resize the underlying hash table. Examples:\nfruits[\u0026#34;kiwi\u0026#34;] = 4 // Adding a new element fruits.removeValue(forKey: \u0026#34;orange\u0026#34;) // Removing an element Iterating over a Dictionary: Swift provides several ways to iterate over the elements in a dictionary. You can use a for-in loop to access each key-value pair, or you can iterate over keys or values separately using the keys and values properties. Iterating over a dictionary has a time complexity of O(n), where n is the number of key-value pairs in the dictionary. This is because iterating requires visiting each element once. Here\u0026rsquo;s an example:\nfor (fruit, quantity) in fruits { print(\u0026#34;There are \\(quantity) \\(fruit)s\u0026#34;) } for fruit in fruits.keys { print(fruit) } for quantity in fruits.values { print(quantity) } Checking for the Existence of Keys and Values: To check if a key or value exists in a dictionary, you can use the contains(where:) method or the keys.contains(:) and values.contains(:) properties. Checking for the existence of keys or values in a dictionary has an average time complexity of O(1). This is due to the efficient lookup mechanism provided by the hash table implementation. Here\u0026rsquo;s an example:\nif fruits.contains(where: { $0.key == \u0026#34;apple\u0026#34; }) { print(\u0026#34;Apple exists\u0026#34;) } if fruits.values.contains(5) { print(\u0026#34;There is a fruit with quantity 5\u0026#34;) } Dictionary Operations and Properties: Swift dictionaries provide various operations and properties to work with. Some notable ones include:\ncount: Returns the number of key-value pairs in the dictionary. isEmpty: Returns a Boolean value indicating whether the dictionary is empty. keys: Returns a collection containing all the keys in the dictionary. values: Returns a collection containing all the values in the dictionary. merge(_:uniquingKeysWith:): Merges the given dictionary with the current dictionary. filter(_:): Returns a new dictionary containing the key-value pairs that satisfy the given predicate. Conclusion: Dictionaries are powerful data structures that allow you to store and retrieve values using a key-value pair mechanism. In Swift, dictionaries are easy to use and provide various operations for manipulating and accessing data efficiently. By understanding the concepts and techniques covered in this blog post, you are now equipped to work with dictionaries effectively in Swift. Happy coding!\n","tags":["Swift"],"title":"Dictionary: Swift"},{"categories":["Gist"],"date":"July 15, 2023","permalink":"https://mahigarg.github.io/gists/carousel-view-swiftui/","section":"gists","summary":"A carousel view is a user interface component commonly used in mobile and web applications to display a collection of items in a horizontally scrolling manner. It allows users to swipe or navigate through a set of images, cards, or other content. The carousel view typically presents a subset of items at a time, with the ability to cycle through the remaining items. It is an engaging and intuitive way to showcase multiple pieces of content within a limited space, providing an interactive and visually appealing user experience.\n","tags":["SwiftUI"],"title":"Carousel View : SwiftUI"},{"categories":["Gist"],"date":"July 13, 2023","permalink":"https://mahigarg.github.io/gists/linked-list-methods-swift/","section":"gists","summary":"A linked list is a data structure in Swift that consists of nodes linked together via pointers or references. Each node contains data and a reference to the next node. Unlike an array, a linked list does not require contiguous memory allocation. Insertions and deletions can be performed efficiently in a linked list by updating the pointers, but accessing elements requires traversing the list linearly. Linked lists are useful when frequent insertions or deletions are expected, and their time complexity for most operations is O(1) or O(n) depending on the operation.\n","tags":["Programming-Basics"],"title":"Linked List : Swift"},{"categories":["Gist"],"date":"July 11, 2023","permalink":"https://mahigarg.github.io/gists/remove-duplicate-array-swift/","section":"gists","summary":"To remove duplicates from an array in Swift using a dictionary, we can create an empty dictionary and iterate through the array. For each element, we use it as a key in the dictionary and assign a dummy value. The dictionary automatically removes duplicate keys, so we end up with only unique elements. The time complexity of this approach is O(n), where n is the number of elements in the array, making it an efficient solution for removing duplicates..\n","tags":["Programming-Basics"],"title":"Remove duplicates from array: Swift"},{"categories":["Blog"],"date":"July 9, 2023","permalink":"https://mahigarg.github.io/blogs/set-swift/","section":"blogs","summary":"A set is an unordered collection of unique elements, meaning it does not allow duplicates. Swift\u0026rsquo;s Set data type ensures that each element occurs only once in the collection. You can think of sets as a mathematical set, where the order of elements does not matter, and there are no duplicate elements. Swift\u0026rsquo;s Set data type uses hash tables internally to store elements, which allows for fast access and modification. This is the reason time complexity for set operation is much better than array.\nLet us explore syntax, usage, time complexity and various operations that can be performed on sets.\nCreating a Set: In Swift, In Swift, you can create a set using the Set keyword, specifying the type of elements the set will hold. Here\u0026rsquo;s an example of creating a set of integers:\nvar integerSet: Set\u0026lt;Int\u0026gt; = [1, 2, 3, 4, 5] Alternatively, you can use type inference to let Swift deduce the type of the set:\nvar anotherSet = Set\u0026lt;String\u0026gt;() anotherSet.insert(\u0026#34;apple\u0026#34;) anotherSet.insert(\u0026#34;banana\u0026#34;) anotherSet.insert(\u0026#34;orange\u0026#34;) Insertion and Deletion To add elements to a set, you can use the insert(_:) method. Insertion and deletion in sets have an average-case time complexity of O(1). Examples:\nvar mySet = Set\u0026lt;Character\u0026gt;() mySet.insert(\u0026#34;a\u0026#34;) mySet.insert(\u0026#34;b\u0026#34;) Membership Test To check if an element exists in a set, you can use the contains(_:) method: Examples:\nif mySet.contains(\u0026#34;a\u0026#34;) { print(\u0026#34;The set contains \u0026#39;a\u0026#39;.\u0026#34;) } else { print(\u0026#34;The set does not contain \u0026#39;a\u0026#39;.\u0026#34;) } Set Operations (Union, Intersection, Difference, Subset) Sets also support various set operations such as union, intersection, difference, and subset checks. Union, intersection, and difference operations have an average-case time complexity of O(m), where m is the number of elements in the smaller set. Swift uses an efficient algorithm to compute these operations, leveraging the benefits of hash tables. The isSubset(of:) method also has an average-case time complexity of O(m), where m is the number of elements in the subset being checked. Here\u0026rsquo;s an example:\nlet set1: Set\u0026lt;Int\u0026gt; = [1, 2, 3, 4] let set2: Set\u0026lt;Int\u0026gt; = [3, 4, 5, 6] let unionSet = set1.union(set2) // {1, 2, 3, 4, 5, 6} let intersectionSet = set1.intersection(set2) // {3, 4} let differenceSet = set1.subtracting(set2) // {1, 2} let isSubset = set1.isSubset(of: set2) // false Conclusion: In conclusion, sets are a powerful data structure for managing collections of unique elements. Swift\u0026rsquo;s Set data type provides efficient insertion, deletion, and membership test operations with an average-case time complexity of O(1). Additionally, set operations like union, intersection, and difference, as well as subset checks, have an average-case time complexity of O(m), where m is the number of elements in the smaller set involved in the operation. Happy coding!\n","tags":["Swift"],"title":"Set: Swift"},{"categories":["Gist"],"date":"July 8, 2023","permalink":"https://mahigarg.github.io/gists/binary-serach-swift/","section":"gists","summary":"Binary search is an efficient search algorithm used to locate a specific element in a sorted array or list. It works by repeatedly dividing the search space in half until the target element is found. In Swift, binary search is typically implemented recursively or iteratively. The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it highly efficient for large data sets as it eliminates half of the remaining search space at each step, significantly reducing the search time.\n","tags":["Programming-Basics"],"title":"Binary Serach : Swift"},{"categories":["Gist"],"date":"July 8, 2023","permalink":"https://mahigarg.github.io/gists/merge-array-swift/","section":"gists","summary":"Merging two sorted Int arrays in Swift means combining them into a single sorted array while preserving the order. With Swift, you can efficiently implement the merging algorithm. By comparing elements in both arrays and arranging them accordingly, you\u0026rsquo;ll obtain a new sorted array. This process ensures that the elements from both arrays are in ascending order, allowing you to organize your data effectively. The merged sorted Int array can be readily used in your Swift app for various purposes like displaying sorted lists or conducting efficient searches.\n","tags":["Programming-Basics"],"title":"Merge 2 sorted Array: Swift"},{"categories":["Gist"],"date":"July 8, 2023","permalink":"https://mahigarg.github.io/gists/merge-linked-list-swift/","section":"gists","summary":"Merging two sorted linked lists in Swift is like combining two ordered lists into one, while still maintaining the sorted order. You can use Swift to define the linked list structure and implement a merging algorithm. By comparing the elements in both lists and arranging them accordingly, you\u0026rsquo;ll create a new sorted linked list. This process ensures that the elements from both lists are in ascending order, resulting in a single, sorted, and merged linked list that you can use in your Swift app for efficient data organization.\n","tags":["Programming-Basics"],"title":"Merge 2 sorted Linked List: Swift"},{"categories":["Gist"],"date":"July 5, 2023","permalink":"https://mahigarg.github.io/gists/instagram-post-swiftui/","section":"gists","summary":"Coding an Instagram post in SwiftUI is an engaging project. You can use various components like images, text, and buttons to design a post layout. With SwiftUI\u0026rsquo;s simple syntax and powerful features, you can easily arrange the content and customize the post\u0026rsquo;s appearance. Adding interactive features like like and comment buttons makes the post come alive. It\u0026rsquo;s a fun way to learn SwiftUI and create your own unique Instagram-style posts, perfect for displaying your creativity or sharing with friends on social media.\n","tags":["SwiftUI"],"title":"Instagram Post : SwiftUI"},{"categories":["Gist"],"date":"July 3, 2023","permalink":"https://mahigarg.github.io/gists/instagram-logo-swiftui/","section":"gists","summary":"Creating the Instagram logo in SwiftUI is an exciting task. Using basic shapes like circles, squares, and colors, you can piece together the iconic camera symbol and colorful gradient background. With SwiftUI\u0026rsquo;s user-friendly syntax and pre-built shape modifiers, you\u0026rsquo;ll enjoy a smooth coding experience. By combining shapes and arranging them creatively, you can replicate the recognizable Instagram logo, ready to be used in your own SwiftUI projects or to explore your coding creativity. Have fun and unleash your artistic side while coding this popular logo!\n","tags":["SwiftUI"],"title":"Instagarm Logo : SwiftUI"},{"categories":["Gist"],"date":"July 2, 2023","permalink":"https://mahigarg.github.io/gists/insertion-sort-swift/","section":"gists","summary":"Insertion sort is a simple sorting algorithm in Swift that builds the final sorted array one element at a time. It iterates through the array, comparing each element with the sorted portion and placing it in the correct position. This process continues until all elements are sorted. Insertion sort has a time complexity of O(n^2) in the worst case, but it performs well on small data sets or partially sorted arrays. It also has an advantage in that it can efficiently sort elements in real-time as they are received or generated.\n","tags":["Programming-Basics"],"title":"Insertion Sort : Swift"},{"categories":["Blog"],"date":"June 29, 2023","permalink":"https://mahigarg.github.io/blogs/state-swiftui/","section":"blogs","summary":"In SwiftUI, a powerful framework for building user interfaces, managing and updating the state of our views is essential for creating dynamic and interactive user experiences. One key tool SwiftUI provides for this purpose is the @State property wrapper.\nNow let us understand what is @State, how it works, what we can achieve through this, and much more.\nWhat is @State? The @State property wrapper is a fundamental component of SwiftUI that allows us to declare mutable state properties within a view. When the value of @State property changes, SwiftUI automatically re-renders the view, ensuring that the UI stays synchronized with the underlying state.\nLet us understand this with an example.\nConsider you want to change the background color of your view with a few button clicks. please have a look at the below code where we will understand its declaration and usage part as well.\nstruct stateBootCamp: View { @State var backgroundColor = Color.red var body: some View { ZStack { backgroundColor VStack(spacing: 20) { Text(\u0026#34;Studing @State\u0026#34;) .font(.title) Button(\u0026#34;BUTTON Green\u0026#34;) { backgroundColor = .green } Button(\u0026#34;BUTTON Pink\u0026#34;) { backgroundColor = .pink } } .foregroundColor(.white) } } } To declare, prefix @State to property declaration. Above we made backgroundColor a state property.\nNow let us understand it\u0026rsquo;s working.\nThe first view is your Initial View in zero state. When you tap on BUTTON Green, the background color changes to green as we are changing the state variable color to Green as the action of Button. Similarly, on Tap of BUTTON Pink, the background color changes to Pink. With this, we understood how @State is used.\nUsage scenario of @State @State is best suited for managing a state within a single view or a small portion of the view hierarchy. It works well for a local, transient state that doesn\u0026rsquo;t need to be shared across multiple views or persisted across sessions.\nLimitation of @State @State not suitable for managing states across multiple views or when sharing states between different parts of an application. In such cases, @ObservedObject or @EnvironmentObject maybe more appropriate choices. By leveraging @State, SwiftUI empowers developers to build modern, responsive applications that are efficient, maintainable, and delightful to use.\n","tags":["SwiftUI"],"title":"@State: SwiftUI"},{"categories":["Gist"],"date":"June 28, 2023","permalink":"https://mahigarg.github.io/gists/selection-sort-swift/","section":"gists","summary":"Selection sort is a sorting algorithm in Swift that works by repeatedly finding the minimum element from the unsorted portion of an array and swapping it with the element in the correct position. This process is iterated until the entire array is sorted. While simple to understand and implement, selection sort has a time complexity of O(n^2), making it inefficient for large data sets. However, it has the advantage of having a minimal number of swaps, which can be beneficial in certain memory-constrained scenarios.\n","tags":["Programming-Basics"],"title":"Selection Sort : Swift"},{"categories":["Gist"],"date":"June 23, 2023","permalink":"https://mahigarg.github.io/gists/dutch-national-flag-swift/","section":"gists","summary":"The Dutch National Flag algorithm is a sorting algorithm that partitions an array into three sections: elements less than a given pivot, elements equal to the pivot, and elements greater than the pivot. In Swift, we can implement this algorithm by maintaining three pointers and swapping elements accordingly. The time complexity of the Dutch National Flag algorithm is O(n), where n is the number of elements in the array. It is an efficient algorithm for sorting arrays with a limited range of values, like sorting colors or other categorical data.\n","tags":["Programming-Basics"],"title":"Dutch National Flag : Sort Int Array of 0, 1 and 2 : Swift"},{"categories":["Gist"],"date":"June 20, 2023","permalink":"https://mahigarg.github.io/gists/list-swiftui/","section":"gists","summary":"In SwiftUI, the List is a powerful tool for creating neat and organized scrolling lists in apps. Imagine it as a virtual scrollable sheet of paper where you can display various items, like names, messages, or to-do tasks. It automatically adjusts its content, so you don\u0026rsquo;t need to worry about updating the list when things change. Whether you want to showcase a bunch of contacts or a menu with different options, List makes it simple and user-friendly. Users can smoothly scroll through the content, making it easy for them to find and interact with the information you present.\n","tags":["SwiftUI"],"title":"List: SwiftUI"},{"categories":["Blog"],"date":"April 25, 2023","permalink":"https://mahigarg.github.io/blogs/closures-swift/","section":"blogs","summary":"Closures are a powerful feature of the Swift programming language that allows you to write code that can be passed around and executed at a later time. They are self-contained blocks of functionality.\nClosures are commonly used in Swift to perform tasks like sorting and filtering collections and for handling asynchronous tasks.\nSyntax:\nA closure is defined using curly braces { } and can take in one or more arguments, and returns a value. Here’s a basic syntax of a closure:\n{ (params) -\u0026gt; return type in // Statement } params — any value passed to the closure returnType — specifies the type of value returned by the closure in (optional) — used to separate parameters/returnType from the closure body Statement — code to be executed. Closures need not have the first 3 always. Find the below examples supporting the statement.\nvar sayHi = { print(\u0026#34;Hey!\u0026#34;) } // call the closure sayHi() // output is Hey! This example of closure prints a string. It doesn’t require any parameters. It doesn’t return anything. It just has a single line of code to execute.\nNow let us see other examples of closure where we have either a parameter or a return type.\nlet sayHi = { (name: String) in print(\u0026#34;Hey!, \\(name).\u0026#34;) } // closure call sayHi(\u0026#34;Mahi\u0026#34;) // output is Hey!, Mahi let taskCompleted = { ()-\u0026gt; String in return \u0026#34;Bravo You Are Done!\u0026#34; } // closure call print(taskCompleted()) // output is Bravo You Are Done! Hope you have understood what is closure. How to write closure in Swift. Now let us move to the usage of closure in Swift.\nNow let us consider a block of code that needs to be executed after the method has completed its task. Let us have a look below for example.\nfunc add(first: Int, second: Int, completion: (Int) -\u0026gt; String) { let sum = first + second print(completion(sum)) } add(first: 4, second: 56) { result in return \u0026#34;result is \\(result)\u0026#34; } // output is result is 60 add(first: 4, second: 56) { result in return \u0026#34;sum is \\(result)\u0026#34; } // output is sum is 60 Here method add takes 2 integers and 1 closure as arguments. It performs the sum of 2 numbers. After the addition is done it calls the closure to print the result according to the code written in the closure.\nHere, the first method call defines the closure to return the string “result is 60” while the second return the string “sum is 60”. So we can conclude that closure also gives the power to the method to execute a different set of code depending on where it is called.\n","tags":["Swift"],"title":"Closures: Swift"},{"categories":["Blog"],"date":"August 22, 2022","permalink":"https://mahigarg.github.io/blogs/for-loop-with-where-clause-swift/","section":"blogs","summary":"For loop is an inevitable part of any programming language. It iterates over every element of the collection type data including array, set, and dictionary, and does the operation as per the code.\nLet us see an example of the same. Consider an array of integers and a for loop accessing its even integers.\n//array example let numbers = [23,62,6,12,87,55,45,22] //for loop for number in numbers { print(number) } Above swift code will print all integers in the array. But sometimes we need only elements on certain conditions like even number, or positive number. This can be achieved by giving a where clause with the for loop body.\nLet us see the code for filtering even numbers.\n//for loop with where for number in numbers where number % 2 == 0 { print(number) } // print 62 6 12 22 Here data is filtered according to where clause i.e., only even numbers will be printed. Similarly, we can filter data on more than one condition using (||) or and (\u0026amp;\u0026amp;) depending on the use case.\nLet us look at this with an example.\n//for loop with where for number in numbers where number % 2 == 0 || number \u0026gt; 50 { print(number) } // 62 6 12 87 55 22 Here data is filtered according to where clause i.e., even numbers or numbers greater than 50 will be printed.\nNow let us consider case printing numbers that are even and greater than 50.\n//for loop with where for number in numbers where number % 2 == 0 \u0026amp;\u0026amp; number \u0026gt; 50 { print(number) } // prints even numbers and number greater than 50 // 62 Here data is filtered according to where clause i.e. even numbers and numbers greater than 50 will be printed.\n","tags":["Swift"],"title":"For loop with where clause: Swift"},{"categories":["Blog"],"date":"August 16, 2022","permalink":"https://mahigarg.github.io/blogs/round-up-to-n-decimal-digit-swift/","section":"blogs","summary":"We sometimes in our calculation get results with more than 4 decimal digits or even more. But as a developer, we can’t use the same to display to users.\nImagine we have a dashboard application that displays monthly tax on an employee\u0026rsquo;s salary. And it is coming as 630.6152. This doesn’t look good at all to say the same. It will be better to show it like 630.62 or 630.61 i.e., rounding it to n Decimal Digit.\nLet us take a look at how this can be done.\nIf we say round up to n Decimal Digits where n equals 2. Then we need to follow the below steps\nMultiply it by 100 (10^n) Use round, floor, or ceil to remove the extra digits Divide by 100 (10^n) Round to n digits using the round function //after calculation tax = 630.6152 //multiply with 100 var result = tax * 100 //63061.52 //Using round to remove extra digit roundresult = round(result) //63062 //divide by 100 result = result/ 100 print (result) //630.62 print(evenNumbers) Here tax 630.6152 is rounded to 630.62 as the third decimal digit is 5.\nLet us consider example 437.1932. Here 3 is the third decimal digit.\n//after calculation tax = 437.1932 //multiply with 100 var result = tax * 100 //43719.32 //Using round to remove extra digit roundresult = round(result) //43719 //divide by 100 result = result/ 100 print (result) //437.19 On comparing the result of both the example, we can see the result depends on the decimal digits we have. If the third digit is between 1 to 4, then it will keep the existing previous results (437.1932 -\u0026gt; 437.19) but in the case of digits between 5–9, it increases the last digit (630.6152 -\u0026gt; 630.61).\nNow let us see how our output will be impacted if we use the floor or ceil function instead of round.\nRound to n digits using the floor function Considering the same example here. Tax after calculation equals 630.6152.\n//after calculation tax = 630.6152 //multiply with 100 var result = tax * 100 //63061.52 //Using floor to remove extra digit floorResult = floor(result) //63061 //divide by 100 floorResult = floorResult / 100 print (floorResult) //630.61 Here, we saw floor will step down the result irrespective of the digit we have at the third position, be it 1 or 9 it will always take you to the nearest smallest number.\nRound to n digits using the ceil function Here, let us alter our example to 630.6122 and see how our results vary.\n//after calculation tax = 630.6122 //multiply with 100 var result = tax * 100 //63061.22 //Using ceil to remove extra digit ceilResult = ceil(result) //63062 //divide by 100 ceilResult = ceilResult / 100 print (ceilResult) //630.62 Here, we saw ceil will step up the result irrespective of the digit we have at the third position, be it anything between 1 to 9 it will always take you to the nearest largest number.\n","tags":["Swift"],"title":"Round up to n Decimal Digit: Swift"},{"categories":["Blog"],"date":"May 31, 2022","permalink":"https://mahigarg.github.io/blogs/setup-firebase-remoteconfig/","section":"blogs","summary":"In continuation with the previous article stating the benefits and working of Firebase RemoteConfig, this article will help you to set up Firebase step by step. Additionally, it will tell you how to configure the remoteConfig Parameter and fetch and Apply the configuration to your app.\nStep 1: Setting Up Firebase RemoteConfig: 1.1 Create a Firebase Project: Start by creating a Firebase project through the Firebase console. Follow the provided instructions to set up your project, including adding the necessary dependencies to your app.\n1.2 Enable RemoteConfig: In the Firebase console, navigate to the RemoteConfig section and enable it for your project. This will allow you to define and manage remote configurations for your app.\nStep 2: Configuring Remote Parameters: 2.1 Define Parameters: Within the RemoteConfig section of the Firebase console, define the parameters you want to configure remotely. These parameters can include strings, booleans, numbers, or JSON objects. Set default values for each parameter to ensure that your app has fallback values in case the remote configurations are not yet fetched.\n2.2 Add Conditions (Optional): To target specific user segments or conditions, you can add conditions to your parameters. For example, you can define a condition based on the user’s country, app version, or any other custom criteria. This allows you to tailor the configurations for different user segments.\nStep 3: Fetching and Applying Configurations: 3.1 Initialize RemoteConfig: In your app’s code, initialize the RemoteConfig instance by obtaining a reference to it from the Firebase SDK. This allows you to interact with the RemoteConfig service.\n3.2 Fetch Configurations: To fetch the remote configurations, call the fetch() method on the RemoteConfig instance. You can specify a cache expiration duration to control how frequently the configurations should be refreshed. Firebase provides options for using a minimum fetch interval or manual fetch.\n3.3 Apply Configurations: After fetching the configurations, call the activate() method to apply the fetched configurations to your app. This ensures that the app\u0026rsquo;s behavior aligns with the remote settings.\nStep 4: Remote Configuration Updates: 4.1 Modify Configurations: To update the configurations remotely, make changes within the Firebase console. You can modify parameter values, add new parameters, or adjust conditions.\n4.2 Publish Configurations: After making the necessary changes, publish the configurations from the Firebase console. Publishing makes the updated configurations available to your app during the next fetch.\nStep 5: Testing and Monitoring: 5.1 Test Configurations: Before deploying the configurations to all users, test them thoroughly to ensure they function as expected. Consider creating a test environment or using Firebase’s remote conditions to target a small group of users for testing purposes.\n5.2 Monitor Performance: Leverage Firebase Analytics to track the impact of configuration changes on user behavior, engagement, and other relevant metrics. This helps you understand the effectiveness of your configurations and make data-driven decisions for optimization.\n","tags":["Firebase"],"title":"Setup Firebase RemoteConfig"},{"categories":["Blog"],"date":"May 30, 2022","permalink":"https://mahigarg.github.io/blogs/map-operator-swift/","section":"blogs","summary":"The collection is something which is used by almost everyone. It makes our life easy. Array, Set, and Dictionary are the best examples of them.\nTo iterate, filter, or modify the existing collection object, Swift provides us with a few in builds transform operators. Map operator is one of them. Let’s try to understand the Map operator in detail.\nWhat is Map operator? Map operator is used to creating a new collection object by iterating over the existing collection object and applying some transformation to it.\nThe transformation that needs to be applied, is passed as a higher-order function named transform to the map function.\nSince the map operator is present in Iterator, it can be used with all three collections ie Array, Set, and Dictionary.\n/// Returns an array containing the results of mapping the given closure over the sequence\u0026#39;s elements. /// - Parameter transform: A mapping closure. `transform` accepts an /// element of this sequence as its parameter and returns a transformed value of the same or of a different type. /// - Returns: An array containing the transformed elements of this sequence. @inlinable public func map\u0026lt;T\u0026gt;(_ transform: (Element) throws -\u0026gt; T) rethrows -\u0026gt; [T] Keep in mind, that this map function never holds the exceptions but it throws them to the caller. If there are any chances of any kind of exception at runtime, we need to wrap this inside a try-catch block.\nMap with Array map operator can be used over an Array to apply the transformation on its elements and return the new Array. It can be used with a named parameter or using $0.\nlet array = [1, 2, 3, 4, 5, 6] let mappedArray = array.map { item in //this will convert all the elements to its square item * item } //or let mappedArray = array.map { //this will convert all the elements to its square $0 * $0 } print(mappedArray) It can also be used with enumerated for positional-based access.\nlet array = [1, 2, 3, 4, 5, 6] let mappedArray = array.enumerated().map { index, item in //this will convert all the elements to its square item * item } //or let mappedArray = arrayenumerated.map { //this will convert all the elements to its square $1 * $1 } print(mappedArray) Map with Set Similar to Array, the map operator can be used along with a Set to iterate over its elements, apply some transformation on its elements and return the new Set. It can be used with a named parameter or using $0.\nlet set : Set = [1, 2, 3, 4, 5, 6] let filteredSet = set.map { item in item * item } //or let filteredSet = set.map { $0 * $0 } print(filteredSet) There is no point in using an enumerated map with the Set as it never guarantees the sequence in a Set.\nMap with Dictionary Similar to Array and Set, the map operator can be used over a Dictionary to iterate over the Dictionary, apply some transformation to its elements and return the new Dictionary. It can be used with a named parameter or using $0.\nlet map = [1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;] let filteredMap = map.map { item in (item.key, item.value.uppercased()) } //or let filteredMap = map.map { ($0.key, $0.value.uppercased()) } print(filteredMap) There is no point in using an enumerated map with the Dictionary as it never guarantees the sequence in a Dictionary.\n","tags":["Swift"],"title":"Map Operator: Swift"},{"categories":["Blog"],"date":"May 29, 2022","permalink":"https://mahigarg.github.io/blogs/0-1-n-in-swift/","section":"blogs","summary":"In order to use any parameter in a closure or a higher-order function, we need to name the parameter inside the closure or higher-order function.\nThe syntax looks like the below.\nlet array = [1, 2, 3, 4, 5, 6] let evenNumbers = array.filter { item in item % 2 == 0 } print(evenNumbers) This filter function takes a single argument which is another function that is of (Int) -\u0026gt; Bool type. The inner function takes every element of the array one by one and checks if that is an even number or not. It returns true if the condition is true else it returns false.\nThe parameter passed inside the function can be replaced with $0.\n$0 represents the first parameter of closure or higher-order function.\nIt can be used with both closers or higher-order functions.\nThe same syntax will look like below.\nlet array = [1, 2, 3, 4, 5, 6] let evenNumbers = array.filter { $0 % 2 == 0 } print(evenNumbers) In case the number of parameters are more than one,\n$0, $1 up to $n can be used.\nFor example, look at the below case where there are two parameters passed to the higher-order function namely index and item.\nlet array = [1, 2, 3, 4, 5, 6] let filterArray = array.enumerated().filter {index, item in //I am doing some rocket science here print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) return index != 2 \u0026amp;\u0026amp; item % 2 == 0 } print(filterArray) We can use $0 for index and $1 for item in the same example.\nlet array = [1, 2, 3, 4, 5, 6] let filterArray = array.enumerated().filter { //I am doing some rocket science here print(\u0026#34;Item at \\($0) is \\($1)\u0026#34;) return $0 != 2 \u0026amp;\u0026amp; $1 % 2 == 0 } print(filterArray) These numbers can go up to any number of parameters passed to the inner function.\nI’ll personally suggest using named parameters if the parameters are more than three as it\u0026rsquo;s difficult to remember which $ variable is what. Up to three is really helpful.\n","tags":["Swift"],"title":"$0, $1 … $n in Swift"},{"categories":["Blog"],"date":"May 29, 2022","permalink":"https://mahigarg.github.io/blogs/filter-operator-swift/","section":"blogs","summary":"The collection is something which is used by almost everyone. It makes our life easy. Array, Set, and Dictionary are the best examples of them.\nTo iterate, filter, or modify the existing collection object, Swift provides us with a few in builds transform operators. Filter operator is one of them. Let\u0026rsquo;s try to understand the filter operator in detail.\nWhat is filter operator? The filter operator is used to create a new collection object by iterating over the existing collection object and filtering the elements based on the predicates to it.\nThe predicate that needs to be checked for, is passed as a higher-order function named isIncluded to the filter function.\nSince the filter operator is present in Iterator, it can be used with all three collections ie Array, Set, and Dictionary.\n/// Returns an array containing, in order, the elements of the sequence that satisfy the given predicate. /// - Parameter isIncluded: A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array. /// - Returns: An array of the elements that `isIncluded` allowed. /// - Complexity: O(*n*), where *n* is the length of the sequence. @inlinable public func filter(_ isIncluded: (Iterator.Element) throws -\u0026gt; Bool) rethrows -\u0026gt; [Iterator.Element] Keep in mind, that this filter function never holds the exceptions but it throws them to the caller. If there are any chances of any kind of exception at runtime, we need to wrap this inside a try-catch block.\nFilter with Array filter operator can be used over an Array to check the predicate on its elements and return the filtered Array. It can be used with a named parameter or using $0.\nlet array = [1, 2, 3, 4, 5, 6] let filteredArray = array.filter { item in item % 2 == 0 } //or let filteredArray = array.filter { $0 % 2 == 0 } print(filteredArray) It can also be used with enumerated for positional-based access.\nlet array = [1, 2, 3, 4, 5, 6] let filteredArray = array.enumerated().filter {index, item in //I am doing some rocket science here print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) return index != 2 \u0026amp;\u0026amp; item % 2 == 0 } //or let filteredArray = array.enumerated().filter { //I am doing some rocket science here print(\u0026#34;Item at \\($0) is \\($1)\u0026#34;) return $0 != 2 \u0026amp;\u0026amp; $1 % 2 == 0 } print(filteredArray) Filter with Set Similar to Array, the filter operator can be used over a Set to check the predicate on its elements and return the filtered Set. It can be used with a named parameter or using $0.\nlet set = [1, 2, 3, 4, 5, 6] let filteredSet = set.filter { item in item % 2 == 0 } //or let filteredSet = set.filter { $0 % 2 == 0 } print(filteredSet) There is no point in using an enumerated filter with the Set as it never guarantees the sequence in a Set.\nFilter with Dictionary Similar to Array and Set, the filter operator can be used over a Dictionary to check the predicate on its elements and return the filtered Dictionary. It can be used with a named parameter or using $0.\nlet map = [1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;] let filteredMap = map.filter { item in item.key % 2 == 0 } //or let filteredMap = map.filter { $0.key % 2 == 0 } print(filteredMap) There is no point in using an enumerated filter with the Dictionary as it never guarantees the sequence in a Dictionary.\n","tags":["Swift"],"title":"Filter Operator: Swift"},{"categories":["Blog"],"date":"May 28, 2022","permalink":"https://mahigarg.github.io/blogs/enumerated-in-swift/","section":"blogs","summary":"Enumerated is used to iterate over a collection along with the position access. It returns a sequence of Pairs where the first element in the Pair is the index and the second element is the element itself of the collection.\nEnumerated is useful when we want to access the position along with making any iteration, filtration or even mapping of the objects of a collection.\nLets look at its definition first.\n/* Returns a sequence of pairs (*n*, *x*), where *n* represents a consecutive integer starting at zero and *x* represents an element of the sequence. */ @inlinable public func enumerated() -\u0026gt; EnumeratedSequence\u0026lt;Array\u0026lt;Element\u0026gt;\u0026gt; Enumerated best use case is with an array.\nlet array = [1, 2, 3, 4, 5] for (index, item) in array.enumerated() { print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) } It can also be used with set and map but the order of insertion is not guaranteed in both set and map.\nlet set = [1, 2, 3, 4, 5] for (index, item) in set.enumerated() { print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) } let map = [1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;] for (index, item) in map.enumerated() { print(\u0026#34;Item at \\(index) is key: \\(item.key) value: \\(item.value)\u0026#34;) } Enumerated can also be used to iterate over a string with the sequence of Pairs of the index and the respective character at that index.\nfor (index, item) in \u0026#34;Swift\u0026#34;.enumerated() { print(\u0026#34;Item at \\(index) is \\(item)\u0026#34;) } //this will print Item at 0 is S Item at 1 is w Item at 2 is i Item at 3 is f Item at 4 is t There is no need to convert the string to a char array first and then iterate over it. The Enumerated function will take care of it.\n","tags":["Swift"],"title":"Enumerated in Swift"},{"categories":["Blog"],"date":"May 28, 2022","permalink":"https://mahigarg.github.io/blogs/named-and-unnamed-parameters-swift/","section":"blogs","summary":"Functions are something that every developer uses daily. A function can of with or without parameters. Swift has multiple ways of passing the parameters to a function. we can alias the parameter name or we can even skip the parameter name while calling the function.\nThe parameter inside the function will still be used by its own name only but while calling the function, the name of the parameter can be replaced or even removed based on the function signature.\nLet\u0026rsquo;s look at them one by one.\nBelow is a normal function with a single parameter and calling it using the parameter name\nfunc doSomething(number : Int){ //I\u0026#39;ll do some rocket science here, //and at the end, will just print the param print (number) } doSomething(number: 100) In order to call the above function, we need to write the parameter name. In the above case the parameter name was number .\nSometimes it\u0026rsquo;s tedious to write the parameter name again and again or sometimes the function name itself is enough to make understand what that function is responsible for.\nIn those cases, in order to skip the parameter name every time we call that function, it can be preceded with an underscore _ which will make the parameter name unnamed.\nfunc doSomethingWithNumber(_ number : Int){ //I\u0026#39;ll do some rocket science here, //and at the end, will just print the param print (number) } doSomethingWithNumber(100) Here in the above example, we added an underscore _ in front of the parameter name which made the parameter unnamed. In order to call this function now, we don’t have to add the parameter name ie number in our case.\nKeep in mind that we can’t even use the parameter name now. Underscore _ doesn’t make it optional but it actually made it unnamed.\nWe can even provide an alias to the parameter after which the parameter will be used with the new alias name instead of the original parameter name.\nfunc doSomething(with number : Int){ //I\u0026#39;ll do some rocket science here, //and at the end, will just print the param print (number) } doSomething(with: 100) In the above example, we added with as an alias name for the parameter. Now in order to call this function, we need to use with as the parameter name instead of number.\nKeep in mind that this is not optional to use as a parameter name but it is mandatory.\nAlso, in all the cases, the parameter inside that function will still be used as its own name only. There is no change in that.\n","tags":["Swift"],"title":"Named and Unnamed Parameters: Swift"},{"categories":["Blog"],"date":"May 28, 2022","permalink":"https://mahigarg.github.io/blogs/remoteconfig-in-firebase/","section":"blogs","summary":"In today’s fast-paced world, mobile app developers must adapt quickly to changing user preferences, market demands, and evolving business requirements. To achieve this, developers need a robust mechanism to configure apps remotely without frequent updates. Firebase RemoteConfig is a powerful tool offered by Google Firebase. It enables developers to dynamically update app settings, content, and feature flags from a centralized console, allowing them to deliver a personalized and tailored experience to the users.\nWhat is Firebase RemoteConfig? Firebase RemoteConfig is a cloud-based service that allows developers to change the behavior and appearance of their mobile applications without requiring users to update their apps. It provides a simple and efficient way to manage configurable parameters such as feature flags, strings, numbers, and even remote JSON files. With RemoteConfig, developers can fine-tune their app’s behavior, perform A/B testing, and target specific user segments based on dynamic conditions.\nBenefits of Using RemoteConfig: 2.1 Real-time Configuration Updates: Firebase RemoteConfig enables developers to update app configurations in real time, eliminating the need for app updates. This capability empowers developers to react swiftly to changing requirements, fix bugs, and introduce new features without disrupting the user experience.\n2.2 Personalization and A/B Testing: With RemoteConfig, developers can define configurations for specific user segments or conduct A/B tests to evaluate the impact of various settings on user engagement and conversion rates. This allows for data-driven decision-making and personalized experiences tailored to each user.\n2.3 Gradual Rollouts and Phased Feature Launches: RemoteConfig supports gradual rollouts of new features by allowing developers to target a subset of users with specific configurations. By releasing features incrementally, developers can gather feedback, monitor performance, and ensure a smooth rollout for all users.\n2.4 Simplified Maintenance: By centralizing configuration management in a web-based console, RemoteConfig simplifies the maintenance process. Developers can modify configurations, set default values, and monitor the usage and impact of different settings, all from a single location.\nWorking with RemoteConfig: 3.1 Configuration Setup: Developers define configuration parameters, their default values, and any associated conditions within the Firebase console. These parameters are stored in the Firebase backend and can be easily updated without requiring app updates.\n3.2 Fetching and Applying Configurations: The mobile app fetches the latest configurations from the Firebase backend during runtime. RemoteConfig provides a simple API to fetch and apply configurations within the app, ensuring that the app’s behavior adapts to the latest settings.\n3.3 Conditions and Targeting: RemoteConfig supports conditional configurations based on various criteria such as app version, language, country, user properties, or custom conditions defined by developers. This allows for precise targeting and tailoring of experiences to different user segments.\nBest Practices and Considerations: 4.1 Testing and Validation: Thoroughly test and validate configuration changes before rolling them out to ensure they function as intended and do not negatively impact the app’s stability or performance.\n4.2 Version Control: Maintain a version control system or use Firebase’s history feature to track and revert configuration changes if necessary, ensuring better accountability and easy rollback options.\n4.3 Monitoring and Analytics: Leverage Firebase Analytics to track the impact of configuration changes on user behavior, engagement, and conversion rates. Monitor performance and iterate on configurations to optimize the user experience continually.\nConclusion: Firebase RemoteConfig empowers mobile app developers with a flexible and efficient mechanism to manage remote configurations, allowing them to adapt quickly to changing requirements and deliver personalized experiences to their users. By leveraging RemoteConfig’s real-time updates, targeted structures, and simplified maintenance.\n","tags":["Firebase"],"title":"RemoteConfig in Firebase"},{"categories":["Blog"],"date":"May 23, 2022","permalink":"https://mahigarg.github.io/blogs/labeled-statement-swift/","section":"blogs","summary":"Swift has a few inbuilt features which make our life super easy. Labeled statements are one of them. It allows us to name a statement and later within the scope, that particular statement can be referenced using the label provided.\nLet me explain this using an example. Assume we have a nested loop inside another loop. We want to break the inner as well as out loop on some condition.\nfor i in 0...5 { for j in 0...5 { print (i + j) //break from outer loop if i + j == 5 } } Break statement can help here but break statement only works for immediate loop.\nfor i in 0...5 { for j in 0...5 { print (i + j) //break from outer loop if i + j == 5 if (i + j == 5) { break } } } It will just break the inner loop but not the outer loop.\nThere is one way where we can use a boolean flag and set it to true when we found the first condition true and every time we check inside the outer loop for that flag.\nThere is another way where we can move this to a function and return from the function when the first time condition met.\nBut there is a simpler way in swift which can help us here. we can name the loops as per the requirement and can break them using the name of the loop as below.\nouterLoop: for i in 0...5 { innerLoop: for j in 0...5 { print (i + j) //break from outer loop if i + j == 5 if (i + j == 5) { break outerLoop } } } We can skip the label if we are not going to use it inside.\nThese label statement can be used with if statement, for-loop, while-loop, repeat and switch statement which makes our life super easy.\n","tags":["Swift"],"title":"Labeled Statement : Swift"}]